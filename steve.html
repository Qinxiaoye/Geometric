<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={334:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},13:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return ZA},load:function(){return YA}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return y},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return k},fromQuat2:function(){return V},fromRotation:function(){return O},fromRotationTranslation:function(){return E},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return F},fromScaling:function(){return P},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return D},frustum:function(){return G},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return T},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ee},multiplyScalarAndAdd:function(){return Ve},normalFromMat4:function(){return we},projection:function(){return Pe},rotate:function(){return Te},scale:function(){return be},set:function(){return de},str:function(){return Oe},sub:function(){return _e},subtract:function(){return De},translate:function(){return ye},transpose:function(){return fe}}),n(334);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(o*O-r*R-a*P)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*T)*M,e[7]=(u*S-p*b+f*T)*M,e[8]=(i*O-s*w+c*A)*M,e[9]=(r*w-n*O-a*A)*M,e[10]=(g*C-m*b+v*y)*M,e[11]=(d*b-u*C-f*y)*M,e[12]=(s*I-i*P-l*A)*M,e[13]=(n*P-r*I+o*A)*M,e[14]=(m*T-g*x-h*y)*M,e[15]=(u*x-d*T+p*y)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function T(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],y=t[15],T=n[0],b=n[1],x=n[2],C=n[3];return e[0]=T*r+b*s+x*d+C*m,e[1]=T*o+b*l+x*p+C*h,e[2]=T*a+b*c+x*f+C*v,e[3]=T*i+b*u+x*g+C*y,T=n[4],b=n[5],x=n[6],C=n[7],e[4]=T*r+b*s+x*d+C*m,e[5]=T*o+b*l+x*p+C*h,e[6]=T*a+b*c+x*f+C*v,e[7]=T*i+b*u+x*g+C*y,T=n[8],b=n[9],x=n[10],C=n[11],e[8]=T*r+b*s+x*d+C*m,e[9]=T*o+b*l+x*p+C*h,e[10]=T*a+b*c+x*f+C*v,e[11]=T*i+b*u+x*g+C*y,T=n[12],b=n[13],x=n[14],C=n[15],e[12]=T*r+b*s+x*d+C*m,e[13]=T*o+b*l+x*p+C*h,e[14]=T*a+b*c+x*f+C*v,e[15]=T*i+b*u+x*g+C*y,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,y,T,b,x,C,S,A,I,w,P,O,R=r[0],M=r[1],D=r[2],E=Math.hypot(R,M,D);return E<a?null:(R*=E=1/E,M*=E,D*=E,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],y=t[10],T=t[11],b=R*R*s+i,x=M*R*s+D*o,C=D*R*s-M*o,S=R*M*s-D*o,A=M*M*s+i,I=D*M*s+R*o,w=R*D*s+M*o,P=M*D*s-R*o,O=D*D*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+y*C,e[3]=d*b+m*x+T*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+y*I,e[7]=d*S+m*A+T*I,e[8]=l*w+p*P+h*O,e[9]=c*w+f*P+v*O,e[10]=u*w+g*P+y*O,e[11]=d*w+m*P+T*O,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function O(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,y=i*c;return e[0]=1-(f+m),e[1]=d+y,e[2]=p-v,e[3]=0,e[4]=d-y,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function V(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),E(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,y=s*c,T=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+T)*b,e[2]=(f-y)*b,e[3]=0,e[4]=(p-T)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+y)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function F(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,y=l*c,T=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],P=(1-(m+v))*x,O=(f+b)*x,R=(g-T)*x,M=(f-b)*C,D=(1-(p+v))*C,E=(h+y)*C,V=(g+T)*S,L=(h-y)*S,B=(1-(p+m))*S;return e[0]=P,e[1]=O,e[2]=R,e[3]=0,e[4]=M,e[5]=D,e[6]=E,e[7]=0,e[8]=V,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(P*A+M*I+V*w),e[13]=n[1]+I-(O*A+D*I+L*w),e[14]=n[2]+w-(R*A+E*I+B*w),e[15]=1,e}function k(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function G(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],y=t[2],T=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(y-A)<a?g(e):(d=h-C,p=v-S,f=y-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-T*f,s=T*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*y),e[13]=-(l*h+c*v+u*y),e[14]=-(d*h+p*v+f*y),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],y=e[15],T=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],P=t[8],O=t[9],R=t[10],M=t[11],D=t[12],E=t[13],V=t[14],L=t[15];return Math.abs(n-T)<=a*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-P)<=a*Math.max(1,Math.abs(d),Math.abs(P))&&Math.abs(p-O)<=a*Math.max(1,Math.abs(p),Math.abs(O))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-D)<=a*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(h-E)<=a*Math.max(1,Math.abs(h),Math.abs(E))&&Math.abs(v-V)<=a*Math.max(1,Math.abs(v),Math.abs(V))&&Math.abs(y-L)<=a*Math.max(1,Math.abs(y),Math.abs(L))}var oe=T,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],y=n[6],T=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=y*r+T*i+b*c,e[7]=y*o+T*s+b*u,e[8]=y*a+T*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],y=n*s-r*i,T=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,P=d*h-p*m,O=d*v-f*m,R=p*v-f*h,M=y*R-T*O+b*P+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*O+c*P)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*O-s*w+c*A)*M,e[3]=(o*O-r*R-a*P)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*O-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*T)*M,e[8]=(g*C-m*b+v*y)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Oe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function De(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Ve(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],y=t[6],T=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-y)<=a*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(u-T)<=a*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,_e=De,Fe=n(152),ke=n.n(Fe),Ge=n(177);const Ue=n.n(Ge)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=Symbol("void"),$e={};function qe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{$e[e]=qe})),Ue.console=console.hasOwnProperty("log")?console:$e;const Xe={debug:qe,error:Ue.console.error||qe,info:Ue.console.info||qe,log:Ue.console.log||qe,warn:Ue.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st("_"===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return Object.values(ot).some((t=>e instanceof t))}function gt(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}function mt(e){return e&&e.isA?e.getState():e}function ht(e){setTimeout(e,0)}function vt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function yt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}function o(e){return Object.freeze({unsubscribe:function(){r(e)}})}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et("instance deleted - cannot call any method"),null;const r=n.length;return n.push(e),o(r)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(mt):ft(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort(),i=Object.keys(o).sort();i.forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object:(e,t,n)=>function(){return{...t[n.name]}}};function bt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const xt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(!ke()(t[n.name],o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}return!1}}};function Ct(e){if("object"==typeof e){const t=xt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function St(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${lt(n.name)}`]=Ct(n)(e,t):e[`set${lt(n)}`]=Ct(n)(e,t)}))}function At(e,t,n){bt(e,t,n),St(e,t,n)}function It(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function Pt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;It(e,t,n),wt(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Rt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et("instance deleted - cannot call any method"):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?et("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.shouldUpdate()&&e.requestData&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Mt=Symbol("Event abort");function Dt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}function s(e){return Object.freeze({unsubscribe:function(){i(e)}})}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Mt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et("instance deleted - cannot call any method"),null;const i=a++;return r.push([i,e,o]),r.sort(((e,t)=>t[2]-e[2])),s(i)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={},r={};return e(r,n,t),Object.freeze(r)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Lt(e){return e&&e.isA&&e.isA("vtkObject")}function Bt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Lt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Bt(e,t,n,r)})):Bt(o,t,n,r)}))}return n}function Nt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=()=>{o=null,n||e.apply(l,i)},u=n&&!o;clearTimeout(o),o=setTimeout(c,t),u&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function _t(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let kt=1;const Gt="__root__";function Ut(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+kt++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),bt(e,t,["proxyId","proxyGroup","proxyName"]),At(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;return o[e]}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],o=t.proxyId,a=i(n)||[];for(let t=0;t<a.length;t++){const n=a[t],i=e[`get${lt(n)}`],l={id:o,name:n,value:i?i():void 0},c=s(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!gt(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}function c(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}}function u(){for(;o.length;)o.pop().subscription.unsubscribe()}const d={bind:c,unbind:l,unsubscribe:u,persistent:n};return t.propertyLinkMap[e]=d,d},e.listPropertyNames=()=>s().map((e=>e.name)),e.getPropertyByName=e=>s().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:s()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,ht((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function zt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Wt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&bt(e,t,a)}function Ht(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var jt={algo:Rt,capitalize:st,chain:Vt,debounce:Nt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Dt,EVENT_ABORT:Mt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:bt,getArray:It,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:mt,isVtkObject:Lt,keystore:Ft,measurePromiseExecution:vt,moveToProtected:Ot,newInstance:Et,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:Ht,obj:yt,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,safeArrays:pt,set:St,setArray:wt,setGet:At,setGetArray:Pt,setImmediate:ht,setLoggerFunction:Ye,throttle:_t,traverseInstanceTree:Bt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt},Kt=Object.freeze({__proto__:null,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:ht,measurePromiseExecution:vt,obj:yt,get:bt,set:St,setGet:At,getArray:It,setArray:wt,setGetArray:Pt,moveToProtected:Ot,algo:Rt,EVENT_ABORT:Mt,event:Dt,newInstance:Et,chain:Vt,isVtkObject:Lt,traverseInstanceTree:Bt,debounce:Nt,throttle:_t,keystore:Ft,proxy:Ut,proxyPropertyMapping:zt,proxyPropertyState:Wt,normalizeWheel:Ht,default:jt});const{vtkErrorMacro:$t}=jt;function qt(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)r.setVisited(!0);else{const r=e.createViewNode(n);r&&(r.setParent(e),r.setVisited(!0),t._renderableChildMap.set(n,r),t.children.push(r))}},e.addMissingNodes=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r],a=t._renderableChildMap.get(o);if(void 0!==a)a.setVisited(!0);else{const n=e.createViewNode(o);n&&(n.setParent(e),n.setVisited(!0),t._renderableChildMap.set(o,n),t.children.push(n))}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];-1===t.children.indexOf(o)&&(o.setParent(e),t.children.push(o)),o.setVisited(!0)}},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return $t("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}const Xt={renderable:null,myFactory:null,children:[],visited:!1};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),jt.obj(e,t),jt.event(e,t,"event"),t._renderableChildMap=new Map,jt.get(e,t,["visited"]),jt.setGet(e,t,["_parent","renderable","myFactory"]),jt.getArray(e,t,["children"]),jt.moveToProtected(e,t,["parent"]),qt(e,t)}var Zt={newInstance:jt.newInstance(Yt,"vtkViewNode"),extend:Yt,PASS_TYPES:["Build","Render"]};function Qt(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s},e.registerOverride=(e,n)=>{t.overrides[e]=n}}const Jt={};function en(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jt,n),jt.obj(e,t),Qt(e,t)}var tn={newInstance:jt.newInstance(en,"vtkViewNodeFactory"),extend:en};const nn=Object.create(null);function rn(e,t){nn[e]=t}function on(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}const an={};function sn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,an,n),t.overrides=nn,tn.extend(e,t,n),on(0,t)}var ln={newInstance:jt.newInstance(sn,"vtkOpenGLViewNodeFactory"),extend:sn};function cn(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),T(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}const un={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},At(e,t,["context","keyMatrixTime"]),cn(e,t)}));rn("vtkCamera",dn);const{vtkDebugMacro:pn}=Kt;function fn(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps()),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(pn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();t.context.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const gn={context:null,_openGLRenderWindow:null,selector:null};const mn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gn,n),Zt.extend(e,t,n),bt(e,t,["shaderCache"]),At(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),fn(e,t)}),"vtkOpenGLRenderer");function hn(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkRenderer",mn);const vn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const yn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vn,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),hn(e,t)}));function Tn(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}rn("vtkActor",yn);const bn={context:null,activeTextures:null};const xn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bn,n),Zt.extend(e,t,n),At(e,t,["context"]),bt(e,t,["activeTextures"]),Tn(e,t)}));function Cn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function Sn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function An(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function In(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function wn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Pn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function On(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Rn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Mn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Dn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function En(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function Vn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function Ln(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Bn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Nn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}rn("vtkActor2D",xn);var _n=Pn,Fn=(Cn(),Math.sqrt(50)),kn=Math.sqrt(10),Gn=Math.sqrt(2);function Un(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Fn?10:a>=kn?5:a>=Gn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Fn?10:a>=kn?5:a>=Gn?2:1)}function zn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Wn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=zn,r=(t,n)=>zn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Hn=Wn(zn),jn=Hn.right;Hn.left,Wn((function(e){return null===e?NaN:+e})).center;var Kn=jn;function $n(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function qn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Xn(){}var Yn=.7,Zn=1/Yn,Qn="\\s*([+-]?\\d+)\\s*",Jn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",er="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",tr=/^#([0-9a-f]{3,8})$/,nr=new RegExp(`^rgb\\(${Qn},${Qn},${Qn}\\)$`),rr=new RegExp(`^rgb\\(${er},${er},${er}\\)$`),or=new RegExp(`^rgba\\(${Qn},${Qn},${Qn},${Jn}\\)$`),ar=new RegExp(`^rgba\\(${er},${er},${er},${Jn}\\)$`),ir=new RegExp(`^hsl\\(${Jn},${er},${er}\\)$`),sr=new RegExp(`^hsla\\(${Jn},${er},${er},${Jn}\\)$`),lr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function cr(){return this.rgb().formatHex()}function ur(){return this.rgb().formatRgb()}function dr(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=tr.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?pr(t):3===n?new hr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?fr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?fr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=nr.exec(e))?new hr(t[1],t[2],t[3],1):(t=rr.exec(e))?new hr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=or.exec(e))?fr(t[1],t[2],t[3],t[4]):(t=ar.exec(e))?fr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=ir.exec(e))?Cr(t[1],t[2]/100,t[3]/100,1):(t=sr.exec(e))?Cr(t[1],t[2]/100,t[3]/100,t[4]):lr.hasOwnProperty(e)?pr(lr[e]):"transparent"===e?new hr(NaN,NaN,NaN,0):null}function pr(e){return new hr(e>>16&255,e>>8&255,255&e,1)}function fr(e,t,n,r){return r<=0&&(e=t=n=NaN),new hr(e,t,n,r)}function gr(e){return e instanceof Xn||(e=dr(e)),e?new hr((e=e.rgb()).r,e.g,e.b,e.opacity):new hr}function mr(e,t,n,r){return 1===arguments.length?gr(e):new hr(e,t,n,null==r?1:r)}function hr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function vr(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}`}function yr(){const e=Tr(this.opacity);return`${1===e?"rgb(":"rgba("}${br(this.r)}, ${br(this.g)}, ${br(this.b)}${1===e?")":`, ${e})`}`}function Tr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function br(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function xr(e){return((e=br(e))<16?"0":"")+e.toString(16)}function Cr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new Ar(e,t,n,r)}function Sr(e){if(e instanceof Ar)return new Ar(e.h,e.s,e.l,e.opacity);if(e instanceof Xn||(e=dr(e)),!e)return new Ar;if(e instanceof Ar)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new Ar(i,s,l,e.opacity)}function Ar(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Ir(e){return(e=(e||0)%360)<0?e+360:e}function wr(e){return Math.max(0,Math.min(1,e||0))}function Pr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function Or(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}$n(Xn,dr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:cr,formatHex:cr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return Sr(this).formatHsl()},formatRgb:ur,toString:ur}),$n(hr,mr,qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new hr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new hr(br(this.r),br(this.g),br(this.b),Tr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vr,formatHex:vr,formatHex8:function(){return`#${xr(this.r)}${xr(this.g)}${xr(this.b)}${xr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:yr,toString:yr})),$n(Ar,(function(e,t,n,r){return 1===arguments.length?Sr(e):new Ar(e,t,n,null==r?1:r)}),qn(Xn,{brighter(e){return e=null==e?Zn:Math.pow(Zn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Yn:Math.pow(Yn,e),new Ar(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new hr(Pr(e>=240?e-240:e+120,o,r),Pr(e,o,r),Pr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new Ar(Ir(this.h),wr(this.s),wr(this.l),Tr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Tr(this.opacity);return`${1===e?"hsl(":"hsla("}${Ir(this.h)}, ${100*wr(this.s)}%, ${100*wr(this.l)}%${1===e?")":`, ${e})`}`}}));var Rr=e=>()=>e;function Mr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Rr(isNaN(e)?t:e)}var Dr=function e(t){var n=function(e){return 1==(e=+e)?Mr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Rr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=mr(e)).r,(t=mr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Mr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Er(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=mr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function Vr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Ur(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Lr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Br(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Nr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Ur(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Er((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return Or((n-r/t)*t,i,o,a,s)}})),Er((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return Or((n-r/t)*t,o,a,i,s)}}));var _r=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Fr=new RegExp(_r.source,"g");function kr(e,t){var n,r,o,a=_r.lastIndex=Fr.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=_r.exec(e))&&(r=Fr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Br(n,r)})),a=Fr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Gr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Ur(e,t){var n,r=typeof t;return null==t||"boolean"===r?Rr(t):("number"===r?Br:"string"===r?(n=dr(t))?(t=n,Dr):kr:t instanceof dr?Dr:t instanceof Date?Lr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Gr:Array.isArray(t)?Vr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Nr:Br)(e,t)}function zr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Wr(e){return+e}var Hr=[0,1];function jr(e){return e}function Kr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function $r(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Kr(o,r),a=n(i,a)):(r=Kr(r,o),a=n(a,i)),function(e){return a(r(e))}}function qr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Kr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=Kn(e,t,1,r)-1;return a[n](o[n](t))}}function Xr(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function Yr(){return function(){var e,t,n,r,o,a,i=Hr,s=Hr,l=Ur,c=jr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==jr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?qr:$r,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Br)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Wr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=zr,u()},d.clamp=function(e){return arguments.length?(c=!!e||jr,u()):c!==jr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(jr,jr)}function Zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Qr,Jr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function eo(e){if(!(t=Jr.exec(e)))throw new Error("invalid format: "+e);var t;return new to({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function to(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function no(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function ro(e){return(e=no(Math.abs(e)))?e[1]:NaN}function oo(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}eo.prototype=to.prototype,to.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var ao={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>oo(100*e,t),r:oo,s:function(e,t){var n=no(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Qr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+no(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function io(e){return e}var so,lo,co,uo=Array.prototype.map,po=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];function fo(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Un(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Fn?o*=10:a>=kn?o*=5:a>=Gn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=eo(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3)))-ro(Math.abs(e)))}(a,i))||(r.precision=o),co(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,ro(t)-ro(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-ro(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return lo(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Un(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function go(){var e=Yr();return e.copy=function(){return Xr(e,go())},Zr.apply(e,arguments),fo(e)}so=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?io:(t=uo.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?io:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(uo.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"−":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=eo(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,y=e.type;"n"===y?(m=!0,y="g"):ao[y]||(void 0===h&&(h=12),v=!0,y="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var T="$"===p?o:"#"===p&&/[boxX]/.test(y)?"0"+y.toLowerCase():"",b="$"===p?a:/[%p]/.test(y)?l:"",x=ao[y],C=/[defgprs%]/.test(y);function S(e){var o,a,l,p=T,S=b;if("c"===y)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===y?po[8+Qr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(y)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=eo(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(ro(t)/3))),o=Math.pow(10,-r),a=po[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),lo=so.format,co=so.formatPrefix;var mo=n(640),ho=n.n(mo);const vo=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],yo=[1,0,0,0,1,0,0,0,1],To=1e-6,bo=1e-12,{vtkErrorMacro:xo,vtkWarningMacro:Co}=jt;let So=0;function Ao(e){return()=>xo(`vtkMath::${e} - NOT IMPLEMENTED`)}function Io(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function wo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function Po(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function Oo(e){return e/180*Math.PI}function Ro(e){return 180*e/Math.PI}const{round:Mo,floor:Do,ceil:Eo,min:Vo,max:Lo}=Math;const Bo=Ao("ceilLog2"),No=Ao("factorial");function _o(e){let t=1;for(;t<e;)t*=2;return t}function Fo(e){return e===_o(e)}const ko=Ao("gaussian");function Go(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Uo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function zo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Wo(e,t){return e[0]*=t,e[1]*=t,e}function Ho(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function jo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ko(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function $o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function qo(e){const t=$o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function Xo(e,t){return e[0]*t[0]+e[1]*t[1]}function Yo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Qo(e){const t=Zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Jo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function ea(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function ta(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function na(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function ra(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function oa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:To;if(e.length!==t.length)return!1;function r(e,r){return Math.abs(e-t[r])<=n}return e.every(r)}const aa=oa;function ia(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function sa(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function la(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ca(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ca(e[0],n),t[1]=ca(e[1],n),t[2]=ca(e[2],n),t}function da(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,y,T;const b=Po(t),x=Po(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(sa(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),y=1/Math.sqrt(1+p*p),m=p*y,f=m/(1+y),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return Co("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,T=n[i],o=a+1;o<t;o++)(n[o]>=T||Math.abs(n[o]-T)<bo)&&(i=o,T=n[i]);i!==a&&(n[i]=n[a],n[a]=T,wo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function pa(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];da([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function fa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=Po(3),r=Po(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(wo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,wo(t,3,1,2)),r[2]=2;let u=0;if(ra(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=Po(4);if(pa(t,d),la(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&wo(t,3,r[1],1),0!==r[0]&&wo(t,3,r[0],0)}function ga(e,t,n){let r,o,a,i,s,l;if(da([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(na(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,Io(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Ko([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);qo(e);const c=Ko(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void na(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,Io(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,Io(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);ra(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),na(n,n)}else ia(n)}function ma(e,t,n){let r,o,a,i,s,l,c,u=0;const d=Po(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return Co("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=bo)return Co("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ha(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function va(e,t,n){if(2===n){const n=Po(2),r=Jo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=Po(n);return 0===ma(e,r,n)?0:(ha(e,r,t,n),1)}function ya(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const a=r||Po(n),i=o||Po(n);if(0===ma(e,a,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)i[e]=0;i[r]=1,ha(e,a,i,n);for(let e=0;e<n;e++)t[e*n+r]=i[e]}return t}function Ta(e,t,n,r){if(e<n)return Co("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=Po(n*n),l=Po(n),c=Po(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(da(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ba(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?.3333333333333333+s*(i-o)/(l-c):.6666666666666666+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function xa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function Ca(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function Sa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function Aa(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function Ia(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function wa(e,t){const n=[0,0,0];Ia(e,n),Sa(n,t)}function Pa(e,t){const n=[0,0,0];Ca(e,n),Aa(n,t)}function Oa(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function Ra(e){return!(e[1]-e[0]<0)}function Ma(e,t,n){return e<t?t:e>n?n:e}function Da(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=Ma(e[0],t[0],n[0]),r[1]=Ma(e[1],t[1],n[1]),r[2]=Ma(e[2],t[2],n[2]),r}const Ea=Ao("GetScalarTypeFittingRange"),Va=Ao("GetAdjustedScalarRange");const La=e=>!Number.isFinite(e),{isFinite:Ba,isNaN:Na}=Number,_a=Na;function Fa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function ka(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ga(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ua(e){return Math.round(255*e)}var za={Pi:()=>Math.PI,radiansFromDegrees:Oo,degreesFromRadians:Ro,round:Mo,floor:Do,ceil:Eo,ceilLog2:Bo,min:Vo,max:Lo,arrayMin:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0;for(let o=t,a=e.length;o<a;o+=n)e[o]<r&&(r=e[o]);return r},arrayMax:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=-1/0;for(let o=t,a=e.length;o<a;o+=n)r<e[o]&&(r=e[o]);return r},arrayRange:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=1/0,o=-1/0;for(let a=t,i=e.length;a<i;a+=n)e[a]<r&&(r=e[a]),o<e[a]&&(o=e[a]);return[r,o]},isPowerOfTwo:Fo,nearestPowerOfTwo:_o,factorial:No,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=Po(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){ho()(`${e}`,{global:!0}),So=e},getSeed:function(){return So},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=t-e;return e+n*Math.random()},gaussian:ko,add:Go,subtract:Uo,multiplyScalar:zo,multiplyScalar2D:Wo,multiplyAccumulate:Ho,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:jo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Ko,norm:$o,normalize:qo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=jo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=jo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return zo(n,o),!0},projectVector2D:function(e,t,n){const r=Xo(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=Xo(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Wo(n,o),!0},distance2BetweenPoints:Yo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Ko(e,t,n),Math.atan2($o(n),jo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:Xo,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Zo,normalize2D:Qo,determinant2x2:Jo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(Io(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,Io(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Jo(s,u,l,d),f=-Jo(i,c,l,d),g=+Jo(i,c,s,u),m=-Jo(o,u,a,d),h=+Jo(r,c,a,d),v=-Jo(r,c,o,u),y=+Jo(o,s,a,l),T=-Jo(r,i,a,l),b=+Jo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+y*t[2],S=f*t[0]+h*t[1]+T*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:ea,multiply3x3_mat3:ta,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&xo("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:na,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Jo(i,c,s,u),p=-Jo(a,l,s,u),f=+Jo(a,l,i,c),g=-Jo(r,c,o,u),m=+Jo(n,l,o,u),h=-Jo(n,l,r,c),v=+Jo(r,i,o,s),y=-Jo(n,a,o,s),T=+Jo(n,a,r,i),b=n*d+r*p+o*f;0===b&&Co("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=y/b,t[8]=T/b},identity3x3:ia,identity:sa,isIdentity:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,vo,t)},isIdentity3x3:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:To;return aa(e,yo,t)},determinant3x3:ra,quaternionToMatrix3x3:la,areEquals:oa,areMatricesEqual:aa,roundNumber:ca,roundVector:ua,matrix3x3ToQuaternion:pa,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],y=e[3]*t[3];n[0]=r-l-f-y,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:fa,diagonalize3x3:ga,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=ra(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];fa(a,t),na(a,a),ta(a,t,r),ga(r,n,r),ta(t,r,t),na(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:va,invertMatrix:ya,luFactorLinearSystem:ma,luSolveLinearSystem:ha,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return da(e,3,t,n)},jacobiN:da,solveHomogeneousLeastSquares:Ta,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return Co("Insufficient number of samples. Underdetermined."),0;const s=Po(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>bo&&(p=0,s[u]=0);if(p&&1===o)return Co("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),Ta(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=Po(n),f=Ta(e,t,n,l));const m=Po(n*n),h=Po(n*n),v=Po(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const y=ya(m,h,n);if(y)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&y:y},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ba,hsv2rgb:xa,lab2xyz:Ca,xyz2lab:Sa,xyz2rgb:Aa,rgb2xyz:Ia,rgb2lab:wa,lab2rgb:Pa,uninitializeBounds:Oa,areBoundsInitialized:Ra,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:Ma,clampVector:Da,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ea,getAdjustedScalarRange:Va,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=Po(3),a=Po(3),i=Po(3),s=Po(3),l=Po(3),c=Po(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=$o(s),d=$o(l),p=$o(i),f=Po(3);Ko(o,a,f);const g=$o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*jo(o,c)/h,y=p*p*jo(s,a)/h,T=u*u*jo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+y*t[o]+T*n[o];return m},inf:1/0,negInf:-1/0,isInf:La,isNan:Na,isNaN:Na,isFinite:Ba,createUninitializedBounds:Fa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:ka,floatToHex2:Ga,floatRGB2HexCode:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";return`${t}${e.map(Ga).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ua).join(", ")})`:`rgba(${Ua(e[0]||0)}, ${Ua(e[1]||0)}, ${Ua(e[2]||0)}, ${e[3]||0})`}};const Wa=1e-6,Ha="coincide",ja="disjoint";function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=jo(e,t);let o=jo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Uo(e,t,o);const a=jo(n,o),i=jo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Uo(t,e,a),Uo(n,e,i);const s=jo(r,i),l=jo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Ko(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Uo(e,n,r),0===jo(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-jo(t,e),u=-jo(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Go(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha};function Ja(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}const ei={normal:[0,0,1],origin:[0,0,0]};function ti(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ei,n),jt.obj(e,t),jt.setGetArray(e,t,["normal","origin"],3),Ja(e,t)}var ni={newInstance:jt.newInstance(ti,"vtkPlane"),extend:ti,...Qa};const ri=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function oi(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ai(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ii(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function si(e){return ii(e,ri)}function li(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function ci(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)li(e,...t[n]);else for(let n=0;n<t.length;n+=3)li(e,...t.slice(n,n+3));return e}function ui(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function pi(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function fi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function gi(e,t,n,r){return!!ai(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function mi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function hi(e,t){return e[2*t+1]-e[2*t]}function vi(e){return[hi(e,0),hi(e,1),hi(e,2)]}function yi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function bi(e){return e.slice(4,6)}function xi(e){const t=vi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function Ci(e){if(ai(e)){const t=vi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Si(e){return[e[0],e[2],e[4]]}function Ai(e){return[e[1],e[3],e[5]]}function Ii(e,t){return e<=0&&t>=0||e>=0&&t<=0}function wi(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function Pi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=wi(e,[]);for(let e=0;e<r.length;++e)Vn(r[e],r[e],t);return si(n),ci(n,r)}function Ri(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Mi(e,t,n,r){const o=[].concat(ri),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=jo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=jo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=jo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Di(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ni.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ai(e)||!ai(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Li(e,t){if(!ai(e)||!ai(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Bi(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Ni(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ni.evaluate(n,t,l)}let i=2;for(;i--&&!(Ii(o[r[i][0]],o[r[i][4]])&&Ii(o[r[i][1]],o[r[i][5]])&&Ii(o[r[i][2]],o[r[i][6]])&&Ii(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class _i{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ri))}getBounds(){return this.bounds}equals(e){return oi(this.bounds,e)}isValid(){return ai(this.bounds)}setBounds(e){return ii(this.bounds,e)}reset(){return si(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return li(this.bounds,...t)}addPoints(e){return ci(this.bounds,e)}addBounds(e,t,n,r,o,a){return ui(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return di(this.bounds,e,t,n)}setMaxPoint(e,t,n){return pi(this.bounds,e,t,n)}inflate(e){return fi(this.bounds,e)}scale(e,t,n){return gi(this.bounds,e,t,n)}getCenter(){return mi(this.bounds)}getLength(e){return hi(this.bounds,e)}getLengths(){return vi(this.bounds)}getMaxLength(){return xi(this.bounds)}getDiagonalLength(){return Ci(this.bounds)}getMinPoint(){return Si(this.bounds)}getMaxPoint(){return Ai(this.bounds)}getXRange(){return yi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return bi(this.bounds)}getCorners(e){return wi(this.bounds,e)}computeCornerPoints(e,t){return Pi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Mi(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Ri(this.bounds,e)}cutWithPlane(e,t){return Ni(this.bounds,e,t)}intersectBox(e,t,n,r){return Di(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Li(this.bounds,e)}containsPoint(e,t,n){return Bi(this.bounds,e,t,n)}contains(e){return Li(this.bounds,e)}}var Fi,ki={newInstance:function(e){const t=e&&e.bounds;return new _i(t)},equals:oi,isValid:ai,setBounds:ii,reset:si,addPoint:li,addPoints:ci,addBounds:ui,setMinPoint:di,setMaxPoint:pi,inflate:fi,scale:gi,scaleAboutCenter:function(e,t,n,r){if(!ai(e))return!1;const o=mi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],gi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:mi,getLength:hi,getLengths:vi,getMaxLength:xi,getDiagonalLength:Ci,getMinPoint:Si,getMaxPoint:Ai,getXRange:yi,getYRange:Ti,getZRange:bi,getCorners:wi,computeCornerPoints:Pi,computeLocalBounds:Mi,transformBounds:Oi,computeScale3:Ri,cutWithPlane:Ni,intersectBox:Di,intersectPlane:Ei,intersect:Vi,intersects:Li,containsPoint:Bi,contains:function(e,t){return!!Li(e,t)&&!!Bi(e,...Si(t))&&!!Bi(e,...Ai(t))},INIT_BOUNDS:ri};function Gi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ui(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function zi(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Wi(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Fi=new i(4),i!=Float32Array&&(Fi[0]=0,Fi[1]=0,Fi[2]=0,Fi[3]=0);var Hi=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};Cn(),An(1,0,0),An(0,1,0),Ui(),Ui(),ie();var ji={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Ki}=ji;function $i(e){return()=>jt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}function qi(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=$i("pick"),e.hasKey=$i("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Ki.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Ki.DISPLAY)}const Xi={allocatedRenderTime:10,coordinateSystem:Ki.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function Yi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xi,n),jt.obj(e,t),jt.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),jt.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),jt.moveToProtected(e,t,["parentProp"]),qi(e,t)}var Zi={newInstance:jt.newInstance(Yi,"vtkProp"),extend:Yi,...ji};function Qi(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ui();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[Ro(r),n[0],n[1],n[2]]},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,Oo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=Oo(n),s=Ui();zi(s,[r,o,a],i);const l=new Float64Array(16);k(l,s),T(t.rotation,t.rotation,l),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!aa(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&T(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),T(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getCenter=()=>ki.getCenter(t.bounds),e.getLength=()=>ki.getLength(t.bounds),e.getXRange=()=>ki.getXRange(t.bounds),e.getYRange=()=>ki.getYRange(t.bounds),e.getZRange=()=>ki.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()}))}const Ji={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[1,-1,1,-1,1,-1],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Zi.extend(e,t,n),t.matrixMTime={},jt.obj(t.matrixMTime),jt.get(e,t,["bounds","isIdentity"]),jt.getArray(e,t,["orientation"]),jt.setGetArray(e,t,["origin","position","scale"],3),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,Qi(e,t)}var ts={newInstance:jt.newInstance(es,"vtkProp3D"),extend:es};const ns={FLAT:0,GOURAUD:1,PHONG:2},rs={POINTS:0,WIREFRAME:1,SURFACE:2};var os={Shading:ns,Representation:rs,Interpolation:ns};const{Representation:as,Interpolation:is}=os;function ss(e){return()=>jt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}function ls(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ss("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ss("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(is.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(is.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(is.PHONG),e.getInterpolationAsString=()=>jt.enumToString(is,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(as.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(as.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(as.POINTS),e.getRepresentationAsString=()=>jt.enumToString(as,t.representation)}const cs={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:is.GOURAUD,representation:as.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null};function us(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cs,n),jt.obj(e,t),jt.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture"]),jt.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),ls(e,t)}var ds={newInstance:jt.newInstance(us,"vtkProperty"),extend:us,...os};const{vtkDebugMacro:ps}=jt;function fs(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(null===t.property&&e.setProperty(e.makeProperty()),!e.getIsOpaque()),e.makeProperty=ds.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||n[0]!==t.mapperBounds[0]||n[1]!==t.mapperBounds[1]||n[2]!==t.mapperBounds[2]||n[3]!==t.mapperBounds[3]||n[4]!==t.mapperBounds[4]||n[5]!==t.mapperBounds[5]||e.getMTime()>t.boundsMTime.getMTime()){ps("Recomputing bounds..."),t.mapperBounds=n.concat();const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}return t.bounds},e.getMTime=()=>{let e=n.getMTime();if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}const gs={mapper:null,property:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1,bounds:[1,-1,1,-1,1,-1]};function ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gs,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),fs(e,t)}var hs={newInstance:jt.newInstance(ms,"vtkActor"),extend:ms};const vs={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},ys={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var Ts={DefaultDataType:ys.FLOAT,DataTypeByteSize:vs,VtkDataTypes:ys};const{vtkErrorMacro:bs}=Kt,{DefaultDataType:xs}=Ts,Cs=1e-6;function Ss(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function As(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return Ss(r,0,1)}return Ss(e,t<0?0:t,n)}function Is(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function ws(e){return Object.prototype.toString.call(e).slice(8,-1)}const Ps={computeRange:As,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get:()=>({min:e,max:t,count:n,sum:r,mean:r/n}),getRange:()=>({min:e,max:t})}},fastComputeRange:Ss,getDataType:ws,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=$o(r,t);a>n&&(n=a)}return n}};function Os(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=As(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=Is(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Cs;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return e*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>Ds({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=ws(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||bs("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}const Rs={name:"",numberOfComponents:1,dataType:xs,rangeTuple:[0,0]};function Ms(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Rs,n),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=ws(t.values)),yt(e,t),St(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");Os(e,t)}const Ds=Et(Ms,"vtkDataArray");var Es={newInstance:Ds,extend:Ms,...Ps,...Ts};function Vs(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}jt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}const Ls={clippingPlanes:[]};var Bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ls,n),jt.obj(e,t),jt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),Vs(e,t)};function Ns(e,t){e.getBounds=()=>(jt.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Fa()),e.getCenter=()=>{const n=e.getBounds();return t.center=ki.isValid(n)?ki.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return ki.getDiagonalLength(t)}}const _s=e=>({bounds:[...ki.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e});var Fs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_s(n)),Bs(e,t,n),jt.setGet(e,t,["viewSpecificProperties"]),Ns(e,t)};const{vtkErrorMacro:ks,vtkWarningMacro:Gs}=jt;function Us(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else ks("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Es.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:jt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Gs("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else ks("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Es.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:jt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}const zs={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ws(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zs,n),jt.obj(e,t),Us(e,t)}var Hs={newInstance:jt.newInstance(Ws,"vtkFieldData"),extend:Ws};const js={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ks={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:js,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:$s,AttributeCopyOperations:qs}=Ks,{vtkWarningMacro:Xs}=jt;function Ys(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>$s[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Xs(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Xs(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Xs(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[qs.PASSDATA][$s[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(qs).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[qs[e]]=Object.keys($s).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[$s[t]]=!0,e)),[])})),t.copyAttributeFlags[qs.COPYTUPLE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.INTERPOLATE][$s.GLOBALIDS]=!1,t.copyAttributeFlags[qs.COPYTUPLE][$s.PEDIGREEIDS]=!1},e.initialize=jt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Es.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}const Zs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zs,n),Hs.extend(e,t,n),jt.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),Ys(e,t)}var Js={newInstance:jt.newInstance(Qs,"vtkDataSetAttributes"),extend:Qs,...Ks};const el=["pointData","cellData","fieldData"];function tl(e,t){t.classHierarchy.push("vtkDataSet"),el.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Js.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),el.forEach((n=>{t[n]=Js.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}const nl={};function rl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nl,n),jt.obj(e,t),jt.setGet(e,t,el),tl(e,t)}var ol={newInstance:jt.newInstance(rl,"vtkDataSet"),extend:rl,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const al={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var il={StructuredType:al};const{StructuredType:sl}=il;var ll={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?sl.EMPTY:3===t?sl.XYZ_GRID:2===t?e[0]===e[1]?sl.YZ_PLANE:e[2]===e[3]?sl.XZ_PLANE:sl.XY_PLANE:1===t?e[0]<e[1]?sl.X_LINE:e[2]<e[3]?sl.Y_LINE:sl.Z_LINE:sl.SINGLE_POINT},...il};const{vtkErrorMacro:cl}=jt;function ul(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return cl("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=ll.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)cl("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void cl("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return cl("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case al.EMPTY:return null;case al.SINGLE_POINT:break;case al.X_LINE:o[0]=n;break;case al.Y_LINE:o[1]=n;break;case al.Z_LINE:o[2]=n;break;case al.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case al.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case al.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case al.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:cl("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>ki.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>ki.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Vn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return ki.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>ki.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];ki.computeCornerPoints(r,o,a),ua(o,o),ua(a,a);const i=e.getDimensions();Da(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Da(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0,v=Math.sqrt(h);return{minimum:d,maximum:u,average:m,variance:h,sigma:v,count:g}},e.computeIncrements=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const n=[];let r=t;for(let t=0;t<3;++t)n[t]=r,r*=e[2*t+1]-e[2*t]+1;return n},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return cl(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return cl(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}const dl={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:al.EMPTY};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),ol.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),jt.get(e,t,["indexToWorld","worldToIndex"]),jt.setGetArray(e,t,["origin","spacing"],3),jt.setGetArray(e,t,["direction"],9),jt.getArray(e,t,["extent"],6),ul(e,t)}var fl={newInstance:jt.newInstance(pl,"vtkImageData"),extend:pl};const gl={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var ml={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:gl},hl={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:vl,VectorMode:yl}=ml,{VtkDataTypes:Tl}=Es,{ColorMode:bl}=hl,{vtkErrorMacro:xl}=jt;function Cl(e){return e}function Sl(e){return Math.floor(255*e+.5)}function Al(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(yl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(yl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(yl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)xl("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===bl.DEFAULT&&t.getDataType()===Tl.UNSIGNED_CHAR||n===bl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Tl.UNSIGNED_CHAR},i=jt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Es.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,vl.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,vl.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===yl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==yl.MAGNITUDE||1!==c&&1!==s||(i=yl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case yl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case yl.RGBCOLORS:break;case yl.MAGNITUDE:default:{const o=Es.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=Sl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Tl.UNSIGNED_CHAR)return n;const i=Es.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Tl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=Cl;switch(n.getDataType()!==Tl.FLOAT&&n.getDataType()!==Tl.DOUBLE||(s=Sl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return xl("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==bl.DEFAULT||n.getDataType()!==Tl.UNSIGNED_CHAR)&&r!==bl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}const Il={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:yl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1};function wl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Il,n),jt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],jt.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),jt.setArray(e,t,["mappingRange"],2),jt.getArray(e,t,["mappingRange"]),Al(e,t)}var Pl={newInstance:jt.newInstance(wl,"vtkScalarsToColors"),extend:wl,...ml};const{vtkErrorMacro:Ol}=jt;function Rl(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=_a(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===gl.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,xa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return Ol("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==ys.UNSIGNED_CHAR)return Ol("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}const Ml={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function Dl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ml,n),Pl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},jt.obj(t.buildTime),t.opaqueFlagBuildTime={},jt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},jt.obj(t.insertTime,{mtime:0}),jt.get(e,t,["buildTime"]),jt.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),jt.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),Rl(e,t)}var El={newInstance:jt.newInstance(Dl,"vtkLookupTable"),extend:Dl};let Vl=1,Ll=0;const Bl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function Nl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;Ll=e}var _l={getResolveCoincidentTopologyAsString:function(){return Bl[Ll]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return Vl},getResolveCoincidentTopology:function(){return Ll},setResolveCoincidentTopology:Nl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){Vl=e},setResolveCoincidentTopologyToDefault:function(){Nl(0)},setResolveCoincidentTopologyToOff:function(){Nl(0)},setResolveCoincidentTopologyToPolygonOffset:function(){Nl(1)}};function Fl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=(e,r)=>{t[n.key]={factor:e,offset:r}}}))}const kl=["Polygon","Line","Point"],Gl={};Fl(Gl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},kl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Ul={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),jt.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(_l).forEach((t=>{e[t]=_l[t]})),Object.keys(Gl).forEach((t=>{e[t]=Gl[t]})),Fl(e,t.topologyOffset,kl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Gl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Gl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Gl,otherStaticMethods:_l,CATEGORIES:kl};const zl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Wl={PassTypes:zl};const{FieldAssociations:Hl}=ol,{staticOffsetAPI:jl,otherStaticMethods:Kl}=Ul,{ColorMode:$l,ScalarMode:ql,GetArray:Xl}=hl,{VectorMode:Yl}=ml,{VtkDataTypes:Zl}=Es;function Ql(e){return()=>jt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Jl(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString($l,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(ql,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===ql.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===ql.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===ql.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===ql.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===ql.USE_FIELD_DATA){const t=e.getFieldData();i=r===Xl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==a){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(n))e.mapScalarsToTexture(o,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},e.scalarToTextureCoordinate=(e,t,n)=>{let r=.5,o=1;return _a(e)||(o=.49,r=(e-t)*n,r>1e3?r=1e3:r<-1e3&&(r=-1e3)),{texCoordS:r,texCoordT:o}},e.createColorTextureCoordinates=(t,n,r,o,a,i,s,l,c)=>{const u=(i[1]-i[0])/l,d=[];d[0]=i[0]-u,d[1]=i[1]+u;const p=1/(d[1]-d[0]),f=n.getData(),g=t.getData();let m=0,h=0;if(a<0||a>=o)for(let t=0;t<r;++t){let t=0;for(let e=0;e<o;++e)t+=g[m]*g[m],m++;let n=Math.sqrt(t);c&&(n=El.applyLogScale(n,s,i));const r=e.scalarToTextureCoordinate(n,d[0],p);f[h]=r.texCoordS,f[h+1]=r.texCoordT,h+=2}else{m+=a;for(let t=0;t<r;++t){let t=g[m];c&&(t=El.applyLogScale(t,s,i));const n=e.scalarToTextureCoordinate(t,d[0],p);f[h]=n.texCoordS,f[h+1]=n.texCoordT,h+=2,m+=o}}},e.mapScalarsToTexture=(n,r)=>{const o=t.lookupTable.getRange(),a=t.lookupTable.usingLogScale();a&&El.getLogRange(o,o);const i=t.lookupTable.getAlpha();if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==r){t.lookupTable.setAlpha(r),t.colorTextureMap=null,t.lookupTable.build();let e=t.lookupTable.getNumberOfAvailableColors();e>4094&&(e=4094),e<64&&(e=64),e+=2;const n=(o[1]-o[0])/(e-2),s=new Float64Array(2*e);for(let t=0;t<e;++t)s[t]=o[0]+t*n-n/2,a&&(s[t]=10**s[t]);for(let t=0;t<e;++t)s[t+e]=NaN;t.colorTextureMap=fl.newInstance(),t.colorTextureMap.setExtent(0,e-1,0,1,0,0);const l=Es.newInstance({numberOfComponents:1,values:s});t.colorTextureMap.getPointData().setScalars(t.lookupTable.mapScalars(l,t.colorMode,0)),t.lookupTable.setAlpha(i)}if(!t.colorCoordinates||e.getMTime()>t.colorCoordinates.getMTime()||e.getInputData(0).getMTime()>t.colorCoordinates.getMTime()||t.lookupTable.getMTime()>t.colorCoordinates.getMTime()){t.colorCoordinates=null;const r=n.getNumberOfComponents(),i=n.getNumberOfTuples();t.colorCoordinates=Es.newInstance({numberOfComponents:2,values:new Float32Array(2*i)});let s=t.lookupTable.getVectorComponent();t.lookupTable.getVectorMode()===Yl.MAGNITUDE&&n.getNumberOfComponents()>1&&(s=-1),e.createColorTextureCoordinates(n,t.colorCoordinates,i,r,s,o,t.lookupTable.getRange(),t.colorTextureMap.getPointData().getScalars().getNumberOfTuples()/2-2,a)}},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=n=>{if(!t.interpolateScalarsBeforeMapping)return!1;if(t.lookupTable&&t.lookupTable.getIndexedLookup())return!1;const r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName),o=r.scalars;return!(!o||r.cellFlag||t.colorMode===$l.DEFAULT&&o.getDataType()===Zl.UNSIGNED_CHAR||t.colorMode===$l.DIRECT_SCALARS)},e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ql("AcquireInvertibleLookupTable"),e.valueToColor=Ql("ValueToColor"),e.colorToValue=Ql("ColorToValue"),e.useInvertibleColorFor=Ql("UseInvertibleColorFor"),e.clearInvertibleColor=Ql("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(zl.ID_LOW24),o=e.getRawPixelBuffer(zl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Hl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Hl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===zl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(zl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===zl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t],n*=256,n+=r[t+1],n*=256,n+=r[t+2];const a=s[n];e.getPixelBuffer(zl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}const ec={colorMapColors:null,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Fs(e,t,n),jt.get(e,t,["colorCoordinates","colorMapColors","colorTextureMap","selectionWebGLIdsToVTKIds"]),jt.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),Ul.implementCoincidentTopologyMethods(e,t),Jl(e,t)}var nc={newInstance:jt.newInstance(tc,"vtkMapper"),extend:tc,...jl,...Kl,...hl};function rc(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function oc(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const ac={extractCellSizes:rc,getNumberOfCells:oc};function ic(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=oc(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=rc(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{const r=e.getNumberOfCells();return e.insertNextTuples([n.length,...n]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(n.length),r}}function sc(e){return{empty:!0,numberOfComponents:1,dataType:ys.UNSIGNED_INT,...e}}function lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Es.extend(e,t,sc(n)),ic(e,t)}var cc={newInstance:jt.newInstance(lc,"vtkCellArray"),extend:lc,...ac};const{vtkErrorMacro:uc}=jt,dc=[1,-1,1,-1,1,-1];function pc(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=jt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return uc(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),dc;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}const fc={empty:!0,numberOfComponents:3,dataType:ys.FLOAT,bounds:[1,-1,1,-1,1,-1]};function gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fc,n),Es.extend(e,t,n),pc(e,t)}var mc={newInstance:jt.newInstance(gc,"vtkPoints"),extend:gc};function hc(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=jt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else Oa(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{jt.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}const vc={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function yc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),jt.obj(e,t),t.points||(t.points=mc.newInstance()),jt.get(e,t,["points","pointsIds"]),hc(e,t)}var Tc={newInstance:jt.newInstance(yc,"vtkCell"),extend:yc};function bc(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Tc.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Tc.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}const xc={array:null,maxId:0,extend:0};function Cc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xc,n),jt.obj(e,t),bc(e,t)}var Sc={newInstance:jt.newInstance(Cc,"vtkCellLinks"),extend:Cc};const Ac=0,Ic=1,wc=2,Pc=3,Oc=4,Rc=5,Mc=6,Dc=7,Ec=9,Vc=21,Lc=41,Bc=42,Nc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],_c={getClassNameFromTypeId:function(e){return e<Nc.length?Nc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return Nc.findIndex(e)},isLinear:function(e){return e<Vc||e===Lc||e===Bc},hasSubCells:function(e){return e===Mc||e===Oc||e===wc}};function Fc(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=Ac},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}const kc={size:0,maxId:-1,extend:1e3};function Gc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kc,n),jt.obj(e,t),jt.get(e,t,["size","maxId","extend"]),jt.getArray(e,t,["typeArray","locationArray"]),Fc(e,t)}var Uc={newInstance:jt.newInstance(Gc,"vtkCellTypes"),extend:Gc,..._c},zc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:Wc}=zc;function Hc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=jo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Yo(i,e),o}function jc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Uo(t,e,i),Uo(r,n,s),Uo(n,e,l);const c=[jo(i,i),-jo(i,s),-jo(i,s),jo(s,s)],u=[];if(u[0]=jo(i,l),u[1]=-jo(s,l),0===va(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Hc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance);return Wc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Wc.YES_INTERSECTION:Wc.NO_INTERSECTION}const Kc={distanceToLine:Hc,intersection:jc};function $c(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=jc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Wc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Yo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Hc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Hc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Hc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Hc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}const qc={orientations:null};function Xc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qc,n),Tc.extend(e,t,n),jt.setGet(e,t,["orientations"]),$c(e,t)}var Yc={newInstance:jt.newInstance(Xc,"vtkLine"),extend:Xc,...Kc,...zc};function Zc(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=mc.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),t.points=mc.newInstance(),t.points.shallowCopy(e.getPoints())}}const Qc={};function Jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qc,n),ol.extend(e,t,n),jt.setGet(e,t,["points"]),Zc(e,t)}var eu={newInstance:jt.newInstance(Jc,"vtkPointSet"),extend:Jc};function tu(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function nu(e,t,n,r){tu(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}const ru={computeNormalDirection:tu,computeNormal:nu,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];nu(e,t,n,d),nu(r,o,a,p);const f=-jo(d,e),g=-jo(p,r),m=[jo(p,e)+g,jo(p,t)+g,jo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[jo(d,r)+f,jo(d,o)+f,jo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],y=[r,o,a],T=jo(d,p),b=(f-g*T)/(T*T-1),x=(g-f*T)/(T*T-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Ko(d,p,[]);qo(S);let A=0,I=0;const w=[],P=[];let O,R,M=50,D=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ni.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=jo(a.x,S)-jo(C,S));const s=ni.intersectWithLine(y[n],y[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(D=I),P[I++]=jo(s.x,S)-jo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=P[2];P[2]=P[D],P[D]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(P[0])||Number.isNaN(P[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(P[0]>P[1]){const e=P[1];P[1]=P[0],P[0]=e}return w[1]<P[0]||P[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<P[0]?w[1]<P[1]?(u[0]=2,u[1]=1,O=P[0],R=w[1]):(u[0]=2,u[1]=2,O=P[0],R=P[1]):w[1]<P[1]?(u[0]=1,u[1]=1,O=w[0],R=w[1]):(u[0]=1,u[1]=2,O=w[0],R=P[1]),Ho(C,S,O,l),Ho(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}};function ou(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(nu(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ni.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Yo(u,d),h=Yo(d,p),v=Yo(p,u);t.line||(t.line=Yc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const y=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=y.betweenPoints,s.t=y.t,y.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=jo(n,e)/v,i[1]=jo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const y=[];let T,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),tu(l,c,u,d),ni.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(y[s++]=i);for(i=0;i<2;i++)f[i]=I[y[i]]-u[y[i]],g[i]=l[y[i]]-u[y[i]],m[i]=c[y[i]]-u[y[i]];if(h=Jo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Jo(f,m)/h,r[1]=Jo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Yo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(T=Yo(e,u),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,u,c,t,A),T<b?(a.dist2=T,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(T=Yo(e,l),b=Yc.distanceToLine(e,l,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(T=Yo(e,c),b=Yc.distanceToLine(e,c,u,t,S),x=Yc.distanceToLine(e,l,c,t,A),T<b?(a.dist2=T,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Yc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Yc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Yc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n}}const au={};function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,au,n),Tc.extend(e,t,n),ou(e,t)}var su={newInstance:jt.newInstance(iu,"vtkTriangle"),extend:iu,...ru};const lu=["verts","lines","polys","strips"],{vtkWarningMacro:cu}=jt,uu={[Pc]:Yc,[Oc]:Yc,[Rc]:su};function du(e,t){t.classHierarchy.push("vtkPolyData"),lu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=cc.newInstance()})),e.getNumberOfCells=()=>lu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n(e,r),lu.forEach((n=>{t[n]=cc.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?wc:Ic,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?Oc:Pc,1===t&&cu("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=Rc;break;case 4:l[n]=Ec;break;default:l[n]=Dc}t<3&&cu("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(Mc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=Uc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=Sc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case Ic:case wc:o=t.verts;break;case Pc:case Oc:o=t.lines;break;case Rc:case Ec:case Dc:o=t.polys;break;case Mc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||uu[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}const pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),eu.extend(e,t,n),jt.get(e,t,["cells","links"]),jt.setGet(e,t,["verts","lines","polys","strips"]),du(e,t)}var gu={newInstance:jt.newInstance(fu,"vtkPolyData"),extend:fu};function mu(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData();if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=document.createElement("canvas");e.width=t.image.width,e.height=t.image.height;const n=e.getContext("2d");return n.translate(0,e.height),n.scale(1,-1),n.drawImage(t.image,0,0,t.image.width,t.image.height),n.getImageData(0,0,e.width,e.height)}return null}}const hu={image:null,canvas:null,jsImageData:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function vu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hu,n),jt.obj(e,t),jt.algo(e,t,6,0),jt.get(e,t,["canvas","image","jsImageData","imageLoaded","resizable"]),jt.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),mu(e,t)}const yu={generateMipmaps:(e,t,n,r)=>{const o=[1,2,1],a=e.length/(t*n);let i=t,s=n,l=e;const c=[l];for(let e=0;e<r;e++){const e=[...l];i/=2,s/=2,l=new Uint8ClampedArray(i*s*a);const t=a*i;let n=0;for(let r=0;r<l.length;r+=a){r%t==0&&(n+=2*a*i);for(let o=0;o<a;o++){let i=e[n+o];i+=e[n+a+o],i+=e[n-2*t+o],i+=e[n-2*t+a+o],i/=4,l[r+o]=i}n+=2*a}let r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let i=-(o.length-1)/2,s=4,c=0;for(let l=0;l<o.length;l++){let u=e+n+i*a;const d=u%t-(e+n)%t;d>a&&(u+=t),d<-a&&(u-=t),r[u]?c+=r[u]*o[l]:s-=o[l],i+=1}l[e+n]=c/s}r=[...l];for(let e=0;e<l.length;e+=a)for(let n=0;n<a;n++){let a=-(o.length-1)/2,i=4,s=0;for(let l=0;l<o.length;l++){const c=e+n+a*t;r[c]?s+=r[c]*o[l]:i-=o[l],a+=1}l[e+n]=s/i}c.push(l)}return c}};var Tu={newInstance:jt.newInstance(vu,"vtkTexture"),extend:vu,...yu};const bu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],xu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],Cu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],Su=[0,1,0,1,0,1,0,1,2,2,2,2],Au=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Iu=new Float64Array(3),wu=new Float64Array(3),Pu=new Float64Array(3),Ou=new Float64Array(3),Ru=new Float64Array(3),Mu=new Float64Array(3),Du=new Float64Array(16);function Eu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vu(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],Vn(Pu,Iu,r),Pu[0]+=.1,Vn(wu,Pu,o),Pn(Ru,wu,Iu),Pu[0]-=.1,Pu[1]+=.1,Vn(wu,Pu,o),Pn(Mu,wu,Iu);for(let e=0;e<3;e++)Ru[e]/=.05*u[0],Mu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Iu[0]=c[3*n],Iu[1]=c[3*n+1],Iu[2]=c[3*n+2],a[0]<-.5?On(Pu,Ru,a[0]*i-l.width):a[0]>.5?On(Pu,Ru,a[0]*i):On(Pu,Ru,a[0]*i-l.width/2),wn(Iu,Iu,Pu),On(Pu,Mu,a[1]*i-l.height/2),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,On(Pu,Ru,l.width),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,On(Pu,Mu,l.height),wn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,On(Pu,Ru,l.width),Pn(Iu,Iu,Pu),s.points[3*d]=Iu[0],s.points[3*d+1]=Iu[1],s.points[3*d+2]=Iu[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(Du,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Iu[0]=f[3*u],Iu[1]=f[3*u+1],Iu[2]=f[3*u+2],Vn(Pu,Iu,n),Iu[0]=f[3*u+3],Iu[1]=f[3*u+4],Iu[2]=f[3*u+5],Vn(Ou,Iu,n),Pn(Pu,Pu,Ou);const r=[Pu[0],Pu[1]];Qo(r),e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Du,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Es.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}const Lu=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),jt.setGet(e,t,["renderable"]),jt.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},jt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],Vu(e,t)}),"vtkCubeAxesActorHelper");function Bu(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=ki.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Iu[s]=t.dataBounds[a]-.1*r*bu[a][s],Iu[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Iu[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),Vn(Pu,Iu,e),Iu[s]=t.dataBounds[a],Vn(Ou,Iu,e),Pn(Pu,Ou,Pu),Mn(Pu,Pu),i=Pu[2]>o,t.camera.getParallelProjection()||(Mn(Ou,Ou),i=Dn(Ou,Pu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Au[t][0]].length+2*r[Au[t][1]].length,a+=r[Au[t][0]].length+r[Au[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=Cu[e][0],l[3*u+2]=Cu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Au[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][0]]=o[r],s[3*c+Au[n][1]]=t.dataBounds[2*Au[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Au[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Au[n][1]]=o[r],s[3*c+Au[n][0]]=t.dataBounds[2*Au[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[Su[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=xu[a][e];if(1===n[d]){const e=Su[d],n=3*Cu[d][0],p=3*Cu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Au[a][0]]=.5*(t.dataBounds[2*Au[a][0]]+t.dataBounds[2*Au[a][0]+1]),s[3*l+Au[a][1]]=.5*(t.dataBounds[2*Au[a][1]]+t.dataBounds[2*Au[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[xu[e][t]]++;const a=[],i=[];for(let e=0;e<3;e++){const n=go().domain([t.dataBounds[2*e],t.dataBounds[2*e+1]]);a[e]=n.ticks(5);const r=n.tickFormat(5);i[e]=a[e].map(r)}e.updatePolyData(r,n,a),e.updateTextData(r,n,a,i),(o||t.forceUpdate)&&e.updateTextureAtlas(i)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Eu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Eu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=_o(n),r=_o(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Eu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),ki.setBounds(t.bounds,t.gridActor.getBounds()),ki.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=jt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}function Nu(e){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...ki.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:12,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},...e}}function _u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nu(n)),hs.extend(e,t,n),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Tu.newInstance(),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=nc.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=hs.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),jt.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset"]),jt.setGetArray(e,t,["dataBounds"],6),jt.setGetArray(e,t,["axisLabels"],3),jt.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),Bu(e,t)}var Fu={newInstance:jt.newInstance(_u,"vtkCubeAxesActor"),extend:_u,newCubeAxesActorHelper:Lu};function ku(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Gu={};const Uu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Zt.extend(e,t,n),t.CubeAxesActorHelper=Fu.newCubeAxesActorHelper(),ku(e,t)}),"vtkOpenGLCubeAxesActor");rn("vtkCubeAxesActor",Uu);const zu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var Wu={ObjectType:zu};const{ObjectType:Hu}=Wu;function ju(e,t){function n(e){switch(e){case Hu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case Hu.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case Hu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}const Ku={objectType:Hu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function $u(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ku,n),jt.obj(e,t),jt.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),ju(e,t)}var qu={newInstance:jt.newInstance($u),extend:$u,...Wu};const{vtkErrorMacro:Xu}=jt;function Yu(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(zu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=qu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,y=0,T=0;const b={anythingToPoints(e,t,n){for(let r=0;r<e;++r)f(t[n+r])},linesToWireframe(e,t,n){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1])},polysToWireframe(e,t,n){if(e>2)for(let r=0;r<e;++r)f(t[n+r]),f(t[n+(r+1)%e])},stripsToWireframe(e,t,n){if(e>2){for(let r=0;r<e-1;++r)f(t[n+r]),f(t[n+r+1]);for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+2])}},polysToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+0]),f(t[n+r+1]),f(t[n+r+2])},stripsToSurface(e,t,n){for(let r=0;r<e-2;r++)f(t[n+r]),f(t[n+r+1+r%2]),f(t[n+r+1+(r+1)%2])}},x={anythingToPoints:(e,t)=>e,linesToWireframe:(e,t)=>e>1?2*(e-1):0,polysToWireframe:(e,t)=>e>2?2*e:0,stripsToWireframe:(e,t)=>e>2?4*e-6:0,polysToSurface:(e,t)=>e>2?3*(e-2):0,stripsToSurface:(e,t,n)=>e>2?3*(e-2):0};let C=null,S=null;o===rs.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===rs.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let P=null;const O=new Float32Array(w*t.blockSize);u&&(P=new Uint8Array(4*w));let R=0,M=0,D=0,E=0;for(let e=0;e<3;++e){const t=a.points.getRange(e),n=t[1]-t[0];D+=n*n;const r=.5*(t[1]+t[0]);E+=r*r}const V=D>0&&(Math.abs(E)/D>1e6||Math.abs(Math.log10(D))>3||0===D&&E>1e6);if(V){const t=new Float64Array(3),n=new Float64Array(3);for(let e=0;e<3;++e){const r=a.points.getRange(e),o=r[1]-r[0];t[e]=.5*(r[1]+r[0]),n[e]=o>0?1/o:1}e.setCoordShiftAndScale(t,n)}else!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null);if(i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e){if(i&&(i.points[L]=e,i.cells[L]=T+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(O[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],O[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],O[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(O[R++]=s[g++],O[R++]=s[g++],O[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(T+a.cellOffset):3*e,O[R++]=l[m++],O[R++]=l[m++],O[R++]=l[m++]),t.customData.forEach((t=>{y=e*t.components;for(let e=0;e<t.components;++e)O[R++]=t.data[y++]})),null!==c){h=e*p;for(let e=0;e<p;++e)O[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(T+a.cellOffset)*d:e*d,P[M++]=u[v++],P[M++]=u[v++],P[M++]=u[v++],P[M++]=4===d?u[v++]:255)};for(let e=0;e<I;)C(A[e],A,e+1),e+=A[e]+1,T++;return t.elementCount=w,e.upload(O,zu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(P,zu.ARRAY_BUFFER)),T},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Nn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Nn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Bn(e,[0,0,0])&&Bn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Rn(n,t);const r=new Float64Array(16);return _(r,Ui(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Xu("Wrong type for coordScale, expected vec3 or null"):Xu("Wrong type for coordShift, expected vec3 or null")}}const Zu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Qu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zu,n),qu.extend(e,t,n),jt.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),jt.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),Yu(e,t)}var Ju={newInstance:jt.newInstance(Qu),extend:Qu};const{vtkErrorMacro:ed}=jt;function td(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return ed(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}const nd={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),jt.obj(e,t),jt.setGet(e,t,["shaderType","source","error","handle","context"]),td(e,t)}var od={newInstance:jt.newInstance(rd,"vtkShader"),extend:rd};const{vtkErrorMacro:ad}=jt;function id(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(ad(`Links failed: ${t.error}`),0):(ad(t.error),0):(ad(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),ad(t.fragmentShader.getError()),0):(ad(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),ad(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return ad(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(ad("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return ad("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}const sd={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sd,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=od.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=od.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=od.newInstance(),t.geometryShader.setShaderType("Geometry"),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),id(e,t)}var cd={newInstance:jt.newInstance(ld,"vtkShaderProgram"),extend:ld,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};function ud(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==zu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}const dd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function pd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dd,n),t.buffers=[],jt.obj(e,t),jt.get(e,t,["supported"]),jt.setGet(e,t,["forceEmulation"]),ud(e,t)}var fd={newInstance:jt.newInstance(pd,"vtkOpenGLVertexArrayObject"),extend:pd};const gd={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6};function md(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===rs.POINTS||n===gd.Points?t.context.POINTS:e===rs.WIREFRAME||n===gd.Lines||n===gd.TrisEdges||n===gd.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===gd.Points||r.getProperty().getRepresentation()===rs.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=cd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=cd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=cd.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=cd.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===gd.Points?2:t.primitiveType===gd.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}const hd={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function vd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hd,n),jt.obj(e,t),t.shaderSourceTime={},jt.obj(t.shaderSourceTime),t.attributeUpdateTime={},jt.obj(t.attributeUpdateTime),jt.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=cd.newInstance(),t.VAO=fd.newInstance(),t.CABO=Ju.newInstance(),md(e,t)}var yd={newInstance:jt.newInstance(vd),extend:vd,primTypes:gd};const Td={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},bd={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var xd={Wrap:Td,Filter:bd};const Cd=new Float32Array(1),Sd=new Int32Array(Cd.buffer);var Ad={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Cd[0]=e;const t=Sd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};const{Wrap:Id,Filter:wd}=xd,{VtkDataTypes:Pd}=Es,{vtkDebugMacro:Od,vtkErrorMacro:Rd,vtkWarningMacro:Md}=Kt,{toHalf:Dd}=Ad;function Ed(e,t){function n(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=[];let a=t.width*t.height*t.components;if(r&&(a*=t.depth),e!==Pd.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Float32Array(t))}else o.push(null);if(e!==Pd.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e]){const t=n[e].length>a?n[e].subarray(0,a):n[e];o.push(new Uint8Array(t))}else o.push(null);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");i=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(i)for(let e=0;e<n.length;e++)if(n[e]){const t=new Uint16Array(a),r=n[e];for(let e=0;e<a;e++)t[e]=Dd(r[e]);o.push(t)}else o.push(null);if(0===o.length)for(let e=0;e<n.length;e++)o.push(n[e]);return o}function r(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Fo(r)||!Fo(o))){const i=t.context.getExtension("OES_texture_half_float"),s=_o(r),l=_o(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Ad.toHalf(Ad.fromHalf(e[u][l+s+t])*h*(1-v)+Ad.fromHalf(e[u][l+p+t])*h*v+Ad.fromHalf(e[u][c+s+t])*m*(1-v)+Ad.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function o(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&t.oglNorm16Ext)||e!==Pd.UNSIGNED_SHORT&&e!==Pd.SHORT)))}function a(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);let i=!1;if(t._openGLRenderWindow.getWebgl2())i=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");i=e&&t.openGLDataType===e.HALF_FLOAT_OES}const s=i&&(function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a);t.useHalfFloat=s}(a,c.offset,c.scale,r),t.useHalfFloat||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent()),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(wd.LINEAR),e.setMagnificationFilter(wd.LINEAR)):(e.setMinificationFilter(wd.NEAREST),e.setMagnificationFilter(wd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Id.REPEAT),e.setWrapS(Id.REPEAT),e.setWrapT(Id.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw(n.width,n.height,4,Pd.UNSIGNED_CHAR,n.data,!0),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(wd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),a):e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()},e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:Md("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Od(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&Md("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(e,n)=>{let r=0;return r=t._openGLRenderWindow.getDefaultTextureInternalFormat(e,n,t.oglNorm16Ext,t.useHalfFloat),r||(r||(Od("Unsupported internal texture type!"),Od(`Unable to find suitable internal format for T=${e} NC= ${n}`)),r)},e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=e=>{if(t._openGLRenderWindow.getWebgl2())switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.SHORT:return t.context.SHORT;case t.oglNorm16Ext&&!t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case t.useHalfFloat&&Pd.SHORT:case t.useHalfFloat&&Pd.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Pd.FLOAT:case Pd.VOID:default:return t.context.FLOAT}switch(e){case Pd.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Pd.FLOAT:case Pd.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case wd.NEAREST:return t.context.NEAREST;case wd.LINEAR:return t.context.LINEAR;case wd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case wd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case wd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case wd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Id.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Id.REPEAT:return t.context.REPEAT;case Id.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.create2DFromRaw=function(a,i,s,l,c){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e.getOpenGLDataType(l,!0),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=n(l,d),f=r(p);return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=f[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,f[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,f[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createCubeFromRaw=(a,i,s,l,c)=>{if(e.getOpenGLDataType(l),e.getInternalFormat(l,s),e.getFormat(l,s),!t.internalFormat||!t.format||!t.openGLDataType)return Rd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=s,t.width=a,t.height=i,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=r(n(l,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(l,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(l)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,a=t.height;for(;r>=1&&a>=1;){let i=null;n<=t.maxLevel&&(i=d[6*n+e]),o(l)?null!=i&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,a,t.format,t.openGLDataType,i):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,a,0,t.format,t.openGLDataType,i),n++,r/=2,a/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*s*t._openGLRenderWindow.getDefaultTextureByteSize(l,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.createDepthFromRaw=(n,r,a,i)=>(e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Pd.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=r,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0):(Rd("Failed to determine texture parameters."),!1)),e.create2DFromImage=n=>{if(e.getOpenGLDataType(Pd.UNSIGNED_CHAR),e.getInternalFormat(Pd.UNSIGNED_CHAR,4),e.getFormat(Pd.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return Rd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1);const r=!(t._openGLRenderWindow.getWebgl2()||Fo(n.width)&&Fo(n.height)),a=document.createElement("canvas");a.width=r?_o(n.width):n.width,a.height=r?_o(n.height):n.height,t.width=a.width,t.height=a.height;const i=a.getContext("2d");i.translate(0,a.height),i.scale(1,-1),i.drawImage(n,0,0,n.width,n.height,0,0,a.width,a.height);const s=a;return o(Pd.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=s&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,s)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,s),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Pd.UNSIGNED_CHAR,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create2DFilterableFromRaw=function(t,n,r,o,a){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return e.create2DFilterableFromDataArray(t,n,Es.newInstance({numberOfComponents:r,dataType:o,values:a}),i)},e.create2DFilterableFromDataArray=function(t,n,r){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const{numComps:i,dataType:s,data:l}=a(r,o);e.create2DFromRaw(t,n,i,s,l)},e.create3DFromRaw=(a,i,s,l,c,u)=>{if(e.getOpenGLDataType(c),e.getInternalFormat(c,l),e.getFormat(c,l),!t.internalFormat||!t.format||!t.openGLDataType)return Rd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=l,t.width=a,t.height=i,t.depth=s,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=r(n(c,[u],!0));return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(c)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=d[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,d[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,d[0]),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(c,t.oglNorm16Ext,t.useHalfFloat),e.deactivate(),!0},e.create3DFilterableFromRaw=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return e.create3DFilterableFromDataArray(t,n,r,Es.newInstance({numberOfComponents:o,dataType:a,values:i}),s)},e.create3DFilterableFromDataArray=function(n,r,i,s){let l=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const{numComps:c,dataType:u,data:d,scaleOffsets:p}=a(s,l),f=n*r*i,g=[],m=[];for(let e=0;e<c;++e)g[e]=0,m[e]=1;t.volumeInfo={scale:m,offset:g,dataComputedScale:p.scale,dataComputedOffset:p.offset,width:n,height:r,depth:i};const h=structuredClone(p);if(t._openGLRenderWindow.getWebgl2()){if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=32767;return e.create3DFromRaw(n,r,i,c,u,d)}if(t.oglNorm16Ext&&!t.useHalfFloat&&u===Pd.UNSIGNED_SHORT){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=65535;return e.create3DFromRaw(n,r,i,c,u,d)}if(u===Pd.FLOAT||t.useHalfFloat&&(u===Pd.SHORT||u===Pd.UNSIGNED_SHORT))return e.create3DFromRaw(n,r,i,c,u,d);if(u===Pd.UNSIGNED_CHAR){for(let e=0;e<c;++e)t.volumeInfo.scale[e]=255;return e.create3DFromRaw(n,r,i,c,u,d)}const o=new Float32Array(f*c);t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;let a=0;const s=h.scale.map((e=>1/e));for(let e=0;e<f;e++)for(let e=0;e<c;e++)o[a]=(d[a]-h.offset[e])*s[e],a++;return e.create3DFromRaw(n,r,i,c,Pd.FLOAT,o)}let v=(e,t,n,r,o)=>{e[t]=n},y=Pd.UNSIGNED_CHAR;if(u===Pd.UNSIGNED_CHAR)for(let e=0;e<c;++e)h.offset[e]=0,h.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=Pd.FLOAT,v=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Pd.UNSIGNED_CHAR,v=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,c),e.getFormat(y,c),!t.internalFormat||!t.format||!t.openGLDataType)return Rd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=c,t.depth=1,t.numberOfDimensions=2;let T=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);T>4096&&(y===Pd.FLOAT||c>=3)&&(T=4096);let b=1,x=1;f>T*T&&(b=Math.ceil(Math.sqrt(f/(T*T))),x=b);let C=Math.sqrt(f)/b;C=_o(C);const S=Math.floor(C*b/n),A=Math.ceil(i/S),I=_o(r*A/x);let w;t.width=C,t.height=I,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=S,t.volumeInfo.yreps=A,t.volumeInfo.xstride=b,t.volumeInfo.ystride=x,t.volumeInfo.offset=h.offset,t.volumeInfo.scale=h.scale;const P=C*I*c;w=y===Pd.FLOAT?new Float32Array(P):new Uint8Array(P);let O=0;const R=Math.floor(n/b),M=Math.floor(r/x);for(let e=0;e<A;e++){const o=Math.min(S,i-e*S),a=c*(t.width-o*Math.floor(n/b));for(let t=0;t<M;t++){for(let a=0;a<o;a++){const o=c*((e*S+a)*n*r+x*t*n);for(let e=0;e<R;e++)for(let t=0;t<c;t++)v(w,O,d[o+b*e*c+t],h.offset[t],h.scale[t]),O++}O+=a}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),o(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=w&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,w)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,w),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1}const Vd={_openGLRenderWindow:null,_forceInternalFormat:!1,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Id.CLAMP_TO_EDGE,wrapT:Id.CLAMP_TO_EDGE,wrapR:Id.CLAMP_TO_EDGE,minificationFilter:wd.NEAREST,magnificationFilter:wd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,useHalfFloat:!0,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0};function Ld(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vd,n),Zt.extend(e,t,n),t.sendParametersTime={},yt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},yt(t.textureBuildTime,{mtime:0}),St(e,t,["format","openGLDataType"]),At(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),bt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),Ed(e,t)}const Bd=Et(Ld,"vtkOpenGLTexture");var Nd={newInstance:Bd,extend:Ld,...xd};rn("vtkTexture",Bd);var _d="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",Fd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",kd=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=cd.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=cd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=cd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=cd.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=cd.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=cd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=cd.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},Gd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=cd.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Ud}=ol,{primTypes:zd}=yd,{Representation:Wd,Shading:Hd}=ds,{ScalarMode:jd}=nc,{Filter:Kd,Wrap:$d}=Nd,{vtkErrorMacro:qd}=Kt,Xd={type:"StartEvent"},Yd={type:"EndEvent"},{CoordinateSystem:Zd}=Zi;function Qd(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=zd.Start;e<zd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=cd.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=cd.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=cd.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=cd.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?t.renderable.getInterpolateScalarsBeforeMapping()&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=cd.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=cd.substitute(i,"//VTK::Color::Impl",c).result):i=cd.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=cd.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=cd.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=cd.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=cd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=cd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=cd.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=cd.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:qd("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=cd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=cd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=cd.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=cd.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=cd.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=cd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=cd.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=cd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=cd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=cd.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=cd.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=cd.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=cd.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=cd.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=cd.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=cd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=cd.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=cd.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=cd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=cd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=cd.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=cd.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=cd.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=cd.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=cd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=cd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=cd.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=cd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=cd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=cd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=cd.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=cd.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=cd.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=cd.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=cd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=cd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=cd.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=cd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=cd.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=cd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=cd.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()||o.getEdgeVisibility()&&o.getRepresentation()===Wd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===zd.Points||o.getRepresentation()===Wd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===zd.Lines||o.getRepresentation()===Wd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==zd.Tris&&e!==zd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==zd.TrisEdges&&e!==zd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=cd.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==zl.ID_LOW24&&t.lastSelectionState!==zl.ID_HIGH24||(a=cd.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=cd.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=cd.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=cd.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case zl.ID_LOW24:o=cd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case zl.ID_HIGH24:o=cd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=cd.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=cd.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=cd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Hd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||qd("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||qd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||qd("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||qd("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),T(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],qo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],qo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);Vn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Zd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,T(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():zl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Wd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Ud.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===zl.ID_LOW24||t.lastSelectionState===zl.ID_HIGH24);for(let i=zd.Start;i<zd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===zd.TrisEdges||i===zd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Xd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Yd),!t.currentInput)return void qd("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(null===o)return;t.renderable.mapScalars(o,1);const a=t.renderable.getColorMapColors();t.haveCellScalars=!1;const i=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(i!==jd.USE_CELL_DATA&&i!==jd.USE_CELL_FIELD_DATA&&i!==jd.USE_FIELD_DATA&&o.getPointData().getScalars()||i===jd.USE_POINT_FIELD_DATA||!a||(t.haveCellScalars=!0));let s=r.getProperty().getInterpolation()!==Hd.FLAT?o.getPointData().getNormals():null;null===s&&o.getCellData().getNormals()&&(t.haveCellNormals=!0,s=o.getCellData().getNormals());const l=r.getProperty().getRepresentation();let c=o.getPointData().getTCoords();if(t.openGLActor.getActiveTextures()||(c=null),t.renderable.getColorCoordinates()){c=t.renderable.getColorCoordinates(),t.internalColorTexture||(t.internalColorTexture=Nd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Kd.NEAREST),e.setMagnificationFilter(Kd.NEAREST),e.setWrapS($d.CLAMP_TO_EDGE),e.setWrapT($d.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw(r[1]-r[0]+1,r[3]-r[2]+1,o.getNumberOfComponents(),o.getDataType(),o.getData()),e.activate(),e.sendParameters(),e.deactivate()}const u=`${o.getMTime()}A${l}B${o.getMTime()}C${s?s.getMTime():1}D${a?a.getMTime():1}E${r.getProperty().getEdgeVisibility()}F${c?c.getMTime():1}`;if(t.VBOBuildString!==u){const n={points:o.getPoints(),normals:s,tcoords:c,colors:a,cellOffset:0,vertexOffset:0,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>o.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const i=[{inRep:"verts",cells:o.getVerts()},{inRep:"lines",cells:o.getLines()},{inRep:"polys",cells:o.getPolys()},{inRep:"strips",cells:o.getStrips()},{inRep:"polys",cells:o.getPolys()},{inRep:"strips",cells:o.getStrips()}],d=r.getProperty().getEdgeVisibility()&&l===Wd.SURFACE;for(let e=zd.Start;e<zd.End;e++)e!==zd.TrisEdges&&e!==zd.TriStripsEdges?(n.cellOffset+=t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,l,n,t.selectionWebGLIdsToVTKIds),n.vertexOffset+=t.primitives[e].getCABO().getElementCount()):d?t.primitives[e].getCABO().createVBO(i[e].cells,i[e].inRep,Wd.WIREFRAME,{...n,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[e].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&(t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),e.updateMaximumPointCellIds()),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const Jd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:zl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function ep(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jd,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=zd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=zd.Start;e<zd.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},yt(t.selectionStateChanged,{mtime:0}),Qd(e,t)}const tp=Et(ep,"vtkOpenGLPolyDataMapper");var np={newInstance:tp,extend:ep};rn("vtkMapper",tp);const{ColorMode:rp,ScalarMode:op,GetArray:ap}=hl;function ip(e,t){t.classHierarchy.push("vtkMapper2D"),e.createDefaultLookupTable=()=>{t.lookupTable=El.newInstance()},e.getColorModeAsString=()=>jt.enumToString(rp,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>jt.enumToString(op,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFLag:!1};let i=null,s=!1;if(n===op.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===op.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===op.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===op.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===op.USE_FIELD_DATA){const t=e.getFieldData();i=r===ap.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.mapScalars=(n,r)=>{const o=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!o)return void(t.colorMapColors=null);const a=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString===a)return;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]);const i=e.getLookupTable();i&&(i.build(),t.colorMapColors=i.mapScalars(o,t.colorMode,t.fieldDataTupleId)),t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}}}const sp={static:!1,lookupTable:null,scalarVisibility:!1,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,transformCoordinate:null,viewSpecificProperties:null,customShaderAttributes:[]};function lp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sp,n),Bs(e,t,n),jt.get(e,t,["colorMapColors"]),jt.setGet(e,t,["arrayAccessMode","colorByArrayName","colorMode","lookupTable","renderTime","scalarMode","scalarVisibility","static","transformCoordinate","useLookupTableScalarRange","viewSpecificProperties","customShaderAttributes"]),jt.setGetArray(e,t,["scalarRange"],2),t.viewSpecificProperties||(t.viewSpecificProperties={}),ip(e,t)}var cp={newInstance:jt.newInstance(lp,"vtkMapper2D"),extend:lp};const up=1,{primTypes:dp}=yd,{ScalarMode:pp}=cp,{vtkErrorMacro:fp}=Kt,gp={type:"StartEvent"},mp={type:"EndEvent"};function hp(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=dp.Start;e<dp.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{e.invokeEvent(gp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(mp),t.currentInput?t.currentInput.getPoints&&t.currentInput.getPoints().getNumberOfValues()&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):fp("No input!")},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==pp.USE_CELL_DATA&&a!==pp.USE_CELL_FIELD_DATA&&a!==pp.USE_FIELD_DATA&&r.getPointData().getScalars()||a===pp.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));const i=n.getProperty().getRepresentation();let s=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(s=null);const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${i}B${r.getMTime()}C${o?o.getMTime():1}D${s?s.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=mc.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const a={points:n,tcoords:s,colors:o,cellOffset:0,haveCellScalars:t.haveCellSCalars,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};a.cellOffset+=t.primitives[dp.Points].getCABO().createVBO(r.getVerts(),"verts",i,a),a.cellOffset+=t.primitives[dp.Lines].getCABO().createVBO(r.getLines(),"lines",i,a),a.cellOffset+=t.primitives[dp.Tris].getCABO().createVBO(r.getPolys(),"polys",i,a),a.cellOffset+=t.primitives[dp.TriStrips].getCABO().createVBO(r.getStrips(),"strips",i,a),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=dp.Start;a<dp.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.haveCellScalars&&(i=cd.substitute(i,"//VTK::Color::Dec",["uniform samplerBuffer texture1;"]).result,i=cd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);"]).result),0!==t.lastBoundBO.getCABO().getColorComponents()?(o=cd.substitute(o,"//VTK::Color::Dec",["in vec4 diffuseColor;","out vec4 fcolorVSOutput;"]).result,o=cd.substitute(o,"//VTK::Color::Impl",["fcolorVSOutput = diffuseColor;"]).result,a=cd.substitute(a,"//VTK::Color::Dec",["in vec4 fcolorVSOutput[];\n","out vec4 fcolorGSOutput;"]).result,a=cd.substitute(a,"//VTK::Color::Impl",["fcolorGSOutput = fcolorVSOutput[i];"]).result,i=cd.substitute(i,"//VTK::Color::Dec",["in vec4 fcolorVSOutput;"]).result,i=cd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = fcolorVSOutput;"]).result):(i=cd.substitute(i,"//VTK::Color::Dec",["uniform vec4 diffuseColor;"]).result,i=cd.substitute(i,"//VTK::Color::Impl",["gl_FragData[0] = diffuseColor;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=cd.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=cd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=cd.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=cd.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=cd.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=cd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=cd.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=cd.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=cd.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=cd.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=cd.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=cd.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.haveCellScalars&&(r=cd.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=cd.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=cd.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||fp("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||fp(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||fp("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity(),a=n.getColor(),i=[a[0],a[1],a[2],o];t.setUniform4f("diffuseColor",i)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=Mo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=Mo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=Mo(c[0]-(d[0]-l[0])*p[0]),h=Mo(c[1]-(d[1]-l[1])*p[1]),v=-f;let y=-f+s[0];const T=-h;let b=-h+s[1];v===y&&(y=v+1),T===b&&(b=T+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(y-v),x[5]=2/(b-T),x[3]=-1*(y+v)/(y-v),x[7]=-1*(b+T)/(b-T),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===up?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}const vp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vp,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.primitives=[],t.primTypes=dp,t.tmpMat4=g(new Float64Array(16));for(let e=dp.Start;e<dp.End;e++)t.primitives[e]=yd.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);At(e,t,["context"]),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),hp(e,t)}),"vtkOpenGLPolyDataMapper2D");rn("vtkMapper2D",yp);const{VectorMode:Tp}=Pl;function bp(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function xp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Cp(e,t){return e=>{const t=e.getLastTickBounds(),n=go().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}function Sp(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;bp(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,bp(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=_o(o),a=_o(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{bp(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),y=e.getTicks(),T=e.getTickStrings();for(let n=0;n<y.length;n++){const o=(y[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(T[n],r,p,"horizontal",g,c)}const b=Es.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(b),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Tp.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Es.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}const Ap=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),jt.obj(e,t),jt.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings"]),jt.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),jt.getArray(e,t,["boxPosition","boxSize"]),jt.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},jt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=nc.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=hs.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=nc.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Tu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=hs.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],Sp(e,t)}),"vtkScalarBarActorHelper");function Ip(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(xp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Cp())}}function wp(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wp(n)),t.autoLayout||(t.autoLayout=xp(0,t)),t.generateTicks||(t.generateTicks=Cp()),hs.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),jt.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),jt.get(e,t,["axisTextStyle","tickTextStyle"]),jt.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),jt.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),Ip(e,t)}var Op={newInstance:jt.newInstance(Pp,"vtkScalarBarActor"),extend:Pp,newScalarBarActorHelper:Ap};function Rp(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}const Mp={};const Dp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mp,n),Zt.extend(e,t,n),t.scalarBarActorHelper=Op.newScalarBarActorHelper(),Rp(e,t)}),"vtkOpenGLScalarBarActor");rn("vtkScalarBarActor",Dp);const{vtkErrorMacro:Ep}=Kt;function Vp(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Es.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",rs.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Ep("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||Ep("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}const Lp={context:null};const Bp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lp,n),Zt.extend(e,t,n),t.openGLTexture=Nd.newInstance(),t.tris=yd.newInstance(),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},At(e,t,["context"]),bt(e,t,["activeTextures"]),Vp(e,t)}));rn("vtkSkybox",Bp);const{FieldAssociations:Np}=ol;function _p(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}const Fp={fieldAssociation:Np.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),jt.obj(e,t),jt.setGet(e,t,["fieldAssociation","captureZValues"]),_p(e,t)}var Gp={newInstance:jt.newInstance(kp,"vtkHardwareSelector"),extend:kp};function Up(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=n;null===r&&(r=t.context.FRAMEBUFFER),t.context.bindFramebuffer(r,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et("Attaching depth buffer textures to fbo requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et("Attaching depth buffer textures to framebuffers requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>{const e=[0,0];return null!==t.glFramebuffer&&(e[0]=t.glFramebuffer.width,e[1]=t.glFramebuffer.height),e},e.populateFramebuffer=()=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Nd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(bd.LINEAR),r.setMagnificationFilter(bd.LINEAR),r.create2DFromRaw(t.glFramebuffer.width,t.glFramebuffer.height,4,ys.UNSIGNED_CHAR,null),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}const zp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Wp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zp,n),yt(e,t),t.colorBuffers&&et("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],It(e,t,["colorBuffers"]),Up(e,t)}var Hp={newInstance:Et(Wp,"vtkFramebuffer"),extend:Wp};function jp(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}const Kp={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),jt.obj(e,t),t.properties={},jt.setGet(e,t,["contentType","fieldType","properties","selectionList"]),jp(e,t)}var qp={newInstance:jt.newInstance($p,"vtkSelectionNode"),extend:$p,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Xp}=Wl,{SelectionContent:Yp,SelectionField:Zp}=qp,{FieldAssociations:Qp}=ol,{vtkErrorMacro:Jp}=jt;function ef(e){return`${e.propID} ${e.compositeID}`}function tf(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function nf(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function rf(e,t){let n=t;return n<<=24,n|=e,n}function of(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=nf(n[0],n[1],e.pixBuffer[Xp.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=nf(n[0],n[1],e.pixBuffer[Xp.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Xp.ID_LOW24]&&0===tf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area))return a;const s=nf(n[0],n[1],e.pixBuffer[Xp.ID_LOW24],e.area),l=nf(n[0],n[1],e.pixBuffer[Xp.ID_HIGH24],e.area);return a.attributeID=rf(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=of(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=of(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=of(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=of(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function af(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=qp.newInstance();switch(l.setContentType(Yp.INDICES),e){case Qp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Zp.CELL);break;case Qp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Zp.POINT);break;default:Jp("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}function sf(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=of(e,[n,t],0,u);if(r&&r.valid){const t=ef(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return af(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}function lf(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e[0]!==n[0]||e[1]!==n[1]?(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer()):t.framebuffer.bind()}else t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return sf(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Jp("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();for(e.beginSelection(),t.currentPass=Xp.MIN_KNOWN_PASS;t.currentPass<=Xp.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Xp.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),e.processPixelBuffers());return e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Xp.ID_HIGH24){if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Qp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Xp.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=nf(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Xp.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Xp.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>jt.enumToString(Xp,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=nf(e[0],e[1],t.pixBuffer[Xp.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=nf(e[0],e[1],t.pixBuffer[Xp.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Xp.ID_LOW24]&&0===tf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area))return a;const s=nf(e[0],e[1],t.pixBuffer[Xp.ID_LOW24],t.area),l=nf(e[0],e[1],t.pixBuffer[Xp.ID_HIGH24],t.area);return a.attributeID=rf(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=ef(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return af(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}const cf={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cf,n),Gp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),jt.setGetArray(e,t,["area"],4),jt.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),jt.setGetArray(e,t,["propColorValue"],3),jt.moveToProtected(e,t,["renderer","openGLRenderWindow"]),jt.event(e,t,"event"),lf(e,t)}var df={newInstance:jt.newInstance(uf,"vtkOpenGLHardwareSelector"),extend:uf,...Wl};const{vtkErrorMacro:pf}=Kt,{Representation:ff}=ds,{ObjectType:gf}=qu,{PassTypes:mf}=df,hf={type:"StartEvent"},vf={type:"EndEvent"};function yf(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hf),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vf),!t.currentInput)return void pf("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],y=t[14],T=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*y,e[3]=b*s+x*d+C*m+S*T,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*y,e[7]=b*s+x*d+C*m+S*T,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*y,e[11]=b*s+x*d+C*m+S*T,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*y,e[15]=b*s+x*d+C*m+S*T},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=cd.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=cd.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=cd.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=cd.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=cd.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=cd.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=cd.substitute(o,"//VTK::Color::Impl",s).result,o=cd.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=cd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=cd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=cd.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=cd.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=cd.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=cd.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=cd.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=cd.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],y=n[r+1],T=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+y*d+T*g,o[1]=v*i+y*p+T*m,o[2]=v*c+y*f+T*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===ff.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),T(t.mcpcMatrix,s.wcpc,l.mcwc),T(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mf.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||pf("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||pf("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pf("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=qu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=qu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=qu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=qu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gf.ARRAY_BUFFER),t.normalBuffer.upload(n,gf.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gf.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gf.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}const Tf={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const bf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),np.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},yt(t.glyphBOBuildTime,{mtime:0}),yf(e,t)}),"vtkOpenGLGlyph3DMapper");rn("vtkGlyph3DMapper",bf);const{vtkErrorMacro:xf}=jt;class Cf{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}function Sf(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void xf("Invalid or missing input");const r=gu.newInstance();r.shallowCopy(n);const o=new Cf,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(cc.newInstance({values:c,name:"faces"})),t[0]=r}}const Af={};function If(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Af,n),jt.obj(e,t),jt.algo(e,t,1,1),Sf(e,t)}var wf={newInstance:jt.newInstance(If,"vtkClosedPolyLineToSurfaceFilter"),extend:If};const{vtkErrorMacro:Pf}=Kt;function Of(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Pf("Invalid or missing input");if(!t.cutFunction)return void Pf("Missing cut function");const o=gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=r.getNumberOfPoints(),i=[],s=[],l=[];(!t.cutScalars||t.cutScalars.length<a)&&(t.cutScalars=new Float32Array(a));let c=0,u=0;for(;c<o.length;)t.cutScalars[u++]=t.cutFunction.evaluateFunction(o[c++],o[c++],o[c++]);const d=[],p=new Array(3),f=new Array(3),g=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)g[e]=t.cutScalars[n.cell[e++]];const e=g[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(g[t]>0!==e){r=!1;break}if(r)continue;const a=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,i=g[e]>0;if(g[r]>0===i)continue;let s=e,l=r,c=g[l]-g[s];c<=0&&(s=r,l=e,c*=-1);let u=0;0!==c&&(u=(t.cutValue-g[s])/c);const d=n.cell[s],m=n.cell[l];p[0]=o[3*d],p[1]=o[3*d+1],p[2]=o[3*d+2],f[0]=o[3*m],f[1]=o[3*m+1],f[2]=o[3*m+2];const h=[p[0]+u*(f[0]-p[0]),p[1]+u*(f[1]-p[1]),p[2]+u*(f[2]-p[2])];a.push({pointEdge1:d,pointEdge2:m,intersectedPoint:h,newPointID:-1})}for(let e=0;e<a.length;e++){const t=a[e];let n=!1;for(let r=0;r<d.length;r++){const o=d[r],i=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(i||s){n=!0,a[e].newPointID=d[r].newPointID;break}}n||(i.push(t.intersectedPoint[0]),i.push(t.intersectedPoint[1]),i.push(t.intersectedPoint[2]),a[e].newPointID=i.length/3-1,d.push(a[e]))}const c=a.length;2===c?s.push(c,a[0].newPointID,a[1].newPointID):c>2&&(l.push(c),a.forEach((e=>{l.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),i),3),0!==s.length&&n.getLines().setData(Uint16Array.from(s)),0!==l.length&&n.getPolys().setData(Uint16Array.from(l))})(r,o),n[0]=o}}const Rf={cutFunction:null,cutScalars:null,cutValue:0};function Mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),yt(e,t),Rt(e,t,1,1),At(e,t,["cutFunction","cutValue"]),Of(e,t)}var Df={newInstance:Et(Mf,"vtkCutter"),extend:Mf};const Ef=e=>e,Vf=1e-6;class Lf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Ef}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);In(n,e[0],e[1],e[2]),In(r,t[0],t[1],t[2]),Mn(n,n),Mn(r,r);const a=Dn(n,r);return a>=1||(En(this.tmp,n,r),Sn(this.tmp)<Vf&&(En(this.tmp,[1,0,0],e),Sn(this.tmp)<Vf&&En(this.tmp,[0,1,0],e)),O(o,Math.acos(a),this.tmp),T(this.matrix,this.matrix,o)),this}rotate(e,t){return In(this.tmp,...t),Mn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return In(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return In(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return T(this.matrix,this.matrix,e),this}multiply3x3(e){return T(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(aa(vo,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)In(this.tmp,e[n],e[n+1],e[n+2]),Vn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Bf=function(){return new Lf(!0)},Nf=function(){return new Lf(!1)};const _f=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22];function kf(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=gu.newInstance();n[0]=r;const o=jt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=jt.newTypedArray(t.pointType,72),i=Es.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=jt.newTypedArray(t.pointType,24*s),c=Es.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Bf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Nf().translate(...t.center).apply(o),t.matrix){Nf().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Nf().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}const Gf={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function Uf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gf,n),jt.obj(e,t),jt.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),jt.setGetArray(e,t,["center","rotations"],3),jt.setGetArray(e,t,["matrix"],16),t._polys=cc.newInstance({values:Uint16Array.from(Ff)}),t._lineCells=cc.newInstance({values:Uint16Array.from(_f)}),jt.moveToProtected(e,t,["polys","lineCells"]),jt.algo(e,t,0,1),kf(e,t)}var zf={newInstance:jt.newInstance(Uf,"vtkCubeSource"),extend:Uf};const{vtkErrorMacro:Wf}=jt;function Hf(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void Wf("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):Wf("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}const jf={};function Kf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jf,n),jt.obj(e,t),jt.algo(e,t,1,1),t._cubeSource=zf.newInstance(),jt.moveToProtected(e,t,["cubeSource","tmpOut"]),Hf(e,t)}var $f={newInstance:jt.newInstance(Kf,"vtkImageDataOutlineFilter"),extend:Kf};let qf;function Xf(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(Vn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],Vn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?T(n,t.matrix,e):T(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>T(o,t.matrix,r):()=>T(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>qf({matrix:za.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag})}const Yf={preMultiplyFlag:!1,matrix:[...vo]};function Zf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yf,n),jt.obj(e,t),jt.setGet(e,t,["preMultiplyFlag"]),jt.setGetArray(e,t,["matrix"],16),Xf(e,t)}qf=jt.newInstance(Zf,"vtkTransform");var Qf={newInstance:qf,extend:Zf};const Jf={NEAREST:0,LINEAR:1};var eg={InterpolationType:Jf};const{vtkErrorMacro:tg}=Kt;function ng(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return"0"}function rg(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}function og(e,t){t.classHierarchy.push("vtkOpenGLImageResliceMapper"),e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),t.currentInput?(e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})):tg("No input!")},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===Jf.NEAREST?(t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.openGLTexture.setMinificationFilter(bd.LINEAR),t.openGLTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime(),e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(!r)return;const o=r.getPointData()?.getScalars();if(!o)return;t._scalars!==o&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=o);const a=o.getNumberOfComponents();let i=`${r.getMTime()}A${o.getMTime()}`;const s=t._openGLRenderWindow.getGraphicsResourceForObject(o);if(s?.vtkObj&&s?.hash===i&&t.openGLTextureString===i)t.openGLTexture=s.vtkObj,t.openGLTextureString=s.hash;else{t.openGLTexture||(t.openGLTexture=Nd.newInstance(),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const e=r.getDimensions();t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],o),t.openGLTextureString=i,o&&t._openGLRenderWindow.setGraphicsResourceForObject(o,t.openGLTexture,t.openGLTextureString)}const l=n.getProperty(),c=l.getIndependentComponents(),u=c?a:1,d=c?2*u:1,p=l.getRGBTransferFunction();i=ng(l,p,u);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===i&&t.colorTextureString===i)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8ClampedArray(e*d*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),p){const r=new Float32Array(3*e);for(let t=0;t<u;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),c)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=i,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}const g=l.getPiecewiseFunction();i=ng(l,g,u);const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);if(m?.vtkObj&&m?.hash===i&&t.pwfTextureString===i)t.pwfTexture=m.vtkObj,t.pwfTextureString=m.hash;else{const e=1024,n=e*d,r=new Uint8ClampedArray(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),g){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<u;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=i,g&&t._openGLRenderWindow.setGraphicsResourceForObject(g,t.pwfTexture,t.pwfTextureString)}const h=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==h){const e=Es.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Es.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:tg("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",rs.SURFACE,r)}t.VBOBuildString=h,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){a.isUniformUsed("texture1")&&a.setUniformi("texture1",t.openGLTexture.getTextureUnit()),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||tg("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",t.currentInput.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=t.currentInput,r=n.getDimensions();d(t.tmpMat4,n.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,r),h(t.tmpMat4,t.tmpMat4),e&&T(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",rg([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",rg([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.openGLTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.openGLTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=t.renderable.getSlabThickness(),s=t.renderable.getSlabType(),l=t.renderable.getSlabTrapezoidIntegration();let c=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(c=!0),!(!c&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a&&t.lastSlabThickness===i&&t.lastSlabType===s&&t.lastSlabTrapezoidIntegration===l||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,t.lastSlabThickness=i,t.lastSlabType=s,t.lastSlabTrapezoidIntegration=l,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=cd.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=cd.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=cd.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=cd.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.openGLTexture.getComponents(),c=r.getProperty().getIndependentComponents();let u=["in vec3 fragTexCoord;","uniform highp sampler3D texture1;","uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:tg("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=cd.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(texture1, fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = texture(texture1, fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:tg("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=cd.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=cd.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=cd.substitute(a,"//VTK::PositionVC::Impl",u).result,a=cd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=cd.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentInput,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`));const t=ue(n?.getDirection());ge(t,t);const r=[...s.getNormal()];Ln(r,r,t),[o,a]=function(e){za.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=za.dot(e,t);if(o<-.999||o>.999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ni.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getDimensions(),l=[0,i[0]-1,0,i[1]-1,0,i[2]-1];let c=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[c+a]=r[a],e[c+o[0]]=l[2*o[0]+n],e[c+o[1]]=l[2*o[1]+t],c+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const u=new Uint16Array(8);u[0]=3,u[1]=0,u[2]=1,u[3]=3,u[4]=3,u[5]=0,u[6]=3,u[7]=2;const d=s.getNormal();za.normalize(d);const p=new Float32Array(12);for(let e=0;e<4;++e)p[3*e]=d[0],p[3*e+1]=d[1],p[3*e+2]=d[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(u,1);const f=Es.newInstance({numberOfComponents:3,values:p,name:"Normals"});t.resliceGeom.getPointData().setNormals(f)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();za.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Es.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else tg("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setOpenGLTexture=e=>{e&&(t.openGLTexture=e,t._externalOpenGLTexture=!0)}}const ag={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastTextureComponents:0,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,openGLTexture:null,openGLTextureString:null,colorTextureString:null,pwfTextureString:null,resliceGeom:null,resliceGeomUpdateString:null,tris:null,colorTexture:null,pwfTexture:null,_externalOpenGLTexture:!1,_scalars:null};const ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.openGLTexture=null,t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},yt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=$f.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=Df.newInstance(),t.lineToSurfaceFilter=wf.newInstance(),t.transform=Qf.newInstance(),bt(e,t,["openGLTexture"]),og(e,t)}),"vtkOpenGLImageResliceMapper");rn("vtkImageResliceMapper",ig);var sg={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:lg}=Kt,{SlicingMode:cg}=sg;function ug(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return"0"}function dg(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}function pg(e,t){t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=n=>{if(n){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(n.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=cd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=cd.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=cd.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform sampler2D labelOutlineTexture1;","uniform float opacity;","uniform float outlineOpacity;"];if(l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:lg("Unsupported number of independent coordinates.")}}if(i=cd.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=cd.substitute(i,"//VTK::LabelOutline::Dec",["uniform int outlineThickness;","uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;"]).result,i=cd.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=cd.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:lg("Unsupported number of independent coordinates.")}i=cd.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=cd.substitute(i,"//VTK::TCoord::Impl",[...dg("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); \n                  float centerValue = texture2D(texture1, centerPosIS.xy).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (actualThickness == 0) {\n                    gl_FragData[0] = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                  }\n                  if (opacityToUse > 0.01) {\n                    for (int i = -actualThickness; i <= actualThickness; i++) {\n                      for (int j = -actualThickness; j <= actualThickness; j++) {\n                        if (i == 0 || j == 0) {\n                          continue;\n                        }\n                        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                          gl_FragCoord.y + float(j),\n                          gl_FragCoord.z, gl_FragCoord.w);\n                        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                        float value = texture2D(texture1, neighborPosIS.xy).r;\n                        if (value != centerValue) {\n                          pixelOnBorder = true;\n                          break;\n                        }\n                      }\n                      if (pixelOnBorder == true) {\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      gl_FragData[0] = vec4(tColor, outlineOpacity);\n                    }\n                    else {\n                      gl_FragData[0] = vec4(tColor, opacityToUse);\n                    }\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=cd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=cd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=cd.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=cd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=cd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6),o=cd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=cd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=cd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=cd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!(!i&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&0!==e.getProgram()?.getHandle()&&t.lastTextureComponents===o&&t.lastIndependentComponents===a||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,0))},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||lg("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||lg("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();n.getProgram().setUniformi("pwfTexture1",u);const p=t.labelOutlineThicknessTexture.getTextureUnit();if(n.getProgram().setUniformi("labelOutlineTexture1",p),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(!0===o.getProperty().getUseLabelOutline()){const e=o.getProperty().getLabelOutlineOpacity();n.getProgram().setUniformf("outlineOpacity",e)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();T(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(T(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();a.setUniform3i("imageDimensions",o[0],o[1],1),a.setUniformMatrix("vWCtoIDX",n);const i=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,i.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const l=e.getRenderTargetSize();a.setUniformf("vpWidth",l[0]),a.setUniformf("vpHeight",l[1]);const c=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",c[0]/l[0]),a.setUniformf("vpOffsetY",c[1]/l[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):lg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=l.getRGBTransferFunction(),g=ug(l,f,d),m=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(m?.vtkObj&&m?.hash===g&&t.colorTextureString===g)t.colorTexture=m.vtkObj,t.colorTextureString=m.hash;else{const e=1024,n=new Uint8ClampedArray(e*p*3);if(t.colorTexture||(t.colorTexture=Nd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST)):(t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR)),f){const r=new Float32Array(3*e);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),u)for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o];else for(let o=0;o<3*e;o++)n[t*e*6+o]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,p,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=g,f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,t.colorTexture,t.colorTextureString)}const h=l.getPiecewiseFunction(),v=ug(l,h,d),y=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(y?.vtkObj&&y?.hash===v&&t.pwfTextureString===v)t.pwfTexture=y.vtkObj,t.pwfTextureString=y.hash;else{const e=1024,n=e*p,r=new Uint8ClampedArray(n);if(t.pwfTexture||(t.pwfTexture=Nd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),c===Jf.NEAREST?(t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR)),h){const r=new Float32Array(n),o=new Float32Array(e);for(let t=0;t<d;++t){const n=l.getPiecewiseFunction(t);if(null===n)r.fill(1);else{const a=n.getRange();if(n.getTable(a[0],a[1],e,o,1),u)for(let n=0;n<e;n++)r[t*e*2+n]=o[n],r[t*e*2+n+e]=o[n];else for(let n=0;n<e;n++)r[t*e*2+n]=o[n]}}t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw(e,p,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=v,h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,t.pwfTexture,t.pwfTextureString)}e.updatelabelOutlineThicknessTexture(r);const{ijkMode:T}=t.renderable.getClosestIJKAxis();let b=t.renderable.getSlice();T!==t.renderable.getSlicingMode()&&(b=t.renderable.getSliceAtPosition(b));const x=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(b),C=o.getExtent();let S;T===cg.I&&(S=x-C[0]),T===cg.J&&(S=x-C[2]),T!==cg.K&&T!==cg.NONE||(S=x-C[4]);const A=`${b}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==A){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Nd.newInstance({resizable:!0}),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow)),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===Jf.NEAREST?(new Set([1,3,4]).has(s)&&i===ys.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.NEAREST)):t.openGLTexture.setMinificationFilter(bd.NEAREST),t.openGLTexture.setMagnificationFilter(bd.NEAREST)):(4!==s||i!==ys.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(bd.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(bd.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(bd.LINEAR)),t.openGLTexture.setWrapS(Td.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Td.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[cg.X,cg.Y,cg.Z].includes(t.renderable.getSlicingMode())?b:x,p=o.getSpatialExtent(),f=a.getData();let g=null;if(T===cg.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(S+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(T===cg.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+S*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else T===cg.K||T===cg.NONE?(g=f.subarray(S*n,(S+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):lg("Reformat slicing not yet supported.");const m=t._openGLRenderWindow.getGraphicsResourceForObject(g);m?.vtkObj?(t.openGLTexture=m.vtkObj,t.VBOBuildString=m.hash):(t._scalars!==g&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=g),t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw(e[0],e[1],s,a.getDataType(),g,t.renderable.getPreferSizeOverAccuracy?.()),t._openGLRenderWindow.setGraphicsResourceForObject(g,t.openGLTexture,t.VBOBuildString)),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Es.newInstance({numberOfComponents:3,values:r});h.setName("points");const v=Es.newInstance({numberOfComponents:2,values:l});v.setName("tcoords");const y=new Uint16Array(8);y[0]=3,y[1]=0,y[2]=1,y[3]=3,y[4]=3,y[5]=0,y[6]=3,y[7]=2;const C=Es.newInstance({numberOfComponents:1,values:y});t.tris.getCABO().createVBO(C,"polys",rs.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=A}},e.updatelabelOutlineThicknessTexture=e=>{t.labelOutlineThicknessTexture||(t.labelOutlineThicknessTexture=Nd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow));const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join("-")}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]}}const fg={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,_scalars:null};const gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fg,n),Zt.extend(e,t,n),kd(e,t,n),Gd(e,t,n),t.tris=yd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),At(e,t,[]),t.VBOBuildTime={},yt(t.VBOBuildTime),pg(e,t)}),"vtkOpenGLImageMapper");rn("vtkAbstractImageMapper",gg);const{vtkErrorMacro:mg}=jt;function hg(e,t,n){if(t.apply(e)){const t=e.getIndependentComponents();return`${e.getMTime()}-${t}-${n}`}return"0"}function vg(e,t){t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow))},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentImageDataInput,o=t.currentCenterlineInput;n.getProperty().getInterpolationType()===Jf.NEAREST?(t.volumeTexture.setMinificationFilter(bd.NEAREST),t.volumeTexture.setMagnificationFilter(bd.NEAREST),t.colorTexture.setMinificationFilter(bd.NEAREST),t.colorTexture.setMagnificationFilter(bd.NEAREST),t.pwfTexture.setMinificationFilter(bd.NEAREST),t.pwfTexture.setMagnificationFilter(bd.NEAREST)):(t.volumeTexture.setMinificationFilter(bd.LINEAR),t.volumeTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.pwfTexture.setMinificationFilter(bd.LINEAR),t.pwfTexture.setMagnificationFilter(bd.LINEAR));const a=r.getMTime();if(t.volumeTextureTime!==a){const e=r.getDimensions(),n=r.getPointData().getScalars();if(!n)return;t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.releaseGraphicsResources(t._openGLRenderWindow),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromRaw(e[0],e[1],e[2],n.getNumberOfComponents(),n.getDataType(),n.getData(),t.renderable.getPreferSizeOverAccuracy()),t.volumeTextureTime=a}const i=r.getPointData()&&r.getPointData().getScalars();if(!i)return;const s=i.getNumberOfComponents(),l=n.getProperty(),c=l.getIndependentComponents(),u=c?s:1,d=c?2*u:1,p=hg(l,l.getRGBTransferFunction,u);if(t.colorTextureString!==p){const e=1024,n=new Uint8ClampedArray(e*d*3);let r=l.getRGBTransferFunction();if(r){const o=new Float32Array(3*e);for(let t=0;t<u;t++){r=l.getRGBTransferFunction(t);const a=r.getRange();if(r.getTable(a[0],a[1],e,o,1),c)for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r],n[t*e*6+r+3*e]=255*o[r];else for(let r=0;r<3*e;r++)n[t*e*6+r]=255*o[r]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw(e,d,3,ys.UNSIGNED_CHAR,n)}else{for(let t=0;t<3*e;++t)n[t]=255*t/(3*(e-1)),n[t+1]=255*t/(3*(e-1)),n[t+2]=255*t/(3*(e-1));t.colorTexture.create2DFromRaw(e,1,3,ys.UNSIGNED_CHAR,n)}t.colorTextureString=p}const f=hg(l,l.getPiecewiseFunction,u);if(t.pwfTextureString!==f){const e=1024,n=e*d,r=new Uint8ClampedArray(n);let o=l.getPiecewiseFunction();if(t.pwfTexture.releaseGraphicsResources(t._openGLRenderWindow),t.pwfTexture.resetFormatAndType(),o){const r=new Float32Array(n),a=new Float32Array(e);for(let t=0;t<u;++t)if(o=l.getPiecewiseFunction(t),null===o)r.fill(1);else{const n=o.getRange();if(o.getTable(n[0],n[1],e,a,1),c)for(let n=0;n<e;n++)r[t*e*2+n]=a[n],r[t*e*2+n+e]=a[n];else for(let n=0;n<e;n++)r[t*e*2+n]=a[n]}t.pwfTexture.create2DFromRaw(e,d,1,ys.FLOAT,r)}else r.fill(255),t.pwfTexture.create2DFromRaw(e,1,1,ys.UNSIGNED_CHAR,r);t.pwfTextureString=f}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<o.getMTime()){const e=o.getNumberOfPoints(),n=e<=1?0:e-1,r=o.getDistancesToFirstPoint(),a=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,a-r[e],0],t),t+=3,s.set([l,a-r[e],0],t),t+=3,s.set([l,a-r[e+1],0],t),t+=3,s.set([0,a-r[e+1],0],t),t+=3;const c=Es.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Es.newInstance({numberOfComponents:1,values:u}),p=o.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Es.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const y=[h,Es.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getCenterlineTangentDirections(),r=new Float32Array(3*i),o=new Float32Array(3*i);for(let t=0,a=0;t<n;++t){const n=3*t;for(let t=0;t<4;++t)r[a+0]=e[n+0],r[a+1]=e[n+1],r[a+2]=e[n+2],o[a+0]=e[n+3],o[a+1]=e[n+4],o[a+2]=e[n+5],a+=3}const a=Es.newInstance({numberOfComponents:3,values:r,name:"centerlineTopDirection"}),s=Es.newInstance({numberOfComponents:3,values:o,name:"centerlineBotDirection"});y.push(a,s)}t.tris.getCABO().createVBO(d,"polys",rs.SURFACE,{points:c,customAttributes:y}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=cd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=cd.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const s=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],l=t.renderable.getUseUniformOrientation();l?s.push("out vec3 centerlineDirVSOutput;","uniform vec3 centerlineDirection;"):s.push("out vec3 centerlineTopDirVSOutput;","out vec3 centerlineBotDirVSOutput;","out float centerlineAngleVSOutput;","attribute vec3 centerlineTopDirection;","attribute vec3 centerlineBotDirection;"),a=cd.substitute(a,"//VTK::Color::Dec",s).result;const c=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];l?c.push("centerlineDirVSOutput = centerlineDirection;"):c.push("vec3 sumVec = centerlineTopDirection + centerlineBotDirection;","float sumLen2 = dot(sumVec, sumVec);","float diffLen2 = 4.0 - sumLen2;","if (diffLen2 < 0.001) {","  // vectors are too close to each other, use lerp","  centerlineAngleVSOutput = -1.0; // use negative angle as a flag for lerp","  centerlineTopDirVSOutput = centerlineTopDirection;","  centerlineBotDirVSOutput = centerlineBotDirection;","} else if (sumLen2 == 0.0) {","  // vector are opposite to each other, don't make a choice for the user","  // use slerp without direction, it will display the centerline color on each row of pixel","  centerlineAngleVSOutput = 0.0;","  centerlineTopDirVSOutput = vec3(0.0);","  centerlineBotDirVSOutput = vec3(0.0);","} else {","  // use slerp","  centerlineAngleVSOutput = 2.0 * atan(sqrt(diffLen2/sumLen2));","  float sinAngle = sin(centerlineAngleVSOutput);","  centerlineTopDirVSOutput = centerlineTopDirection / sinAngle;","  centerlineBotDirVSOutput = centerlineBotDirection / sinAngle;","}"),a=cd.substitute(a,"//VTK::Color::Impl",c).result;const u=t.volumeTexture.getComponents(),d=o.getProperty().getIndependentComponents();let p=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];l?p.push("in vec3 centerlineDirVSOutput;"):p.push("in vec3 centerlineTopDirVSOutput;","in vec3 centerlineBotDirVSOutput;","in float centerlineAngleVSOutput;");const f=t.renderable.getCenterPoint();if(f&&p.push("uniform vec3 globalCenterPoint;"),d){for(let e=1;e<u;e++)p=p.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(u){case 1:p=p.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:p=p.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:p=p.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:p=p.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:mg("Unsupported number of independent coordinates.")}}i=cd.substitute(i,"//VTK::TCoord::Dec",p).result;let g=[];if(l?g.push("vec3 interpolatedCenterlineDir = centerlineDirVSOutput;"):g.push("vec3 interpolatedCenterlineDir;","if (centerlineAngleVSOutput < 0.0) {","  // Lerp","  interpolatedCenterlineDir = quadOffsetVSOutput.y * centerlineTopDirVSOutput + (1.0 - quadOffsetVSOutput.y) * centerlineBotDirVSOutput;","} else {","  // Slerp","  float topInterpolationAngle = quadOffsetVSOutput.y * centerlineAngleVSOutput;","  float botInterpolationAngle = centerlineAngleVSOutput - topInterpolationAngle;","  interpolatedCenterlineDir = sin(topInterpolationAngle) * centerlineTopDirVSOutput + sin(botInterpolationAngle) * centerlineBotDirVSOutput;","}","// Slerp should give a normalized vector but when sin(angle) is small, rounding error occurs","// Normalize for both lerp and slerp","interpolatedCenterlineDir = normalize(interpolatedCenterlineDir);"),f?g.push("float baseOffset = dot(interpolatedCenterlineDir, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):g.push("float horizontalOffset = quadOffsetVSOutput.x;"),g.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * interpolatedCenterlineDir;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = texture(volumeTexture, volumePosTC);"),d){const e=["r","g","b","a"];for(let t=0;t<u;++t)g=g.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(u){case 1:g=g.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:g=g.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:g=g.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:g=g.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:mg("Unsupported number of independent coordinates.")}}else switch(u){case 1:g=g.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:g=g.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:g=g.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:g=g.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=cd.substitute(i,"//VTK::TCoord::Impl",g).result,t.haveSeenDepthRequest&&(i=cd.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=cd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=cd.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=cd.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=cd.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=cd.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=_d,e.Fragment=Fd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||mg("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&n.getProgram().isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),e.name,e.offset,n.getCABO().getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&mg(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const a=t.volumeTexture.getTextureUnit();if(n.getProgram().setUniformi("volumeTexture",a),n.getProgram().setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4f("backgroundColor",...t.renderable.getBackgroundColor()),n.getProgram().isUniformUsed("centerlineDirection")){const e=t.renderable.getUniformDirection();n.getProgram().setUniform3fArray("centerlineDirection",e)}if(n.getProgram().isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();n.getProgram().setUniform3fArray("globalCenterPoint",e)}const i=t.currentImageDataInput,s=i.getWorldToIndex(),l=P(new Float32Array(16),Rn([],i.getDimensions())),c=oe(l,l,s);if(n.getProgram().setUniformMatrix("MCTCMatrix",c),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(jt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),T(a,a,r),m(a,a)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),T(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}if(n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(T(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();T(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)}}const yg={currentRenderPass:null,volumeTexture:null,volumeTextureTime:0,colorTexture:null,colorTextureString:null,pwfTexture:null,pwfTextureString:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const Tg=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yg,n),Zt.extend(e,t,n),kd(e,t,n),jt.algo(e,t,2,0),t.tris=yd.newInstance(),t.volumeTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.pwfTexture=Nd.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),vg(e,t)}),"vtkOpenGLImageCPRMapper");function bg(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getFirstAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}rn("vtkImageCPRMapper",Tg);const xg={context:null,keyMatrixTime:null,keyMatrices:null};const Cg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xg,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},At(e,t,["context"]),bg(e,t)}),"vtkOpenGLImageSlice");function Sg(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getFirstAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}rn("vtkImageSlice",Cg);const Ag={};const Ig=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ag,n),Zt.extend(e,t,n),t.keyMatrixTime={},yt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),At(e,t,["context"]),Sg(e,t)}),"vtkOpenGLVolume");rn("vtkVolume",Ig);const wg={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Pg={FRACTIONAL:0,PROPORTIONAL:1};var Og={InterpolationType:wg,OpacityMode:Pg};const Rg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5};var Mg={BlendMode:Rg,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const{vtkWarningMacro:Dg,vtkErrorMacro:Eg}=Kt;function Vg(e,t,n){if(t){const r=e.getIndependentComponents();return`${t.getMTime()}-${r}-${n}`}return"0"}function Lg(e,t){t.classHierarchy.push("vtkOpenGLVolumeMapper"),e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){t._openGLRenderWindow=e.getFirstAncestorOfType("vtkOpenGLRenderWindow"),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.scalarTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.opacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const n=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(r.getActiveCamera()),e.renderPiece(r,n)}},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkTrilinearOn\n//VTK::TrilinearOn\n\n// possibly define vtkIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n#ifdef vtkImageLabelOutlineOn\n\nuniform float outlineOpacity;\nuniform float vpWidth;\nuniform float vpHeight;\nuniform float vpOffsetX;\nuniform float vpOffsetY;\nuniform mat4 PCWCMatrix;\nuniform mat4 vWCtoIDX;\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n//VTK::VolumeShadowOn\n//VTK::SurfaceShadowOn\n//VTK::localAmbientOcclusionOn\n//VTK::LAO::Dec\n//VTK::VolumeShadow::Dec\n\n// define vtkComputeNormalFromOpacity\n//VTK::vtkComputeNormalFromOpacity\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents >= 3\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#endif\n#if vtkNumComponents >= 4\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n//VTK::ClipPlane::Dec\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n// jitter texture\nuniform sampler2D jtexture;\nuniform sampler2D ttexture;\n\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef vtkIndependentComponentsOn\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\nuniform vec4 ipScalarRangeMin;\nuniform vec4 ipScalarRangeMax;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\nvec3 rayDirVC;\nfloat sampleDistanceISVS;\nfloat sampleDistanceIS;\n\n#define SQRT3    1.7321\n#define INV4PI   0.0796\n#define EPSILON  0.001\n#define PI       3.1415\n#define PI2      9.8696\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.a = tmp.g;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing trilinear values from multiple z slices\n#ifdef vtkTrilinearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\nvec3 IStoVC(vec3 posIS){\n  vec3 posVC = posIS / vVCToIJK;\n  return posVC.x * vPlaneNormal0 +\n         posVC.y * vPlaneNormal2 +\n         posVC.z * vPlaneNormal4 +\n         vOriginVC;\n}\n\n// convert vector position from vc to idx\nvec3 VCtoIS(vec3 posVC){\n  posVC = posVC - vOriginVC;\n  posVC = vec3(\n    dot(posVC, vPlaneNormal0),\n    dot(posVC, vPlaneNormal2),\n    dot(posVC, vPlaneNormal4));\n  return posVC * vVCToIJK;\n}\n#endif\n\n//Rotate vector to view coordinate\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\nvoid rotateToViewCoord(inout vec3 dirIS){\n  dirIS.xyz =\n    dirIS.x * vPlaneNormal0 +\n    dirIS.y * vPlaneNormal2 +\n    dirIS.z * vPlaneNormal4;\n}\n\n//Rotate vector to idx coordinate\nvec3 rotateToIDX(vec3 dirVC){\n  vec3 dirIS;\n  dirIS.xyz = vec3(\n    dot(dirVC, vPlaneNormal0),\n    dot(dirVC, vPlaneNormal2),\n    dot(dirVC, vPlaneNormal4));\n  return dirIS;\n}\n#endif\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\n{\n#if defined(vtkGradientOpacityOn)\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n#else\n  return 1.0;\n#endif\n}\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward difference\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\n#ifdef vtkClippingPlanesOn\n  void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\n  {\n    vec3 g1VC[3];\n    for (int i = 0; i < 3; ++i)\n    {\n      g1VC[i] = IStoVC(texPos[i]);\n    }\n    vec3 posVC = IStoVC(pos);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      for (int j = 0; j < 3; ++j)\n      {\n        if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\n        {\n          g1[j] = 0.0;\n        }\n      }\n    }\n  }\n#endif\n\n  #ifdef vtkComputeNormalFromOpacity\n    #ifdef vtkGradientOpacityOn\n      vec4 computeDensityNormal(float gradientMag, vec3 scalarInterp[2])\n      {\n    #else\n      //if gradient opacity not on but using density gradient\n      vec4 computeDensityNormal(vec3 scalarInterp[2])\n      {\n    #endif\n        vec3 opacityG1, opacityG2;\n        opacityG1.x = texture2D(otexture, vec2(scalarInterp[0].x * oscale0 + oshift0, 0.5)).r;\n        opacityG1.y = texture2D(otexture, vec2(scalarInterp[0].y * oscale0 + oshift0, 0.5)).r;\n        opacityG1.z = texture2D(otexture, vec2(scalarInterp[0].z * oscale0 + oshift0, 0.5)).r;\n        opacityG2.x = texture2D(otexture, vec2(scalarInterp[1].x * oscale0 + oshift0, 0.5)).r;\n        opacityG2.y = texture2D(otexture, vec2(scalarInterp[1].y * oscale0 + oshift0, 0.5)).r;\n        opacityG2.z = texture2D(otexture, vec2(scalarInterp[1].z * oscale0 + oshift0, 0.5)).r;\n    #ifdef vtkGradientOpacityOn\n        float gradOpacityFactor = 1.0f;\n        if (gradientMag >= 0.0){\n          gradOpacityFactor = computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\n        }\n        opacityG1.xyz *= gradOpacityFactor;\n        opacityG2.xyz *= gradOpacityFactor;\n    #endif\n\n        vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\n        // divide by spacing\n        opacityG.xyz /= vSpacing;\n        opacityG.w = length(opacityG.xyz);\n        // rotate to View Coords\n        rotateToViewCoord(opacityG.xyz);\n        if (length(opacityG.xyz) > 0.0) {\n          return vec4(normalize(opacityG.xyz),opacityG.w);\n        } else {\n          return vec4(0.0);\n        }\n      }\n\n      vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2])\n      {\n        vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n        vec3 yvec = vec3(0.0, tstep.y, 0.0);\n        vec3 zvec = vec3(0.0, 0.0, tstep.z);\n        vec3 texPosPVec[3];\n        texPosPVec[0] = pos + xvec;\n        texPosPVec[1] = pos + yvec;\n        texPosPVec[2] = pos + zvec;\n        vec3 texPosNVec[3];\n        texPosNVec[0] = pos - xvec;\n        texPosNVec[1] = pos - yvec;\n        texPosNVec[2] = pos - zvec;\n        vec3 g1, g2;\n\n        scalarInterp[0].x = getTextureValue(texPosPVec[0]).a;\n        scalarInterp[0].y = getTextureValue(texPosPVec[1]).a;\n        scalarInterp[0].z = getTextureValue(texPosPVec[2]).a;\n        scalarInterp[1].x = getTextureValue(texPosNVec[0]).a;\n        scalarInterp[1].y = getTextureValue(texPosNVec[1]).a;\n        scalarInterp[1].z = getTextureValue(texPosNVec[2]).a;\n\n        #ifdef vtkClippingPlanesOn\n          adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\n          adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\n        #endif\n        vec4 result;\n        result.x = scalarInterp[0].x - scalarInterp[1].x;\n        result.y = scalarInterp[0].y - scalarInterp[1].y;\n        result.z = scalarInterp[0].z - scalarInterp[1].z;\n        // divide by spacing\n        result.xyz /= vSpacing;\n        result.w = length(result.xyz);\n        // rotate to View Coords\n        rotateToViewCoord(result.xyz);\n        if (length(result.xyz) > 0.0) {\n          return vec4(normalize(result.xyz),result.w);\n        } else {\n          return vec4(0.0);\n        }\n      }\n  #endif\n\n  vec4 computeNormal(vec3 pos, vec3 tstep)\n  {\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\n    vec3 texPosPVec[3];\n    texPosPVec[0] = pos + xvec;\n    texPosPVec[1] = pos + yvec;\n    texPosPVec[2] = pos + zvec;\n    vec3 texPosNVec[3];\n    texPosNVec[0] = pos - xvec;\n    texPosNVec[1] = pos - yvec;\n    texPosNVec[2] = pos - zvec;\n    vec3 g1, g2;\n    g1.x = getTextureValue(texPosPVec[0]).a;\n    g1.y = getTextureValue(texPosPVec[1]).a;\n    g1.z = getTextureValue(texPosPVec[2]).a;\n    g2.x = getTextureValue(texPosNVec[0]).a;\n    g2.y = getTextureValue(texPosNVec[1]).a;\n    g2.z = getTextureValue(texPosNVec[2]).a;\n    #ifdef vtkClippingPlanesOn\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\n    #endif\n    vec4 result;\n    result = vec4(g1 - g2, -1.0);\n    // divide by spacing\n    result.xyz /= vSpacing;\n    result.w = length(result.xyz);\n    if (result.w > 0.0){\n      // rotate to View Coords\n      rotateToViewCoord(result.xyz);\n      return vec4(normalize(result.xyz),result.w);\n    } else {\n      return vec4(0.0);\n    }\n  }\n#endif\n\n#ifdef vtkImageLabelOutlineOn\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = vec4(\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n    (fragCoord.z - 0.5) * 2.0,\n    1.0);\n\n  vec4 worldCoord = PCWCMatrix * pcPos;\n  vec4 vertex = (worldCoord/worldCoord.w);\n\n  vec3 index = (vWCtoIDX * vertex).xyz;\n\n  // half voxel fix for labelmapOutline\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\n}\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\nfloat random()\n{\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\n  uint pcg_state = floatBitsToUint(jitter);\n  uint state = pcg_state;\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\n}\n#endif\n\n#ifdef VolumeShadowOn\n// henyey greenstein phase function\nfloat phase_function(float cos_angle)\n{\n  // divide by 2.0 instead of 4pi to increase intensity\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\n}\n\n// Computes the intersection between a ray and a box\nstruct Hit\n{\n  float tmin;\n  float tmax;\n};\n\nstruct Ray\n{\n  vec3 origin;\n  vec3 dir;\n  vec3 invDir;\n};\n\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\n{\n  vec3 tbot = r.invDir * (boundMin - r.origin);\n  vec3 ttop = r.invDir * (boundMax - r.origin);\n  vec3 tmin = min(ttop, tbot);\n  vec3 tmax = max(ttop, tbot);\n  vec2 t = max(tmin.xx, tmin.yz);\n  float t0 = max(t.x, t.y);\n  t = min(tmax.xx, tmax.yz);\n  float t1 = min(t.x, t.y);\n  hit.tmin = t0;\n  hit.tmax = t1;\n  return t1 > max(t0,0.0);\n}\n\n// As BBoxIntersect requires the inverse of the ray coords,\n// this function is used to avoid numerical issues\nvoid safe_0_vector(inout Ray ray)\n{\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\n}\n\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\n{\n  float shadow = 1.0;\n  float opacity = 0.0;\n\n  // modify sample distance with a random number between 1.5 and 3.0\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\n\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\n\n  // compute the start and end points for the ray\n  Ray ray;\n  Hit hit;\n  ray.origin = posIS;\n  ray.dir = lightDirNormIS;\n  safe_0_vector(ray);\n  ray.invDir = 1.0/ray.dir;\n\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\n  {\n    return 1.0;\n  }\n  float maxdist = hit.tmax;\n\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\n  maxdist = min(maxdist,maxgi);\n  if(maxdist < EPSILON) {\n    return 1.0;\n  }\n\n  // support gradient opacity\n  #ifdef vtkGradientOpacityOn\n    vec4 normal;\n  #endif\n\n  float current_dist = 0.0;\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\n  float clamped_step = 0.0;\n\n  vec4 scalar = vec4(0.0);\n  while(current_dist < maxdist)\n  {\n#ifdef vtkClippingPlanesOn\n    vec3 posVC = IStoVC(posIS);\n    for (int i = 0; i < clip_numPlanes; ++i)\n    {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\n      {\n        current_dist = maxdist;\n      }\n    }\n#endif\n    scalar = getTextureValue(posIS);\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\n    #ifdef vtkGradientOpacityOn\n      normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    shadow *= 1.0 - opacity;\n\n    // optimization: early termination\n    if (shadow < EPSILON){\n      return 0.0;\n    }\n\n    clamped_step = min(maxdist - current_dist, current_step);\n    posIS += clamped_step * lightDirNormIS;\n    current_dist += current_step;\n  }\n\n  return shadow;\n}\n\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\n{\n  vec3 vertLight = vec3(0.0);\n  vec3 secondary_contrib = vec3(0.0);\n  // here we assume only positional light, no effect of cones\n  for (int i = 0; i < lightNum; i++)\n  {\n    #if(vtkLightComplexity==3)\n      if (lightPositional[i] == 1){\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\n      }else{\n        vertLight = - lightDirectionVC[i];\n      }\n    #else\n      vertLight = - lightDirectionVC[i];\n    #endif\n    // here we assume achromatic light, only intensity\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    float phase_attenuation = 0.5;\n    if (abs(anisotropy) > EPSILON){\n      phase_attenuation = phase_function(dDotL);\n    }\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\n    secondary_contrib += tColor * vAmbient;\n  }\n  return secondary_contrib;\n}\n#endif\n\n//=======================================================================\n// local ambient occlusion\n#ifdef localAmbientOcclusionOn\nvec3 sample_direction_uniform(int i)\n{\n  float rand = random() * 0.5;\n  float theta = PI2 * (kernelSample[i][0] + rand);\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\n}\n\n// return a matrix that transform startDir into z axis; startDir should be normalized\nmat3 zBaseRotationalMatrix(vec3 startDir){\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\n  float cosA = startDir.z;\n  float k = 1.0 / (1.0 + cosA);\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\n  return matrix;\n}\n\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\n  // apply LAO only at selected locations, otherwise return full brightness\n  if (normal.w > 0.0 && op > 0.05){\n    float total_transmittance = 0.0;\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\n    vec3 currPos, randomDirStep;\n    float weight, transmittance, opacity;\n    for (int i = 0; i < kernelSize; i++)\n    {\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\n      currPos = posIS;\n      transmittance = 1.0;\n      for (int j = 0; j < kernelRadius ; j++){\n        currPos += randomDirStep;\n        // check if it's at clipping plane, if so return full brightness\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\n          #ifdef vtkGradientOpacityOn\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\n          #endif\n          transmittance *= 1.0 - opacity;\n        }\n        else{\n          break;\n        }\n      }\n      total_transmittance += transmittance / float(kernelRadius) * weight;\n\n      // early termination if fully translucent\n      if (total_transmittance > 1.0 - EPSILON){\n        return 1.0;\n      }\n    }\n    // average transmittance and reduce variance\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\n  } else {\n    return 1.0;\n  }\n}\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkLightComplexity > 0\n  void applyLighting(inout vec3 tColor, vec4 normal)\n  {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    float df, sf = 0.0;\n    for (int i = 0; i < lightNum; i++){\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\n        diffuse += df * lightColor[i];\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\n        specular += sf * lightColor[i];\n    }\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n  }\n  #ifdef SurfaceShadowOn\n  #if vtkLightComplexity < 3\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float ndotL,vdotR;\n        vertLightDirection = lightDirectionVC[i];\n        ndotL = dot(normal.xyz, vertLightDirection);\n        if (ndotL < 0.0 && twoSidedLighting)\n        {\n          ndotL = -ndotL;\n        }\n        if (ndotL > 0.0)\n        {\n          diffuse += ndotL * lightColor[i];\n          //specular\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n          if (vdotR > 0.0)\n          {\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\n          }\n        }\n        #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n        #endif\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #else\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\n    {\n      // everything in VC\n      vec3 diffuse = vec3(0.0);\n      vec3 specular = vec3(0.0);\n      #ifdef localAmbientOcclusionOn\n        vec3 ambient = vec3(0.0);\n      #endif\n      vec3 vertLightDirection;\n      for (int i = 0; i < lightNum; i++){\n        float distance,attenuation,ndotL,vdotR;\n        vec3 lightDir;\n        if (lightPositional[i] == 1){\n          lightDir = lightDirectionVC[i];\n          vertLightDirection = posVC - lightPositionVC[i];\n          distance = length(vertLightDirection);\n          vertLightDirection = normalize(vertLightDirection);\n          attenuation = 1.0 / (lightAttenuation[i].x\n                              + lightAttenuation[i].y * distance\n                              + lightAttenuation[i].z * distance * distance);\n          // per OpenGL standard cone angle is 90 or less for a spot light\n          if (lightConeAngle[i] <= 90.0){\n            float coneDot = dot(vertLightDirection, lightDir);\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\n            }\n            else {\n              attenuation = 0.0;\n            }\n          }\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * attenuation * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        } else {\n          vertLightDirection = lightDirectionVC[i];\n          ndotL = dot(normal.xyz, vertLightDirection);\n          if (ndotL < 0.0 && twoSidedLighting)\n          {\n            ndotL = -ndotL;\n          }\n          if (ndotL > 0.0)\n          {\n            diffuse += ndotL * lightColor[i];\n            //specular\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\n            if (vdotR > 0.0)\n            {\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\n            }\n          }\n          #ifdef localAmbientOcclusionOn\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\n          #endif\n        }\n      }\n      #ifdef localAmbientOcclusionOn\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\n      #else\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\n      #endif\n    }\n  #endif\n  #endif\n#endif\n\n//=======================================================================\n// Given a texture value compute the color and opacity\n//\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n#ifdef vtkImageLabelOutlineOn\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  int segmentIndex = int(centerValue.r * 255.0);\n  \n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\n\n  int actualThickness = int(textureValue * 255.0);\n\n  if (actualThickness == 0) {\n    return vec4(0, 0, 1, 1);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  if (float(tColor.a) > 0.01) {\n    for (int i = -actualThickness; i <= actualThickness; i++) {\n      for (int j = -actualThickness; j <= actualThickness; j++) {\n        if (i == 0 || j == 0) {\n          continue;\n        }\n\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n          gl_FragCoord.y + float(j),\n          gl_FragCoord.z, gl_FragCoord.w);\n\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n        vec4 value = getTextureValue(neighborPosIS);\n\n        // If any of my neighbours are not the same value as I\n        // am, this means I am on the border of the segment.\n        // We can break the loops\n        if (any(notEqual(value, centerValue))) {\n          pixelOnBorder = true;\n          break;\n        }\n      }\n\n      if (pixelOnBorder == true) {\n        break;\n      }\n    }\n\n    // If I am on the border, I am displayed at full opacity\n    if (pixelOnBorder == true) {\n      tColor.a = outlineOpacity;\n    }\n  }\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n  //\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\n\n  // compute the normal vectors as needed\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #if !defined(vtkComponent0Proportional)\n        vec4 normal0 = normalMat[0];\n      #endif\n      #if !defined(vtkComponent1Proportional)\n        vec4 normal1 = normalMat[1];\n      #endif\n      #if vtkNumComponents > 2\n        #if !defined(vtkComponent2Proportional)\n          vec4 normal2 = normalMat[2];\n        #endif\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            vec4 normal3 = normalMat[3];\n          #endif\n        #endif\n      #endif\n    #else\n      vec4 normalLight;\n      #ifdef vtkComputeNormalFromOpacity\n        vec3 scalarInterp[2];\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp);\n        if (length(normal0)>0.0){\n          #ifdef vtkGradientOpacityOn\n            normalLight = computeDensityNormal(normal0.w, scalarInterp);\n          #else\n            normalLight = computeDensityNormal(scalarInterp);\n          #endif\n          if (length(normalLight) == 0.0){\n            normalLight = normal0;\n          }\n        }\n      #else\n        vec4 normal0 = computeNormal(posIS, tstep);\n        normalLight = normal0;\n      #endif\n    #endif\n  #endif\n\n  // compute gradient opacity factors as needed\n  #if defined(vtkGradientOpacityOn)\n    #if !defined(vtkComponent0Proportional)\n      goFactor.x =\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\n      #if !defined(vtkComponent1Proportional)\n        goFactor.y =\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\n      #endif\n      #if vtkNumComponents > 2\n        #if !defined(vtkComponent2Proportional)\n          goFactor.z =\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\n        #endif\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            goFactor.w =\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\n          #endif\n        #endif\n      #endif\n    #endif\n  #endif\n\n  // single component is always independent\n  #if vtkNumComponents == 1\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n    if (tColor.a < EPSILON){\n      return vec4(0.0);\n    }\n  #endif\n\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\n    #if !defined(vtkComponent0Proportional)\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n    #else\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n      tColor *= pwfValue;\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\n    #endif\n\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n    #if !defined(vtkComponent1Proportional)\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n    #else\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n      tColor1 *= pwfValue;\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\n    #endif\n\n    #if vtkNumComponents >= 3\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n      #if !defined(vtkComponent2Proportional)\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n      #else\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n        tColor2 *= pwfValue;\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\n      #endif\n\n      #if vtkNumComponents >= 4\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n        #if !defined(vtkComponent3Proportional)\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #else\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n          tColor3 *= pwfValue;\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\n        #endif\n      #endif\n    #endif\n  #else // then not independent\n\n  #if vtkNumComponents == 2\n    float lum = tValue.r * cscale0 + cshift0;\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    vec4 tColor = vec4(lum, lum, lum, alpha);\n  #endif\n  #if vtkNumComponents == 3\n    vec4 tColor;\n    tColor.r = tValue.r * cscale0 + cshift0;\n    tColor.g = tValue.g * cscale1 + cshift1;\n    tColor.b = tValue.b * cscale2 + cshift2;\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n  #endif\n  #if vtkNumComponents == 4\n    vec4 tColor;\n    tColor.r = tValue.r * cscale0 + cshift0;\n    tColor.g = tValue.g * cscale1 + cshift1;\n    tColor.b = tValue.b * cscale2 + cshift2;\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n  #endif\n  #endif // dependent\n\n  // apply lighting if requested as appropriate\n  #if vtkLightComplexity > 0\n    #if !defined(vtkComponent0Proportional)\n      #if vtkNumComponents == 1\n        #ifdef SurfaceShadowOn\n            #if vtkLightComplexity < 3\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\n            #else\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\n            #endif\n        #endif\n\n        #ifdef VolumeShadowOn\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\n          #ifdef SurfaceShadowOn\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\n          #else\n            tColor.rgb = tColorVS;\n          #endif\n        #else\n            tColor.rgb = tColorS;\n        #endif\n\n      #else\n        applyLighting(tColor.rgb, normal0);\n      #endif\n    #endif\n\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\n      #if !defined(vtkComponent1Proportional)\n        applyLighting(tColor1, normal1);\n      #endif\n    #if vtkNumComponents >= 3\n      #if !defined(vtkComponent2Proportional)\n        applyLighting(tColor2, normal2);\n      #endif\n    #if vtkNumComponents >= 4\n      #if !defined(vtkComponent3Proportional)\n        applyLighting(tColor3, normal3);\n      #endif\n    #endif\n    #endif\n    #endif\n  #endif\n\n// perform final independent blend as needed\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\n  tColor.rgb += tColor1;\n#if vtkNumComponents >= 3\n  tColor.rgb += tColor2;\n#if vtkNumComponents >= 4\n  tColor.rgb += tColor3;\n#endif\n#endif\n#endif\n\n#endif\nreturn tColor;\n}\n\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\n  bool withinRange = false;\n  #if vtkNumComponents == 1\n    if (val.r >= min.r && val.r <= max.r) {\n      withinRange = true;\n    }\n  #endif\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\n     if (val.r >= min.r && val.r <= max.r &&\n        val.g >= min.g && val.g <= max.g) {\n      withinRange = true;\n    }\n  #endif\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\n        all(lessThanEqual(val, ipScalarRangeMax))) {\n      withinRange = true;\n    }\n  #endif\n  return withinRange;\n}\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\n    vec4 sum = vec4(0.);\n\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n        // Sum the values across each step in the path\n        sum += tValue;\n      }\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    #if vtkBlendMode == 3 // Average\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 5 // RADON\n    float normalizedRayIntensity = 1.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tValue = getTextureValue(posIS);\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar value\n      tValue = getTextureValue(posIS);\n\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n\n      posIS += stepIS;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\n\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (abs(result) < 1e-6)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*tdims;\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n  #ifdef VolumeShadowOn\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\n  #endif\n}\n\nvoid main()\n{\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, tdims);\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Fragment;o.getProperty().getInterpolationType()===wg.LINEAR&&(a=cd.substitute(a,"//VTK::TrilinearOn","#define vtkTrilinearOn").result),!0===o.getProperty().getUseLabelOutline()&&(a=cd.substitute(a,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result);const i=t.scalarTexture.getComponents();a=cd.substitute(a,"//VTK::NumComponents",`#define vtkNumComponents ${i}`).result;const s=o.getProperty().getIndependentComponents();if(s){a=cd.substitute(a,"//VTK::IndependentComponentsOn","#define vtkIndependentComponentsOn").result;const e=[];for(let t=0;t<i;t++)o.getProperty().getOpacityMode(t)===Pg.PROPORTIONAL&&e.push(`#define vtkComponent${t}Proportional`);e.length>0&&(a=cd.substitute(a,"//VTK::vtkProportionalComponents",e.join("\n")).result)}const l=t.currentInput.getSpatialExtent(),c=t.currentInput.getSpacing(),u=new Float64Array(3);In(u,(l[1]-l[0])*c[0],(l[3]-l[2])*c[1],(l[5]-l[4])*c[2]);const d=Sn(u)/e.getCurrentSampleDistance(r);a=cd.substitute(a,"//VTK::MaximumSamplesValue",`${Math.ceil(d)}`).result,a=cd.substitute(a,"//VTK::LightComplexity",`#define vtkLightComplexity ${t.lastLightComplexity}`).result,t.lastLightComplexity>0&&(t.renderable.getVolumetricScatteringBlending()>0&&(a=cd.substitute(a,"//VTK::VolumeShadowOn","#define VolumeShadowOn").result),t.renderable.getVolumetricScatteringBlending()<1&&(a=cd.substitute(a,"//VTK::SurfaceShadowOn","#define SurfaceShadowOn").result),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0&&(a=cd.substitute(a,"//VTK::localAmbientOcclusionOn","#define localAmbientOcclusionOn").result)),t.gopacity=o.getProperty().getUseGradientOpacity(0);for(let e=1;s&&!t.gopacity&&e<i;++e)o.getProperty().getUseGradientOpacity(e)&&(t.gopacity=!0);t.gopacity&&(a=cd.substitute(a,"//VTK::GradientOpacityOn","#define vtkGradientOpacityOn").result),t.renderable.getComputeNormalFromOpacity()&&(a=cd.substitute(a,"//VTK::vtkComputeNormalFromOpacity","#define vtkComputeNormalFromOpacity").result),null!==t.zBufferTexture&&(a=cd.substitute(a,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,a=cd.substitute(a,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDir.z;","dists.y = min(zdepth,dists.y);"]).result),a=cd.substitute(a,"//VTK::BlendMode",`${t.renderable.getBlendMode()}`).result,n.Fragment=a,e.replaceShaderLight(n,r,o),e.replaceShaderClippingPlane(n,r,o)},e.replaceShaderLight=(e,n,r)=>{if(0===t.lastLightComplexity)return;let o=e.Fragment,a=0;n.getLights().forEach((e=>{e.getSwitch()&&(a+=1)})),o=cd.substitute(o,"//VTK::Light::Dec",["uniform int lightNum;","uniform bool twoSidedLighting;",`uniform vec3 lightColor[${a}];`,`uniform vec3 lightDirectionVC[${a}]; // normalized`,`uniform vec3 lightHalfAngleVC[${a}];`,"//VTK::Light::Dec"],!1).result,3===t.lastLightComplexity&&(o=cd.substitute(o,"//VTK::Light::Dec",[`uniform vec3 lightPositionVC[${a}];`,`uniform vec3 lightAttenuation[${a}];`,`uniform float lightConeAngle[${a}];`,`uniform float lightExponent[${a}];`,`uniform int lightPositional[${a}];`],!1).result),t.renderable.getVolumetricScatteringBlending()>0&&(o=cd.substitute(o,"//VTK::VolumeShadow::Dec",["uniform float volumetricScatteringBlending;","uniform float giReach;","uniform float volumeShadowSamplingDistFactor;","uniform float anisotropy;","uniform float anisotropy2;"],!1).result),t.renderable.getLocalAmbientOcclusion()&&r.getProperty().getAmbient()>0&&(o=cd.substitute(o,"//VTK::LAO::Dec",["uniform int kernelRadius;",`uniform vec2 kernelSample[${t.renderable.getLAOKernelRadius()}];`,"uniform int kernelSize;"],!1).result),e.Fragment=o},e.replaceShaderClippingPlane=(e,n,r)=>{let o=e.Fragment;if(t.renderable.getClippingPlanes().length>0){const e=t.renderable.getClippingPlanes().length;o=cd.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=cd.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${e}; i++) {`,"  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result}e.Fragment=o},e.getNeedToRebuildShaders=(n,r,o)=>{let a=0;o.getProperty().getShade()&&t.renderable.getBlendMode()===Rg.COMPOSITE_BLEND&&(a=0,t.numberOfLights=0,r.getLights().forEach((e=>{e.getSwitch()>0&&(t.numberOfLights++,0===a&&(a=1)),1===a&&(t.numberOfLights>1||1!==e.getIntensity()||!e.lightTypeIsHeadLight())&&(a=2),a<3&&e.getPositional()&&(a=3)})));let i=!1;t.lastLightComplexity!==a&&(t.lastLightComplexity=a,i=!0);const s=t.scalarTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=!1;const u=[];if(l){for(let e=0;e<s;e++)u.push(o.getProperty().getOpacityMode(e));u.length>0&&(c=!0)}const d=t.currentInput.getSpatialExtent(),p=t.currentInput.getSpacing(),f=new Float64Array(3);In(f,(d[1]-d[0])*p[0],(d[3]-d[2])*p[1],(d[5]-d[4])*p[2]);const g=Sn(f)/e.getCurrentSampleDistance(r),m={interpolationType:o.getProperty().getInterpolationType(),useLabelOutline:o.getProperty().getUseLabelOutline(),numComp:s,usesProportionalComponents:c,iComps:l,maxSamples:g,useGradientOpacity:o.getProperty().getUseGradientOpacity(0),blendMode:t.renderable.getBlendMode(),proportionalComponents:u};return t.previousState&&t.previousState.interpolationType===m.interpolationType&&t.previousState.useLabelOutline===m.useLabelOutline&&t.previousState.numComp===m.numComp&&t.previousState.usesProportionalComponents===m.usesProportionalComponents&&t.previousState.iComps===m.iComps&&t.previousState.maxSamples===m.maxSamples&&t.previousState.useGradientOpacity===m.useGradientOpacity&&t.previousState.blendMode===m.blendMode&&function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(t.previousState.proportionalComponents,m.proportionalComponents)?!!(0===n.getProgram()?.getHandle()||i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||!!t.lastZBufferTexture!=!!t.zBufferTexture||n.getShaderSourceTime().getMTime()<e.getMTime()||n.getShaderSourceTime().getMTime()<t.renderable.getMTime())&&(t.lastZBufferTexture=t.zBufferTexture,!0):(t.previousState={...m},!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified()),a.setUniformi("texture1",t.scalarTexture.getTextureUnit()),a.setUniformf("sampleDistance",e.getCurrentSampleDistance(r));const i=t.scalarTexture.getVolumeInfo(),s=t.renderable.getIpScalarRange(),l=[],c=[];for(let e=0;e<4;e++)l[e]=s[0]*i.dataComputedScale[e]+i.dataComputedOffset[e],c[e]=s[1]*i.dataComputedScale[e]+i.dataComputedOffset[e],l[e]=(l[e]-i.offset[e])/i.scale[e],c[e]=(c[e]-i.offset[e])/i.scale[e];if(a.setUniform4f("ipScalarRangeMin",l[0],l[1],l[2],l[3]),a.setUniform4f("ipScalarRangeMax",c[0],c[1],c[2],c[3]),null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(n,r,o)=>{const a=t.openGLCamera.getKeyMatrices(r),i=t.openGLVolume.getKeyMatrices();T(t.modelToView,a.wcvc,i.mcwc);const s=n.getProgram(),l=t.openGLCamera.getRenderable(),c=l.getClippingRange();s.setUniformf("camThick",c[1]-c[0]),s.setUniformf("camNear",c[0]),s.setUniformf("camFar",c[1]);const u=t.currentInput.getBounds(),d=t.currentInput.getDimensions(),p=new Float64Array(3),f=new Float64Array(3);let g=1,m=-1,v=1,y=-1;for(let e=0;e<8;++e)In(p,u[e%2],u[2+Math.floor(e/2)%2],u[4+Math.floor(e/4)]),Vn(p,p,t.modelToView),l.getParallelProjection()||(Mn(f,p),On(p,f,-c[0]/p[2])),Vn(p,p,a.vcpc),g=Math.min(p[0],g),m=Math.max(p[0],m),v=Math.min(p[1],v),y=Math.max(p[1],y);s.setUniformf("dcxmin",g),s.setUniformf("dcxmax",m),s.setUniformf("dcymin",v),s.setUniformf("dcymax",y),s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",l.getParallelProjection());const b=t.currentInput.getSpatialExtent(),x=t.currentInput.getSpacing(),C=new Float64Array(3);In(C,(b[1]-b[0])*x[0],(b[3]-b[2])*x[1],(b[5]-b[4])*x[2]),s.setUniform3f("vSpacing",x[0],x[1],x[2]),In(p,b[0],b[2],b[4]),t.currentInput.indexToWorldVec3(p,p),Vn(p,p,t.modelToView),s.setUniform3f("vOriginVC",p[0],p[1],p[2]);const S=t.currentInput.getIndexToWorld();T(t.idxToView,t.modelToView,S),ve(t.idxNormalMatrix,a.normalMatrix,i.normalMatrix),ve(t.idxNormalMatrix,t.idxNormalMatrix,t.currentInput.getDirectionByReference());const A=Sn(C)/e.getCurrentSampleDistance(r);A>t.renderable.getMaximumSamplesPerRay()&&Dg(`The number of steps required ${Math.ceil(A)} is larger than the\n        specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples.`);const I=new Float64Array(3);if(In(I,1,1,1),function(e,t,n){e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2]}(I,I,C),s.setUniform3f("vVCToIJK",I[0],I[1],I[2]),s.setUniform3i("volumeDimensions",d[0],d[1],d[2]),!t._openGLRenderWindow.getWebgl2()){const e=t.scalarTexture.getVolumeInfo();s.setUniformf("texWidth",t.scalarTexture.getWidth()),s.setUniformf("texHeight",t.scalarTexture.getHeight()),s.setUniformi("xreps",e.xreps),s.setUniformi("xstride",e.xstride),s.setUniformi("ystride",e.ystride)}const w=new Float64Array(3),P=new Float64Array(3);for(let e=0;e<6;++e){switch(e){case 1:In(w,-1,0,0),In(P,b[0],b[2],b[4]);break;case 2:In(w,0,1,0),In(P,b[1],b[3],b[5]);break;case 3:In(w,0,-1,0),In(P,b[0],b[2],b[4]);break;case 4:In(w,0,0,1),In(P,b[1],b[3],b[5]);break;case 5:In(w,0,0,-1),In(P,b[0],b[2],b[4]);break;default:In(w,1,0,0),In(P,b[1],b[3],b[5])}Ln(w,w,t.idxNormalMatrix),Vn(P,P,t.idxToView);const n=-1*Dn(P,w);s.setUniform3f(`vPlaneNormal${e}`,w[0],w[1],w[2]),s.setUniformf(`vPlaneDistance${e}`,n)}if(o.getProperty().getUseLabelOutline()){const n=t.currentInput.getWorldToIndex();s.setUniformMatrix("vWCtoIDX",n);const o=r.getActiveCamera(),[a,i]=o.getClippingRange(),l=o.getDistance();o.setClippingRange(l,l+.1);const c=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,c.wcpc),o.setClippingRange(a,i),t.openGLCamera.getKeyMatrices(r),s.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const u=e.getRenderTargetSize();s.setUniformf("vpWidth",u[0]),s.setUniformf("vpHeight",u[1]);const d=e.getRenderTargetOffset();s.setUniformf("vpOffsetX",d[0]/u[0]),s.setUniformf("vpOffsetY",d[1]/u[1])}if(h(t.projectionToView,a.vcpc),s.setUniformMatrix("PCVCMatrix",t.projectionToView),0===t.lastLightComplexity)return;let O=0;const R=[],M=[],D=[];if(r.getLights().forEach((e=>{if(e.getSwitch()>0){const t=e.getColor(),n=e.getIntensity();R[0+3*O]=t[0]*n,R[1+3*O]=t[1]*n,R[2+3*O]=t[2]*n;const r=e.getDirection();In(w,r[0],r[1],r[2]),Ln(w,w,a.normalMatrix),Mn(w,w),M[0+3*O]=w[0],M[1+3*O]=w[1],M[2+3*O]=w[2],D[0+3*O]=-.5*w[0],D[1+3*O]=-.5*w[1],D[2+3*O]=-.5*(w[2]-1),O++}})),s.setUniformi("twoSidedLighting",r.getTwoSidedLighting()),s.setUniformi("lightNum",O),s.setUniform3fv("lightColor",R),s.setUniform3fv("lightDirectionVC",M),s.setUniform3fv("lightHalfAngleVC",D),3===t.lastLightComplexity){O=0;const e=[],n=[],o=[],a=[],i=[];r.getLights().forEach((r=>{if(r.getSwitch()>0){const s=r.getAttenuationValues();n[0+3*O]=s[0],n[1+3*O]=s[1],n[2+3*O]=s[2],a[O]=r.getExponent(),o[O]=r.getConeAngle(),i[O]=r.getPositional();const l=r.getTransformedPosition();Vn(l,l,t.modelToView),e[0+3*O]=l[0],e[1+3*O]=l[1],e[2+3*O]=l[2],O+=1}})),s.setUniform3fv("lightPositionVC",e),s.setUniform3fv("lightAttenuation",n),s.setUniformfv("lightConeAngle",o),s.setUniformfv("lightExponent",a),s.setUniformiv("lightPositional",i)}if(t.renderable.getVolumetricScatteringBlending()>0&&(s.setUniformf("giReach",t.renderable.getGlobalIlluminationReach()),s.setUniformf("volumetricScatteringBlending",t.renderable.getVolumetricScatteringBlending()),s.setUniformf("volumeShadowSamplingDistFactor",t.renderable.getVolumeShadowSamplingDistFactor()),s.setUniformf("anisotropy",t.renderable.getAnisotropy()),s.setUniformf("anisotropy2",t.renderable.getAnisotropy()**2)),t.renderable.getLocalAmbientOcclusion()&&o.getProperty().getAmbient()>0){const e=t.renderable.getLAOKernelSize();s.setUniformi("kernelSize",e);const n=[];for(let t=0;t<e;t++)n[2*t]=.5*Math.random(),n[2*t+1]=.5*Math.random();s.setUniform2fv("kernelSample",n),s.setUniformi("kernelRadius",t.renderable.getLAOKernelRadius())}},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi("ctexture",t.colorTexture.getTextureUnit()),o.setUniformi("otexture",t.opacityTexture.getTextureUnit()),o.setUniformi("jtexture",t.jitterTexture.getTextureUnit()),o.setUniformi("ttexture",t.labelOutlineThicknessTexture.getTextureUnit());const a=t.scalarTexture.getVolumeInfo(),i=r.getProperty(),s=t.scalarTexture.getComponents(),l=r.getProperty().getIndependentComponents();if(l&&s>=2)for(let e=0;e<s;e++)o.setUniformf(`mix${e}`,r.getProperty().getComponentWeight(e));for(let e=0;e<s;e++){const t=l?e:0,n=a.scale[e],r=i.getScalarOpacity(t).getRange(),s=n/(r[1]-r[0]),c=(a.offset[e]-r[0])/(r[1]-r[0]);o.setUniformf(`oshift${e}`,c),o.setUniformf(`oscale${e}`,s);const u=i.getRGBTransferFunction(t).getRange(),d=(a.offset[e]-u[0])/(u[1]-u[0]),p=n/(u[1]-u[0]);o.setUniformf(`cshift${e}`,d),o.setUniformf(`cscale${e}`,p)}if(t.gopacity)if(l)for(let e=0;e<s;++e){const t=a.scale[e];if(i.getUseGradientOpacity(e)){const n=i.getGradientOpacityMinimumOpacity(e),r=i.getGradientOpacityMaximumOpacity(e);o.setUniformf(`gomin${e}`,n),o.setUniformf(`gomax${e}`,r);const a=[i.getGradientOpacityMinimumValue(e),i.getGradientOpacityMaximumValue(e)];o.setUniformf(`goscale${e}`,t*(r-n)/(a[1]-a[0])),o.setUniformf(`goshift${e}`,-a[0]*(r-n)/(a[1]-a[0])+n)}else o.setUniformf(`gomin${e}`,1),o.setUniformf(`gomax${e}`,1),o.setUniformf(`goscale${e}`,0),o.setUniformf(`goshift${e}`,1)}else{const e=a.scale[s-1],t=i.getGradientOpacityMinimumOpacity(0),n=i.getGradientOpacityMaximumOpacity(0);o.setUniformf("gomin0",t),o.setUniformf("gomax0",n);const r=[i.getGradientOpacityMinimumValue(0),i.getGradientOpacityMaximumValue(0)];o.setUniformf("goscale0",e*(n-t)/(r[1]-r[0])),o.setUniformf("goshift0",-r[0]*(n-t)/(r[1]-r[0])+t)}if(!0===r.getProperty().getUseLabelOutline()){const e=r.getProperty().getLabelOutlineOpacity();o.setUniformf("outlineOpacity",e)}t.lastLightComplexity>0&&(o.setUniformf("vAmbient",i.getAmbient()),o.setUniformf("vDiffuse",i.getDiffuse()),o.setUniformf("vSpecular",i.getSpecular()),o.setUniformf("vSpecularPower",i.getSpecularPower()))},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();Ln(t,t,r.normalMatrix),Vn(n,n,r.wcvc);const l=-1*Dn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r),r.getProperty().getInterpolationType()===wg.NEAREST?(t.scalarTexture.setMinificationFilter(bd.NEAREST),t.scalarTexture.setMagnificationFilter(bd.NEAREST)):(t.scalarTexture.setMinificationFilter(bd.LINEAR),t.scalarTexture.setMagnificationFilter(bd.LINEAR)),t.lastBoundBO=null,null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context;t.scalarTexture.activate(),t.opacityTexture.activate(),t.labelOutlineThicknessTexture.activate(),t.colorTexture.activate(),t.jitterTexture.activate(),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.scalarTexture.deactivate(),t.colorTexture.deactivate(),t.opacityTexture.deactivate(),t.labelOutlineThicknessTexture.deactivate(),t.jitterTexture.deactivate()},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Eg("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Eg("No input!")},e.computeBounds=(n,r)=>{e.getInput()?t.bounds=e.getInput().getBounds():Oa(t.Bounds)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;t._scalars!==a&&(t._openGLRenderWindow.releaseGraphicsResourcesForObject(t._scalars),t._scalars=a);const i=r.getProperty();if(!t.jitterTexture.getHandle()){const e=new Uint8Array(1024);for(let t=0;t<1024;++t)e[t]=255*Math.random();t.jitterTexture.setMinificationFilter(bd.LINEAR),t.jitterTexture.setMagnificationFilter(bd.LINEAR),t.jitterTexture.create2DFromRaw(32,32,1,ys.UNSIGNED_CHAR,e)}const s=a.getNumberOfComponents(),l=i.getIndependentComponents()?s:1,c=i.getScalarOpacity(),u=t._openGLRenderWindow.getGraphicsResourceForObject(c);let d=Vg(i,c,l);if(u.vtkObj&&u.hash===d&&t.opacityTextureString===d)t.opacityTexture=u.vtkObj,t.opacityTextureString=u.hash;else{const r=1024,o=2*r*l,a=new Float32Array(o),s=new Float32Array(r);for(let t=0;t<l;++t){const o=i.getScalarOpacity(t),l=e.getCurrentSampleDistance(n)/i.getScalarOpacityUnitDistance(t),c=o.getRange();o.getTable(c[0],c[1],r,s,1);for(let e=0;e<r;++e)a[t*r*2+e]=1-(1-s[e])**l,a[t*r*2+e+r]=a[t*r*2+e]}if(t.opacityTexture.releaseGraphicsResources(t._openGLRenderWindow),t.opacityTexture.resetFormatAndType(),t.opacityTexture.setMinificationFilter(bd.LINEAR),t.opacityTexture.setMagnificationFilter(bd.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))t.opacityTexture.create2DFromRaw(r,2*l,1,ys.FLOAT,a);else{const e=new Uint8ClampedArray(o);for(let t=0;t<o;++t)e[t]=255*a[t];t.opacityTexture.create2DFromRaw(r,2*l,1,ys.UNSIGNED_CHAR,e)}t.opacityTextureString=d,c&&t._openGLRenderWindow.setGraphicsResourceForObject(c,t.opacityTexture,t.opacityTextureString)}const p=i.getRGBTransferFunction();d=Vg(i,p,l);const f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.vtkObj&&f?.hash===d&&t.colorTextureString===d)t.colorTexture=f.vtkObj,t.colorTextureString=f.hash;else{const e=1024,n=new Uint8ClampedArray(2*e*l*3),r=new Float32Array(3*e);for(let t=0;t<l;++t){const o=i.getRGBTransferFunction(t),a=o.getRange();o.getTable(a[0],a[1],e,r,1);for(let o=0;o<3*e;++o)n[t*e*6+o]=255*r[o],n[t*e*6+o+3*e]=255*r[o]}t.colorTexture.releaseGraphicsResources(t._openGLRenderWindow),t.colorTexture.resetFormatAndType(),t.colorTexture.setMinificationFilter(bd.LINEAR),t.colorTexture.setMagnificationFilter(bd.LINEAR),t.colorTexture.create2DFromRaw(e,2*l,3,ys.UNSIGNED_CHAR,n),t.colorTextureString=d,p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,t.colorTexture,t.colorTextureString)}e.updateLabelOutlineThicknessTexture(r);const g=t._openGLRenderWindow.getGraphicsResourceForObject(a);if(d=`${o.getMTime()}A${a.getMTime()}`,g?.vtkObj&&g?.hash===d&&t.scalarTextureString===d)t.scalarTexture=g.vtkObj,t.scalarTextureString=g.hash;else{const e=o.getDimensions();t.scalarTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.scalarTexture.releaseGraphicsResources(t._openGLRenderWindow),t.scalarTexture.resetFormatAndType(),t.scalarTexture.create3DFilterableFromDataArray(e[0],e[1],e[2],a,t.renderable.getPreferSizeOverAccuracy()),t.scalarTextureString=d,a&&t._openGLRenderWindow.setGraphicsResourceForObject(a,t.scalarTexture,t.scalarTextureString)}if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Es.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Es.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",rs.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()},e.updateLabelOutlineThicknessTexture=e=>{const n=e.getProperty().getLabelOutlineThickness(),r=t._openGLRenderWindow.getGraphicsResourceForObject(n),o=`${n.join("-")}`;if(r?.vtkObj&&r?.hash===o&&t.labelOutlineThicknessTextureString===o)t.labelOutlineThicknessTexture=r.vtkObj,t.labelOutlineThicknessTextureString=r.hash;else{const e=1024,r=1,a=new Uint8Array(e*r);for(let t=0;t<e;++t){const e=n[t]||n[0];a[t]=e}t.labelOutlineThicknessTexture.releaseGraphicsResources(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(bd.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw(e,r,1,ys.UNSIGNED_CHAR,a),t.labelOutlineThicknessTextureString=o,n&&t._openGLRenderWindow.setGraphicsResourceForObject(n,t.labelOutlineThicknessTexture,t.labelOutlineThicknessTextureString)}}}const Bg={context:null,VBOBuildTime:null,scalarTexture:null,scalarTextureString:null,opacityTexture:null,opacityTextureString:null,colorTexture:null,colorTextureString:null,jitterTexture:null,labelOutlineThicknessTexture:null,labelOutlineThicknessTextureString:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,lastLightComplexity:0,fullViewportTime:1,idxToView:null,idxNormalMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0,_scalars:null};const Ng=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bg,n),Zt.extend(e,t,n),t.VBOBuildTime={},yt(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),t.scalarTexture=Nd.newInstance(),t.opacityTexture=Nd.newInstance(),t.colorTexture=Nd.newInstance(),t.jitterTexture=Nd.newInstance(),t.jitterTexture.setWrapS(Td.REPEAT),t.jitterTexture.setWrapT(Td.REPEAT),t.labelOutlineThicknessTexture=Nd.newInstance(),t.framebuffer=Hp.newInstance(),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),At(e,t,["context"]),Lg(e,t)}),"vtkOpenGLVolumeMapper");rn("vtkVolumeMapper",Ng);const{vtkDebugMacro:_g}=Kt;function Fg(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent();const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():_g("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}const kg={};const Gg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),Zt.extend(e,t,n),Fg(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");rn("vtkPixelSpaceCallbackMapper",Gg);var Ug="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:zg}=ds;function Wg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Nd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw(o,a,4,"Float32Array",null),s.activate(),s.sendParameters(),s.deactivate(),s}function Hg(e,t){return Wg(e,t,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE)}function jg(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",zg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Hg(t._openGLRenderWindow,t.size),t.seedTexture0=Hg(t._openGLRenderWindow,t.size),t.licTexture1=Hg(t._openGLRenderWindow,t.size),t.seedTexture1=Hg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Wg(t._openGLRenderWindow,t.size,Nd.Filter.NEAREST,Nd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?function(e,t){return Wg(e,t,Nd.Filter.LINEAR,Nd.Wrap.CLAMP_TO_EDGE)}(t._openGLRenderWindow,t.size):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return 0===e?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(e){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager")}const Kg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function $g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kg,n),jt.obj(e,t),jt.get(e,t,["readIndex"]),jt.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),jg(e,t)}var qg={newInstance:jt.newInstance($g,"vtkLICPingPongBufferManager"),extend:$g};const Xg=0,Yg=1,Zg=2,Qg=3,Jg=1;function em(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Hp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=cd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=cd.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){const e="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    ",t="\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ";return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?t:e}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;f&&o[0]===f.getSize()[0]&&o[1]===f.getSize()[1]||(f=Hp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=qg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const g=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],m=1/o[0],h=1/o[1],v=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;v.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;v.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",0),y.setUniformf("uMaskThreshold",t.maskThreshold),y.setUniform2f("uNoiseBoundsPt1",...g),y.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),y.setUniformi("texLIC",t.bufs.getLICTextureUnit()),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:T}=t;v.readyShaderProgram(T),T.setUniformi("uPassNo",0),T.setUniformf("uStepSize",-d),T.setUniform2f("uNoiseBoundsPt1",...g),T.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:b}=t;if(v.readyShaderProgram(b),b.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,b),t.enhancedLIC){t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;v.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",m),a.setUniformf("uDy",h),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),v.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",1),n(y,t.bufs),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformi("uPassNo",1),T.setUniformf("uStepSize",-d),T.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);v.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),v.readyShaderProgram(T),T.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(T,t.bufs),r(t.bufs,o,T);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),v.readyShaderProgram(b),b.setUniformi("texLIC",t.bufs.getLICTextureUnit()),b.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,b)}if(t.antiAlias){const e=t.AAHProgram;v.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",m);const a=t.AAVProgram;v.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",h);for(let i=0;i<t.antiAlias;++i)v.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),v.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Yg&&t.enhanceContrast!==Qg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}const tm={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function nm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tm,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),em(e,t)}var rm={newInstance:jt.newInstance(nm,"vtkLineIntegralConvolution2D"),extend:nm};function om(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}const am={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Xg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:Jg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function im(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,am,n),jt.obj(e,t),jt.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),om(0,t)}var sm={newInstance:jt.newInstance(im,"vtkSurfaceLICInterface"),extend:im};const{Representation:lm}=ds;function cm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=fd.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),ho()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===Jg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Nd.newInstance({wrapS:Nd.Wrap.REPEAT,wrapT:Nd.Wrap.REPEAT,minificationFilter:Nd.Filter.NEAREST,magnificationFilter:Nd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw(e,e,4,"Float32Array",d),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Ug,e,""),e.allocateTextures=()=>{const n=Nd.Filter.NEAREST,r=Nd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Nd.newInstance({wrapS:Nd.Wrap.CLAMP_TO_EDGE,wrapT:Nd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw(...t.size,4,"Float32Array",null),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Nd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw(...t.size,"Float32Array",null),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Hp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=yd.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Es.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Es.newInstance({numberOfComponents:1,values:o}),s=Es.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",lm.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=rm.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Zg||u===Qg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}const um={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,um,n),sm.extend(e,t,n),jt.obj(e,t),jt.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),jt.moveToProtected(e,t,["openGLRenderWindow"]),cm(e,t)}var pm={newInstance:jt.newInstance(dm,"vtkSurfaceLICInterface"),extend:dm};const{vtkErrorMacro:fm}=Kt;function gm(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=cd.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=cd.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=cd.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=cd.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=cd.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(fm("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(fm("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(fm("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=sm.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=pm.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(fm("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}const mm={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const hm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mm,n),np.extend(e,t,n),gm(e,t),At(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");rn("vtkSurfaceLICMapper",hm);const{vtkErrorMacro:vm}=Kt;function ym(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=Fd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=cd.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=cd.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=cd.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=cd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=cd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=cd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||vm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())o.setUniformMatrix("MCVCMatrix",i.wcvc);else{const e=t.openGLActor.getKeyMatrices(),n=new Float64Array(16);T(n,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",n)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(Oo(30));let h=0,v=0,y=0,T=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=-2*n*m,g[y++]=-n,d&&(v=e*p,f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=2*n*m,g[y++]=-n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3]),h=3*e,g[y++]=c[h++],g[y++]=c[h++],g[y++]=c[h++],g[y++]=0,g[y++]=2*n,d&&(f[T++]=d[v],f[T++]=d[v+1],f[T++]=d[v+2],f[T++]=d[v+3])}a.setElementCount(y/5),a.upload(g,zu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Tm={};const bm=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),np.extend(e,t,n),ym(e,t)}),"vtkOpenGLSphereMapper");rn("vtkSphereMapper",bm);const{vtkErrorMacro:xm}=Kt;function Cm(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=Fd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=cd.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=cd.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=cd.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=cd.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=cd.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=cd.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=cd.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||xm("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||xm("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||xm("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);T(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(qu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():xm(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let y=0,T=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)y=3*e,f[b++]=c[y++],f[b++]=c[y++],f[b++]=c[y++],y=3*e,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=h[y++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,T=e*p,d&&(g[x++]=d[T],g[x++]=d[T+1],g[x++]=d[T+2],g[x++]=d[T+3])}a.setElementCount(b/7),a.upload(f,zu.ARRAY_BUFFER),a.getColorBO().upload(g,zu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}const Sm={};const Am=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sm,n),np.extend(e,t,n),Cm(e,t)}),"vtkOpenGLStickMapper");rn("vtkStickMapper",Am);const Im=[];Im["-".charCodeAt(0)]=62,Im["_".charCodeAt(0)]=63;const wm="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<wm.length;e++)Im[wm.charCodeAt(e)]=e;function Pm(e){return void 0!==Im[e.charCodeAt(0)]}function Om(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<18;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<12;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<6;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<10;!Pm(e[l]);)l++;for(c|=Im[e.charCodeAt(l++)]<<4;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Pm(e[l]);)l++;for(c=Im[e.charCodeAt(l++)]<<2;!Pm(e[l]);)l++;c|=Im[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function Rm(e,t,n){const r=(e<<16)+(t<<8)+n;return wm[r>>18]+wm[r>>12&63]+wm[r>>6&63]+wm[63&r]}function Mm(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=Rm(t[n],t[n+1],t[n+2])}if(n>0){const e=Rm(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var Dm=function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Pm(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Om(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o};const Em={};function Vm(e,t){Em[e]=t}var Lm=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Em[e](t)},Bm=Uint8Array,Nm=Uint16Array,_m=Uint32Array,Fm=new Bm([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),km=new Bm([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Gm=new Bm([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Um=function(e,t){for(var n=new Nm(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new _m(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},zm=Um(Fm,2),Wm=zm[0],Hm=zm[1];Wm[28]=258,Hm[258]=28;for(var jm=Um(km,0),Km=jm[0],$m=(jm[1],new Nm(32768)),qm=0;qm<32768;++qm){var Xm=(43690&qm)>>>1|(21845&qm)<<1;Xm=(61680&(Xm=(52428&Xm)>>>2|(13107&Xm)<<2))>>>4|(3855&Xm)<<4,$m[qm]=((65280&Xm)>>>8|(255&Xm)<<8)>>>1}var Ym=function(e,t,n){for(var r=e.length,o=0,a=new Nm(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Nm(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Nm(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[$m[d]>>>l]=c}else for(i=new Nm(r),o=0;o<r;++o)e[o]&&(i[o]=$m[s[e[o]-1]++]>>>15-e[o]);return i},Zm=new Bm(288);for(qm=0;qm<144;++qm)Zm[qm]=8;for(qm=144;qm<256;++qm)Zm[qm]=9;for(qm=256;qm<280;++qm)Zm[qm]=7;for(qm=280;qm<288;++qm)Zm[qm]=8;var Qm=new Bm(32);for(qm=0;qm<32;++qm)Qm[qm]=5;var Jm=Ym(Zm,9,1),eh=Ym(Qm,5,1),th=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},nh=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},rh=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},oh=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Nm:4==e.BYTES_PER_ELEMENT?_m:Bm)(n-t);return r.set(e.subarray(t,n)),r},ah=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],ih=function(e,t,n){var r=new Error(t||ah[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,ih),!n)throw r;return r},sh=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Bm(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Bm(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Bm(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=nh(e,c,1);var h=nh(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(O=4+((i+7)/8|0))-4)]|e[O-3]<<8,y=O+v;if(y>r){a&&ih(0);break}o&&s(u+v),t.set(e.subarray(O,y),u),n.b=u+=v,n.p=c=8*y,n.f=l;continue}if(1==h)d=Jm,p=eh,f=9,g=5;else if(2==h){var T=nh(e,c,31)+257,b=nh(e,c+10,15)+4,x=T+nh(e,c+5,31)+1;c+=14;for(var C=new Bm(x),S=new Bm(19),A=0;A<b;++A)S[Gm[A]]=nh(e,c+3*A,7);c+=3*b;var I=th(S),w=(1<<I)-1,P=Ym(S,I,1);for(A=0;A<x;){var O,R=P[nh(e,c,w)];if(c+=15&R,(O=R>>>4)<16)C[A++]=O;else{var M=0,D=0;for(16==O?(D=3+nh(e,c,3),c+=2,M=C[A-1]):17==O?(D=3+nh(e,c,7),c+=3):18==O&&(D=11+nh(e,c,127),c+=7);D--;)C[A++]=M}}var E=C.subarray(0,T),V=C.subarray(T);f=th(E),g=th(V),d=Ym(E,f,1),p=Ym(V,g,1)}else ih(1);if(c>m){a&&ih(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var _=(M=d[rh(e,c)&L])>>>4;if((c+=15&M)>m){a&&ih(0);break}if(M||ih(2),_<256)t[u++]=_;else{if(256==_){N=c,d=null;break}var F=_-254;if(_>264){var k=Fm[A=_-257];F=nh(e,c,(1<<k)-1)+Wm[A],c+=k}var G=p[rh(e,c)&B],U=G>>>4;if(G||ih(3),c+=15&G,V=Km[U],U>3&&(k=km[U],V+=rh(e,c)&(1<<k)-1,c+=k),c>m){a&&ih(0);break}o&&s(u+131072);for(var z=u+F;u<z;u+=4)t[u]=t[u-V],t[u+1]=t[u+1-V],t[u+2]=t[u+2-V],t[u+3]=t[u+3-V];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:oh(t,0,u)},lh=new Bm(0),ch=function(e,t){return e[t]|e[t+1]<<8},uh=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},dh=function(e,t){return uh(e,t)+4294967296*uh(e,t+4)};function ph(e,t){return sh(e,t)}function fh(e,t){return sh(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||ih(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Bm((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function gh(e,t){return sh(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&ih(6,"invalid zlib data"),32&n[1]&&ih(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function mh(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?fh(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?ph(e,t):gh(e,t)}var hh="undefined"!=typeof TextEncoder&&new TextEncoder,vh="undefined"!=typeof TextDecoder&&new TextDecoder;try{vh.decode(lh,{stream:!0})}catch(e){}function yh(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(vh)return vh.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,oh(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&ih(8),a}var Th=function(e,t){return t+30+ch(e,t+26)+ch(e,t+28)},bh=function(e,t,n){var r=ch(e,t+28),o=yh(e.subarray(t+46,t+46+r),!(2048&ch(e,t+8))),a=t+46+r,i=uh(e,t+20),s=n&&4294967295==i?xh(e,a):[i,uh(e,t+24),uh(e,t+42)],l=s[0],c=s[1],u=s[2];return[ch(e,t+10),l,c,o,a+ch(e,t+30)+ch(e,t+32),u]},xh=function(e,t){for(;1!=ch(e,t);t+=4+ch(e,t+2));return[dh(e,t+12),dh(e,t+4),dh(e,t+20)]};function Ch(e,t){for(var n={},r=e.length-22;101010256!=uh(e,r);--r)(!r||e.length-r>65558)&&ih(13);var o=ch(e,r+8);if(!o)return{};var a=uh(e,r+16),i=4294967295==a;i&&(r=uh(e,r-12),101075792!=uh(e,r)&&ih(13),o=uh(e,r+32),a=uh(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=bh(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Th(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=ph(e.subarray(h,h+d),new Bm(p)):ih(14,"unknown compression type "+u):n[f]=oh(e,h,h+d))}return n}function Sh(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Ah=Sh(),Ih=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:wh,vtkDebugMacro:Ph}=jt;let Oh=0;function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const Mh={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=Rh("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(Ph(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&wh(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=Rh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(yh(mh(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(wh("Supported algorithms are: [gz]"),wh(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=Rh("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Oh&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Oh&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(yh(mh(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(wh("Supported algorithms are: [gz]"),wh(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=Rh("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(mh(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Vm("http",(e=>Mh));const{vtkDebugMacro:Dh}=jt;function Eh(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function y(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,Dh("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,Dh("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,y()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,Oo(n),s),Gi(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,Oo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,Oo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),Vn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Go(t.position,a,t.position),Go(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Gi(o,[...t.position,1],n),Gi(a,[...t.focalPoint,1],n),Gi(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,Dh("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,Dh("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),P(i,[t.distance,t.distance,t.distance]),T(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Hi(e[0],e[1],e[2],e[3]),n=Ui(),r=Hi(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Wi(r,t,r),Wi(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Ko(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),In(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),Vn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),Vn(l,r,a),Pn(l,l,s),Mn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),Vn(c,o,a),Pn(c,c,s),Mn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),T(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return In(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(Oo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return T(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,y()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Ko(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,Oo(n),t.physicalViewUp),C(s,s,Oo(r),i),C(s,s,Oo(o),t.physicalViewNorth),C(s,s,Oo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);Vn(l,l,s),Vn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=Oo(t),i=Ui();zi(i,[n,r,o],e),k(a,i)}const i=new Float64Array(3);Vn(i,[0,0,-1],a);const s=new Float64Array(3);Vn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}const Vh={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Lh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vh,n),jt.obj(e,t),jt.get(e,t,["distance"]),jt.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),jt.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),jt.setGetArray(e,t,["clippingRange","windowCenter"],2),jt.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),Eh(e,t)}var Bh={newInstance:jt.newInstance(Lh,"vtkCamera"),extend:Lh};function Nh(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?Vn(n,t.position,t.transformMatrix):In(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?Vn(n,t.focalPoint,t.transformMatrix):In(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(_n(t.direction,t.focalPoint,t.position),qo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);_n(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=Oo(t),o=Oo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}const _h={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_h,n),jt.obj(e,t),jt.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),jt.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),Nh(e,t)}var kh={newInstance:jt.newInstance(Fh,"vtkLight"),extend:Fh,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Gh}=jt;function Uh(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{const e=[];for(let r=0;r<t.props.length;r++)n(t.props[r],e);return e},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Gh("call displayToView on your view instead"),e.viewToDisplay=()=>Gh("callviewtodisplay on your view instead"),e.getSize=()=>Gh("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=("PickPropFrom",()=>Gh("vtkViewport::PickPropFrom - NOT IMPLEMENTED"))}const zh={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),jt.obj(e,t),jt.event(e,t,"event"),jt.setGetArray(e,t,["viewport"],4),jt.setGetArray(e,t,["background","background2"],3),Uh(e,t)}var Hh={newInstance:jt.newInstance(Wh,"vtkViewport"),extend:Wh};const{vtkDebugMacro:jh,vtkErrorMacro:Kh,vtkWarningMacro:$h}=Kt;function qh(e){return()=>Kh(`vtkRenderer::${e} - NOT IMPLEMENTED`)}function Xh(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(jh("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Kh("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=qh("allocateTime"),e.updateGeometry=qh("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{jh(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=Bh.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=kh.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Kh("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Kh("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Kh("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return Vn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Kh("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return Vn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=ki.INIT_BOUNDS[0],t.allBounds[1]=ki.INIT_BOUNDS[1],t.allBounds[2]=ki.INIT_BOUNDS[2],t.allBounds[3]=ki.INIT_BOUNDS[3],t.allBounds[4]=ki.INIT_BOUNDS[4],t.allBounds[5]=ki.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&Ra(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Oa(t.allBounds),jh("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const r=n||e.computeVisiblePropBounds(),a=[0,0,0];if(!Ra(r))return jh("Cannot reset camera!"),!1;let i=null;if(!e.getActiveCamera())return Kh("Trying to reset non-existent camera"),!1;i=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),a[0]=(r[0]+r[1])/2,a[1]=(r[2]+r[3])/2,a[2]=(r[4]+r[5])/2;let s=r[1]-r[0],l=r[3]-r[2],c=r[5]-r[4];s*=s,l*=l,c*=c;let u=s+l+c;u=0===u?1:u,u=.5*Math.sqrt(u);const d=Oo(t.activeCamera.getViewAngle()),p=u,f=u/Math.sin(.5*d),g=t.activeCamera.getViewUp();return Math.abs(jo(g,i))>.999&&($h("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-g[2],g[0],g[1])),t.activeCamera.setFocalPoint(a[0],a[1],a[2]),t.activeCamera.setPosition(a[0]+f*i[0],a[1]+f*i[1],a[2]+f*i[2]),e.resetCameraClippingRange(r),t.activeCamera.setParallelScale(p),t.activeCamera.setPhysicalScale(u),t.activeCamera.setPhysicalTranslation(-a[0],-a[1],-a[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const o=n||e.computeVisiblePropBounds();if(!Ra(o))return jh("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Kh("Trying to reset clipping range of non-existent camera"),!1;const a=t.activeCamera.computeClippingRange(o);let i=0;if(t.activeCamera.getParallelProjection())i=.2*t.activeCamera.getParallelScale();else{const e=Oo(t.activeCamera.getViewAngle());i=.2*Math.tan(e/2)*a[1]}return a[1]-a[0]<i&&(i=i-a[1]+a[0],a[1]+=i/2,a[0]-=i/2),a[0]<0&&(a[0]=0),a[0]=.99*a[0]-(a[1]-a[0])*t.clippingRangeExpansion,a[1]=1.01*a[1]+(a[1]-a[0])*t.clippingRangeExpansion,a[0]=a[0]>=a[1]?.01*a[1]:a[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),a[0]<t.nearClippingPlaneTolerance*a[1]&&(a[0]=t.nearClippingPlaneTolerance*a[1]),t.activeCamera.setClippingRange(a[0],a[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}const Yh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Fa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Yh,n),Hh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),bt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),At(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),It(e,t,["actors","volumes","lights"]),Pt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),Xh(e,t)}var Qh={newInstance:Et(Zh,"vtkRenderer"),extend:Zh};const Jh=Object.create(null);function ev(e,t){Jh[e]=t}function tv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Jh[e]&&Jh[e](t)}function nv(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return tv(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return jt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))}}const rv={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1};function ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rv,n),jt.obj(e,t),jt.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),jt.get(e,t,["neverRendered"]),jt.getArray(e,t,["renderers"]),jt.moveToProtected(e,t,["views"]),jt.event(e,t,"completion"),nv(e,t)}var av={newInstance:jt.newInstance(ov,"vtkRenderWindow"),extend:ov,registerViewConstructor:ev,listViewAPIs:function(){return Object.keys(Jh)},newAPISpecificView:tv};const iv={Unknown:0,LeftController:1,RightController:2},sv={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var lv={Device:iv,Input:sv,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4}};const{Device:cv,Input:uv}=lv,{vtkWarningMacro:dv,vtkErrorMacro:pv,normalizeWheel:fv,vtkOnceErrorMacro:gv}=jt,mv={ctrlKey:!1,altKey:!1,shiftKey:!1},hv={"xr-standard":[uv.Trigger,uv.Grip,uv.TrackPad,uv.Thumbstick,uv.A,uv.B]},vv=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function yv(e){e.cancelable&&e.preventDefault()}function Tv(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}function bv(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{pv("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>dv("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",yv),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),document.addEventListener("keypress",e.handleKeyPress),document.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",yv),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel)),document.removeEventListener("keypress",e.handleKeyPress),document.removeEventListener("keydown",e.handleKeyDown),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&yv(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&dv("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&yv(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:pv(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?dv("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):pv("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;dv(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=n.gamepad,s=n.handedness;if(i){i.index in t.lastGamepadValues||(t.lastGamepadValues[i.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<i.buttons.length;++r)r in t.lastGamepadValues[i.index][s].buttons||(t.lastGamepadValues[i.index][s].buttons[r]=!1),t.lastGamepadValues[i.index][s].buttons[r]!==i.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,pressed:i.buttons[r].pressed,device:"left"===n.handedness?cv.LeftController:cv.RightController,input:hv[i.mapping]&&hv[i.mapping][r]?hv[i.mapping][r]:uv.Trigger}),t.lastGamepadValues[i.index][s].buttons[r]=i.buttons[r].pressed),t.lastGamepadValues[i.index][s].buttons[r]&&null!=a&&e.move3DEvent({gamepad:i,position:a.transform.position,orientation:a.transform.orientation,device:"left"===n.handedness?cv.LeftController:cv.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{yv(n);const r={...fv(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:pv(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Tv(o);if(2===r.length){const t={...l(mv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(mv),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Tv(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(mv),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(mv),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Tv(o);e.recognizeGesture("TouchEnd",t);const a={...l(mv),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Tv(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(mv),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},vv.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void gv("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=Ro(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=Ro(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}const xv={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Cv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xv,n),jt.obj(e,t),t._animationExtendedEnd=0,jt.event(e,t,"RenderEvent"),vv.forEach((n=>jt.event(e,t,n))),jt.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),jt.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),jt.moveToProtected(e,t,["view"]),bv(e,t)}var Sv={newInstance:jt.newInstance(Cv,"vtkRenderWindowInteractor"),extend:Cv,handledEvents:vv,...lv};const{vtkErrorMacro:Av,VOID:Iv}=jt;function wv(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Sv.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Iv),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Av("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}const Pv={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Ov(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pv,n),jt.obj(e,t),jt.event(e,t,"InteractionEvent"),jt.event(e,t,"StartInteractionEvent"),jt.event(e,t,"EndInteractionEvent"),jt.get(e,t,["_interactor","enabled"]),jt.setGet(e,t,["priority","processEvents"]),jt.moveToProtected(e,t,["interactor"]),wv(e,t)}var Rv={newInstance:jt.newInstance(Ov,"vtkInteractorObserver"),extend:Ov,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},Mv={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Dv}=Mv,Ev={Rotate:Dv.IS_ROTATE,Pan:Dv.IS_PAN,Spin:Dv.IS_SPIN,Dolly:Dv.IS_DOLLY,CameraPose:Dv.IS_CAMERA_POSE,WindowLevel:Dv.IS_WINDOW_LEVEL,Slice:Dv.IS_SLICE};function Vv(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(Ev).forEach((n=>{jt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Dv.IS_NONE&&(t.state=Ev[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},jt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Ev[n]&&(t.state=Dv.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":e.pokedRenderer.resetCamera(),n.render();break;case"w":case"W":r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=e.pokedRenderer.getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}const Lv={state:Dv.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lv,n),Rv.extend(e,t,n),Vv(e,t)}var Nv={newInstance:jt.newInstance(Bv,"vtkInteractorStyle"),extend:Bv,...Mv};const{States:_v}=Mv;function Fv(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=n.pokedRenderer;switch(t.state){case _v.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case _v.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case _v.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case _v.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad?!n||n.pressed||n.device!==iv.RightController||n.input!==sv.Trigger&&n.input!==sv.TrackPad||t.state!==_v.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===_v.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const t=e.pokedRenderer.getActiveCamera(),n=t.getPhysicalTranslation(),r=.025*t.getPhysicalScale(),o=t.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);t.setPhysicalTranslation(n[0]+o[0]*r,n[1]+o[1]*r,n[2]+o[2]*r)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case _v.IS_DOLLY:e.endDolly();break;case _v.IS_PAN:e.endPan();break;case _v.IS_SPIN:e.endSpin();break;case _v.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(n.pokedRenderer,n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=n.pokedRenderer.getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(n.pokedRenderer,o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(n.pokedRenderer,o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(n.pokedRenderer,o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&n.pokedRenderer.updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=e.pokedRenderer.getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=Ro(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=Ro(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(n.pokedRenderer,r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}const kv={motionFactor:10,zoomFactor:10};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Nv.extend(e,t,n),jt.setGet(e,t,["motionFactor","zoomFactor"]),Fv(e,t)}var Uv={newInstance:jt.newInstance(Gv,"vtkInteractorStyleTrackballCamera"),extend:Gv};function zv(e){return e}function Wv(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>Wv(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Hv=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Wv:zv,o=(t||"").replace(/#.*/,"").replace("?","").split("&");return o.forEach((e=>{const[t,o]=e.split("=").map((e=>decodeURIComponent(e)));t&&(n[t]=!o||r(o))})),n};function jv(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${jt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}const Kv={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),jt.obj(e,t),jt.get(e,t,["currentOperation"]),jt.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),jt.moveToProtected(e,t,["currentParent"]),jv(e,t)}var qv={newInstance:jt.newInstance($v,"vtkRenderPass"),extend:$v};const{Representation:Xv}=ds,{vtkErrorMacro:Yv}=jt;function Zv(e){const t=cd.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}function Qv(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Es.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Es.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Es.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",Xv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Hp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Nd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw(n[0],n[1],4,"Float32Array",null),t.translucentRTexture=Nd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw(n[0],n[1],1,"Float32Array",null),t.translucentZTexture=Nd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw(n[0],n[1],"Float32Array",null),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||Yv("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||Yv("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=fd.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate()},e.getShaderReplacement=()=>t._supported?Zv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}const Jv={framebuffer:null,copyShader:null,tris:null};function ey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jv,n),qv.extend(e,t,n),t.VBOBuildTime={},jt.obj(t.VBOBuildTime,{mtime:0}),t.tris=yd.newInstance(),jt.get(e,t,["framebuffer"]),Qv(e,t)}var ty={newInstance:jt.newInstance(ey,"vtkOpenGLOrderIndependentTranslucentPass"),extend:ey};function ny(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];if(s.getDraw()&&s.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),i.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Hp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),i.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),i.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=ty.newInstance()),t.translucentPass.traverse(n,i,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),i.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),i.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}const ry={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function oy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ry,n),qv.extend(e,t,n),jt.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),ny(e,t)}var ay={newInstance:jt.newInstance(oy,"vtkForwardPass"),extend:oy},iy=n(594),sy=n.n(iy);const ly=["lastShaderProgramBound","context","_openGLRenderWindow"];function cy(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=cd.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=cd.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=cd.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=cd.substitute(l,"varying","out").result,o=cd.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=cd.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=cd.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:cd.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=sy().hash(o);if(!(a in t.shaderPrograms)){const o=cd.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}const uy={lastShaderProgramBound:null,shaderPrograms:null,context:null};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),t.shaderPrograms={},jt.obj(e,t),jt.setGet(e,t,ly),jt.moveToProtected(e,t,["openGLRenderWindow"]),cy(e,t)}var py={newInstance:jt.newInstance(dy,"vtkShaderCache"),extend:dy};const{vtkErrorMacro:fy}=jt;function gy(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&fy("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}const my={context:null,numberOfTextureUnits:0,textureUnits:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),jt.obj(e,t),t.textureUnits=[],jt.get(e,t,["numberOfTextureUnits"]),jt.setGet(e,t,["context"]),gy(e,t)}var vy={newInstance:jt.newInstance(hy,"vtkOpenGLTextureUnitManager"),extend:hy};function yy(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{jt.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{jt.vtkErrorMacro("not implemented")},e.createSelector=()=>{jt.vtkErrorMacro("not implemented")}}const Ty={size:void 0,selector:void 0};function by(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ty,n),t.size||(t.size=[300,300]),jt.getArray(e,t,["size"],2),jt.get(e,t,["selector"]),Zt.extend(e,t,n),yy(e,t)}var xy={newInstance:jt.newInstance(by,"vtkRenderWindowViewNode"),extend:by};const{vtkDebugMacro:Cy,vtkErrorMacro:Sy}=jt,Ay={position:"absolute",top:0,left:0,width:"100%",height:"100%"};function Iy(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let wy=0;const Py=[];function Oy(){wy++,Py.forEach((e=>e(wy)))}function Ry(){wy--,Py.forEach((e=>e(wy)))}function My(e){e.preventDefault()}function Dy(e,t){t.classHierarchy.push("vtkOpenGLRenderWindow");const n=function(){const e=new Map,t={apply:(t,n,r)=>e.has(r[0])?e.get(r[0]):t.apply(n,r)},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply:(t,n,r)=>(e.set(a,r[0]),t.apply(n,r))}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}();e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",My,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow(e)}))}},e.initialize=()=>{if(!t.initialized){t.context=e.get3DContext(),t.textureUnitManager=vy.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND),t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sy("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.activeFramebuffer?t.activeFramebuffer.getSize():t.size,e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},r=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext("webgl2",e),r&&(t.webgl2=!0,Cy("using webgl2"))),r||(Cy("using webgl1"),r=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(r,n)},e.restoreContext=()=>{const t=qv.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sy("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case ys.CHAR:case ys.SIGNED_CHAR:case ys.UNSIGNED_CHAR:return 1;case n:case r:case ys.UNSIGNED_SHORT:case ys.SHORT:case ys.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case ys.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&ys.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&ys.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Ay,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Iy(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Iy(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Iy(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Iy(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Iy(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Iy(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Iy(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Iy(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Iy(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Iy(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Iy(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Iy(n,n.RGB,n.FLOAT)?"RGB":"",r&&Iy(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Iy(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Iy(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect(),i=t.renderable;i.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const s=r.toDataURL(n);r.remove(),e.invokeImageReady(s)}()},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=df.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=jt.chain((function(){t.canvas.removeEventListener("webglcontextlost",My),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete,e.setViewStream,Ry),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.getGraphicsResourceForObject=e=>e?{vtkObj:t._graphicsResources.get(e),hash:t._graphicsResourceHash.get(e)}:null,e.setGraphicsResourceForObject=(e,n,r)=>{e&&(t._graphicsResources.set(e,n),t._graphicsResourceHash.set(e,r))},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach(((t,n)=>{e+=t.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResourcesForObject=n=>!!n&&(t._graphicsResources.get(n)?.releaseGraphicsResources(e),t._graphicsResources.delete(n)&&t._graphicsResourceHash.delete(n)),e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach(((t,n)=>{t.releaseGraphicsResources(e)})),t._graphicsResources.clear(),t._graphicsResourceHash.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{e.getViewNodeFor(t)?.releaseGraphicsResources()}))}}const Ey={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const Vy=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ey,n),xy.extend(e,t,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",Oy(),t.selector||(t.selector=df.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._graphicsResourceHash=new Map,t._glInformation=null,t.myFactory=ln.newInstance(),t.myFactory.registerOverride("vtkRenderWindow",Vy),t.shaderCache=py.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=ay.newInstance(),jt.event(e,t,"imageReady"),jt.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer"]),jt.setGet(e,t,["initialized","context","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"windowResizeEvent"),Dy(e,t)}),"vtkOpenGLRenderWindow");function Ly(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}ev("WebGL",Vy);const By={device:null,handle:null};function Ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,By,n),jt.obj(e,t),jt.get(e,t,["lastCameraMTime"]),jt.setGet(e,t,["device","handle"]),Ly(e,t)}var _y={newInstance:jt.newInstance(Ny,"vtkWebGPUShaderModule"),extend:Ny};function Fy(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=_y.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}const ky={shaderModules:null,device:null,window:null};function Gy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ky,n),t._shaderModules=new Map,jt.obj(e,t),jt.setGet(e,t,["device","window"]),Fy(e,t)}var Uy={newInstance:jt.newInstance(Gy,"vtkWebGPUShaderCache"),extend:Gy,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i),l=e.replace(s,o);return{replace:a,result:l}}};function zy(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}const Wy={device:null,handle:null,label:null};function Hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wy,n),jt.obj(e,t),t.bindables=[],t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),jt.setGet(e,t,["label","device","arrayInformation"]),zy(e,t)}var jy={newInstance:jt.newInstance(Hy),extend:Hy};function Ky(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}const $y={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$y,n),yt(e,t),t.layouts=[],t.shaderDescriptions=[],bt(e,t,["handle","pipelineDescription"]),At(e,t,["device","renderEncoder","topology","vertexState"]),Ky(e,t)}var Xy={newInstance:Et(qy,"vtkWebGPUPipeline"),extend:qy};function Yy(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=Uy.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=Uy.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=Uy.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}const Zy={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Qy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zy,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],jt.obj(e,t),jt.setGet(e,t,["type","hash","code"]),jt.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),Yy(e,t)}var Jy={newInstance:jt.newInstance(Qy,"vtkWebGPUShaderDescription"),extend:Qy};const eT={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var tT=function(e){return!e||e.length<6?0:e in eT==1?eT[e]:(et(`unknown format ${e}`),null)},nT=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},rT=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void et(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;et(`unknown format ${e}`)},oT=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void et(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},aT=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},iT=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void et(`unknown format ${e}`)};function sT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}function lT(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(sT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=oT(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}const cT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function uT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cT,n),yt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],At(e,t,["created","device","handle","indexBuffer"]),lT(e,t)}var dT={newInstance:Et(uT,"vtkWebGPUVertexInput"),extend:uT};const pT="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",fT="\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function gT(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=Jy.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=Jy.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Uy.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=Uy.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=Uy.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=Uy.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Uy.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Xy.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}const mT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Zt.extend(e,t,n),t.textureViews=[],t.vertexInput=dT.newInstance(),t.bindGroup=jy.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||fT,t.vertexShaderTemplate=t.vertexShaderTemplate||pT,t.shaderReplacements=new Map,jt.get(e,t,["pipeline","vertexInput"]),jt.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),gT(e,t)}var vT={newInstance:jt.newInstance(hT,"vtkWebGPUSimpleMapper"),extend:hT};function yT(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=Uy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}const TT={};function bT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),vT.extend(e,t,n),yT(e,t)}var xT={newInstance:jt.newInstance(bT,"vtkWebGPUFullScreenQuad"),extend:bT};const CT=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"];function ST(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<CT.length;n++)e[CT[n]]=function(){return t.handle[CT[n]](...arguments)}}const AT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),yt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Uy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],bt(e,t,["boundPipeline","colorTextureViews"]),At(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),ST(e,t)}var wT={newInstance:Et(IT,"vtkWebGPURenderEncoder"),extend:IT},PT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const OT=["getMappedRange","mapAsync","unmap"];function RT(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e.byteLength,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=e.byteLength,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<OT.length;n++)e[OT[n]]=function(){return t.handle[OT[n]](...arguments)}}const MT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),jt.obj(e,t),jt.get(e,t,["handle","sizeInBytes","usage"]),jt.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),RT(e,t)}var ET={newInstance:jt.newInstance(DT),extend:DT,...PT};const{Representation:VT}=ds,{PrimitiveTypes:LT}=PT;class BT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function NT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function _T(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=NT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=NT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=NT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=NT(n,o,t),n.ibo[n.iboId++]=a}function FT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let kT;const GT=new Uint32Array(1),UT=new Uint32Array(2),zT=new Uint32Array(3),WT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)GT[0]=t[n+a],kT(GT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)UT[0]=t[n+a],UT[1]=t[n+(a+1)%e],kT(UT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)UT[0]=t[n+a],UT[1]=t[n+a+1],kT(UT,r,o);for(let a=0;a<e-2;a++)UT[0]=t[n+a],UT[1]=t[n+a+2],kT(UT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n],zT[1]=t[n+a+1],zT[2]=t[n+a+2],kT(zT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)zT[0]=t[n+a],zT[1]=t[n+a+1+a%2],zT[2]=t[n+a+1+(a+1)%2],kT(zT,r,o)}};function HT(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case LT.Points:return"points";case LT.Lines:return"lines";case LT.Triangles:case LT.TriangleEdges:return"polys";case LT.TriangleStripEdges:case LT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new BT};let d=null;d=o===VT.POINTS||r===LT.Points?WT.anythingToPoints:o===VT.WIREFRAME||r===LT.Lines?WT[`${l}ToWireframe`]:WT[`${l}ToSurface`],kT=FT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),kT=_T,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}const jT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function KT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jT,n),ET.extend(e,t,n),jt.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),HT(e,t)}var $T={newInstance:jt.newInstance(KT),extend:KT,...PT};const{BufferUsage:qT}=PT,{vtkErrorMacro:XT}=Kt,{VtkDataTypes:YT}=Es;function ZT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function QT(e,t,n,r){const o=[];return Ko([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),qo(o),o}function JT(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===qT.Index&&(n=$T.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=ET.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===qT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===qT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===qT.PointArray){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=ZT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===qT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=rT(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=QT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ZT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===qT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(nT(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case YT.UNSIGNED_CHAR:t="uint8";break;case YT.FLOAT:t="float32";break;case YT.UNSIGNED_INT:t="uint32";break;case YT.INT:t="sint32";break;case YT.DOUBLE:t="float32";break;case YT.UNSIGNED_SHORT:t="uint16";break;case YT.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||XT(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:qT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=ET.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}const eb={device:null,fullScreenQuadBuffer:null};function tb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eb,n),yt(e,t),At(e,t,["device"]),JT(e,t)}var nb={newInstance:Et(tb),extend:tb,...PT};function rb(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}const ob={device:null,handle:null,label:null,options:null};function ab(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ob,n),jt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","handle","options"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label"]),rb(e,t)}var ib={newInstance:jt.newInstance(ab),extend:ab};function sb(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=tT(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=ib.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}const lb={texture:null,handle:null,sampler:null,label:null};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),jt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),jt.get(e,t,["bindGroupTime","texture"]),jt.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),sb(e,t)}var ub={newInstance:jt.newInstance(cb),extend:cb};const{BufferUsage:db}=nb;function pb(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];if(n.canvas)return t.device.getHandle().queue.copyExternalImageToTexture({source:n.canvas,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0},[t.width,t.height,t.depth]),void(t.ready=!0);n.jsImageData&&!n.nativeArray&&(n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,n.nativeArray=n.jsImageData.data);const o=tT(t.format);let a=t.width*o.stride;const i=(e,t,n)=>{const r=e.length/(t*n)*e.BYTES_PER_ELEMENT,a=2===o.elementSize&&"float"===o.sampleType;if(a||r%256){const i=e,s=r/i.BYTES_PER_ELEMENT,l=o.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=jt.newTypedArray(a?"Uint16Array":i.constructor.name,u*t*n);for(let e=0;e<t*n;e++)if(a)for(let t=0;t<s;t++)d[e*u+t]=Ad.toHalf(i[e*s+t]);else d.set(i.subarray(e*s,(e+1)*s),e*u);return[d,c]}return[e,r]};if(n.nativeArray&&(r=n.nativeArray),n.image){const e=document.createElement("canvas");e.width=n.image.width,e.height=n.image.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n.image,0,0,n.image.width,n.image.height,0,0,e.width,e.height),r=t.getImageData(0,0,n.image.width,n.image.height).data}const s=t.device.createCommandEncoder();if(3!==e.getDimensionality()){const e=Tu.generateMipmaps(r,t.width,t.height,t.mipLevel);let o=t.width,l=t.height;for(let r=0;r<=t.mipLevel;r++){const c=i(e[r],l,1);a=c[1];const u={dataArray:n.dataArray?n.dataArray:null,nativeArray:c[0],usage:db.Texture},d=t.device.getBufferManager().getBuffer(u);s.copyBufferToTexture({buffer:d.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:l},{texture:t.handle,mipLevel:r},[o,l,1]),o/=2,l/=2}t.device.submitCommandEncoder(s),t.ready=!0}else{const e=i(r,t.height,t.depth);a=e[1];const o={dataArray:n.dataArray?n.dataArray:null,usage:db.Texture};o.nativeArray=e[0];const l=t.device.getBufferManager().getBuffer(o);s.copyBufferToTexture({buffer:l.getHandle(),offset:0,bytesPerRow:a,rowsPerImage:t.height},{texture:t.handle},[t.width,t.height,t.depth]),t.device.submitCommandEncoder(s),t.ready=!0}},e.getScale=()=>{const e=tT(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>tT(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=ub.newInstance({label:n});return o.create(e,r),o}}const fb={device:null,handle:null,buffer:null,ready:!1,label:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),jt.obj(e,t),jt.get(e,t,["handle","ready","width","height","depth","format","usage"]),jt.setGet(e,t,["device","label"]),pb(e,t)}var mb={newInstance:jt.newInstance(gb),extend:gb};function hb(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=mb.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=wT.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}const vb={renderEncoder:null,colorTexture:null,depthTexture:null};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vb,n),qv.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),hb(e,t)}var Tb={newInstance:jt.newInstance(yb,"vtkWebGPUOpaquePass"),extend:yb};function bb(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=mb.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=mb.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=xT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=wT.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Uy.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcfactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=wT.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=Uy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}const xb={colorTextureView:null,depthTextureView:null};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),qv.extend(e,t,n),jt.setGet(e,t,["colorTextureView","depthTextureView"]),bb(e,t)}var Sb={newInstance:jt.newInstance(Cb,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Cb};const{BufferUsage:Ab}=nb,{vtkErrorMacro:Ib}=jt;function wb(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?Ib(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:aT(n),offset:-1,nativeType:iT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:Ab.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void Ib(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}const Pb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function Ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},jt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,jt.get(e,t,["binding","bindGroupTime"]),jt.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),wb(e,t)}var Rb={newInstance:jt.newInstance(Ob,"vtkWebGPUUniformBuffer"),extend:Ob};const{BufferUsage:Mb}=nb,{vtkErrorMacro:Db}=jt;function Eb(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void Db(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=aT(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:iT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:Mb.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=jt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void Db(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void Db(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}const Vb={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function Lb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),jt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},jt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},jt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},jt.get(e,t,["bindGroupTime"]),jt.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),Eb(e,t)}var Bb={newInstance:jt.newInstance(Lb,"vtkWebGPUStorageBuffer"),extend:Lb};const Nb="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",_b=new Float64Array(16),Fb=new Float64Array(16);function kb(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=Uy.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Rg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=Uy.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=Uy.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=Uy.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Rg.COMPOSITE_BLEND?l=!0:n===Rg.MAXIMUM_INTENSITY_BLEND?a=Uy.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Rg.MINIMUM_INTENSITY_BLEND?a=Uy.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Rg.AVERAGE_INTENSITY_BLEND?a=Uy.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Rg.ADDITIVE_INTENSITY_BLEND&&(a=Uy.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=Uy.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),d=r.getInputData();g(_b),b(_b,_b,o);const p=n.getMatrix();m(Fb,p),h(Fb,Fb),T(_b,Fb,_b);const f=d.getWorldToIndex();T(_b,f,_b);const v=d.getDimensions();g(Fb),x(Fb,Fb,[1/v[0],1/v[1],1/v[2]]),T(_b,Fb,_b);for(let t=0;t<16;t++)a[16*e+t]=_b[t];h(_b,_b);for(let t=0;t<4;t++)i[16*e+4*t]=_b[4*t],i[16*e+4*t+1]=_b[4*t+1],i[16*e+4*t+2]=_b[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/v[0],s[4*e+1]=1/v[1],s[4*e+2]=1/v[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const y=d.getSpacing();c[4*e]=y[0],c[4*e+1]=y[1],c[4*e+2]=y[2],c[4*e+3]=1;const C=t.textureViews[e+4].getTexture().getScale(),S=r.getIpScalarRange();u[4*e]=S[0]/C,u[4*e+1]=S[1]/C,u[4*e+2]=r.getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),y=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=tT(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);y[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else y[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",y),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=ib.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}const Gb={volumes:null,rowLength:1024,lastVolumeLength:0};function Ub(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),xT.extend(e,t,n),t.fragmentShaderTemplate=Nb,t.UBO=Rb.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=Bb.newInstance({label:"volumeSSBO"}),t.componentSSBO=Bb.newInstance({label:"componentSSBO"}),t.lutBuildTime={},jt.obj(t.lutBuildTime,{mtime:0}),kb(e,t)}var zb={newInstance:jt.newInstance(Ub,"vtkWebGPUVolumePassFSQ"),extend:Ub};const{Representation:Wb}=ds,{BufferUsage:Hb,PrimitiveTypes:jb}=nb,Kb=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$b="\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";function qb(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zb.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=xT.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=Rb.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Yo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=jt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:Hb.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jb.Triangles,representation:Wb.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:Hb.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+Kb[e][0],l[n++]=r+Kb[e][1],l[n++]=r+Kb[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=wT.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=Uy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcfactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcfactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=mb.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=mb.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=mb.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=wT.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=wT.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=wT.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=Uy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}const Xb={colorTextureView:null,depthTextureView:null,volumes:null};function Yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xb,n),qv.extend(e,t,n),t._mapper=vT.newInstance(),t._mapper.setFragmentShaderTemplate($b),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],jt.setGet(e,t,["colorTextureView","depthTextureView"]),qb(e,t)}var Zb={newInstance:jt.newInstance(Yb,"vtkWebGPUVolumePass"),extend:Yb};function Qb(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Tb.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Sb.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Zb.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=wT.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcfactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=ib.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=xT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=ub.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}const Jb={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jb,n),qv.extend(e,t,n),jt.setGet(e,t,["opaquePass","translucentPass","volumePass"]),Qb(e,t)}var tx={newInstance:jt.newInstance(ex,"vtkForwardPass"),extend:ex};const{VtkDataTypes:nx}=Es;function rx(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case nx.UNSIGNED_CHAR:e.format+="8unorm";break;case nx.FLOAT:case nx.UNSIGNED_INT:case nx.INT:case nx.DOUBLE:case nx.UNSIGNED_SHORT:case nx.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm"),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=mb.newInstance();return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=e=>{const r={time:e.getMTime()};return e.getInputData()?r.imageData=e.getInputData():e.getImage()?r.image=e.getImage():e.getJsImageData()?r.jsImageData=e.getJsImageData():e.getCanvas()&&(r.canvas=e.getCanvas()),n(r),r.mipLevel=e.getMipLevel(),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)}}const ox={handle:null,device:null};function ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ox,n),jt.obj(e,t),jt.setGet(e,t,["device"]),rx(e,t)}var ix={newInstance:jt.newInstance(ax),extend:ax};class sx extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}function lx(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}const cx={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),yt(e,t),At(e,t,["handle"]),bt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new sx,t.shaderCache=Uy.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=nb.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ix.newInstance(),t.textureManager.setDevice(e),t.pipelines={},lx(e,t)}var dx={newInstance:Et(ux,"vtkWebGPUDevice"),extend:ux};function px(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=mb.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=mb.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=wT.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=Uy.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}const fx={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function gx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fx,n),qv.extend(e,t,n),jt.get(e,t,["colorTexture","depthTexture"]),px(e,t)}var mx={newInstance:jt.newInstance(gx,"vtkWebGPUHardwareSelectionPass"),extend:gx};const{SelectionContent:hx,SelectionField:vx}=qp,{FieldAssociations:yx}=ol,{vtkErrorMacro:Tx}=jt;function bx(e){return`${e.propID} ${e.compositeID}`}function xx(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function Cx(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=xx(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=xx(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=Cx(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Cx(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=Cx(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Cx(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=Cx(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}function Sx(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return Tx("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=ET.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=ET.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Cx(e,[n,t],0,u);if(r){const t=bx(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=qp.newInstance();switch(i.setContentType(hx.INDICES),e){case yx.FIELD_ASSOCIATION_CELLS:i.setFieldType(vx.CELL);break;case yx.FIELD_ASSOCIATION_POINTS:i.setFieldType(vx.POINT);break;default:Tx("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}const Ax={};function Ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ax,n),Gp.extend(e,t,n),t._selectionPass=mx.newInstance(),jt.setGet(e,t,["_WebGPURenderWindow"]),jt.moveToProtected(e,t,["WebGPURenderWindow"]),Sx(e,t)}var wx={newInstance:jt.newInstance(Ix,"vtkWebGPUHardwareSelector"),extend:Ix};const Px=Object.create(null);function Ox(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}const Rx={};function Mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rx,n),t.overrides=Px,tn.extend(e,t,n),Ox(0,t)}var Dx={newInstance:jt.newInstance(Mx,"vtkWebGPUViewNodeFactory"),extend:Mx};const{vtkErrorMacro:Ex}=jt,Vx={position:"absolute",top:0,left:0,width:"100%",height:"100%"};function Lx(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ex("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ex("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=dx.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=qv.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Vx,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect(),l=t.renderable;l.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const c=r.toDataURL(n);r.remove(),e.invokeImageReady(c)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=ET.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Ad.fromHalf(r.colorValues[o]),s[n+1]=255*Ad.fromHalf(r.colorValues[o+1]),s[n+2]=255*Ad.fromHalf(r.colorValues[o+2]),s[n+3]=255*Ad.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=wx.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=jt.chain(e.delete,e.setViewStream)}const Bx={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Nx=jt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bx,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",xy.extend(e,t,n),t.myFactory=Dx.newInstance(),t.myFactory.registerOverride("vtkRenderWindow",Nx),t.renderPasses[0]=tx.newInstance(),t.selector||(t.selector=wx.newInstance(),t.selector.setWebGPURenderWindow(e)),jt.event(e,t,"imageReady"),jt.event(e,t,"initialized"),jt.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),jt.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),jt.setGetArray(e,t,["size"],2),jt.event(e,t,"windowResizeEvent"),Lx(e,t)}),"vtkWebGPURenderWindow");ev("WebGPU",Nx);const _x=Hv(),Fx={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},kx={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Gx(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}function Ux(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Gx(t.container,t.containerStyle||Fx),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=av.newInstance(),t.renderer=Qh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(_x.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Sv.newInstance(),t.interactor.setInteractorStyle(Uv.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Gx(t.controlContainer,t.controlPanelStyle||kx),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",(t=>{"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}))},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=jt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}const zx={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Wx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zx,n),jt.obj(e,t),jt.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),Ux(e,t)}var Hx={newInstance:jt.newInstance(Wx),extend:Wx},jx={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Kx,Scale:$x}=jx,{ScalarMappingTarget:qx}=Pl,{vtkDebugMacro:Xx,vtkErrorMacro:Yx,vtkWarningMacro:Zx}=jt;function Qx(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Jx(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function eC(e,t,n,r){const o=[],a=[];wa(t,o),wa(n,a);const i=[],s=[];Qx(o,i),Qx(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Jx(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Jx(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Pa(u,r)}function tC(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Yx("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return Yx("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[],l=[n,r,o];return xa(l,s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];xa([n,r,o],u),xa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.getTable=(n,r,o,a)=>{const i=Number(n),s=Number(r);if(_a(i)||_a(s)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let l=0;const c=t.nodes.length;let u=0,d=0,p=0;0!==c&&(u=t.nodes[c-1].r,d=t.nodes[c-1].g,p=t.nodes[c-1].b);let f=0,g=0,m=0;const h=[0,0,0],v=[0,0,0];let y=0,T=0;const b=[];let x=t.scale===$x.LOG10;x&&(x=t.mappingRange[0]>0);let C=0,S=0,A=0;x&&(C=Math.log10(i),S=Math.log10(s));for(let n=0;n<o;n++){const r=3*n;if(o>1?x?(A=C+n/(o-1)*(S-C),f=10**A):f=i+n/(o-1)*(s-i):x?(A=.5*(C+S),f=10**A):f=.5*(i+s),t.discretize){const e=t.mappingRange;if(f>=e[0]&&f<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)f=e[0]+r/2;else{const t=(f-e[0])/r,o=Do(n*t);f=e[0]+o/(n-1)*r}}}for(;l<c&&f>t.nodes[l].x;)l++,l<c&&(g=t.nodes[l-1].x,m=t.nodes[l].x,x&&(g=Math.log10(g),m=Math.log10(m)),h[0]=t.nodes[l-1].r,v[0]=t.nodes[l].r,h[1]=t.nodes[l-1].g,v[1]=t.nodes[l].g,h[2]=t.nodes[l-1].b,v[2]=t.nodes[l].b,y=t.nodes[l-1].midpoint,T=t.nodes[l-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(f>t.mappingRange[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=u,a[r+1]=d,a[r+2]=p));else if(f<t.mappingRange[0]||La(f)&&f<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):c>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===l&&(Math.abs(f-i)<1e-6||t.discretize))c>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=x?(A-g)/(m-g):(f-g)/(m-g),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),T>.99){if(e<.5){a[r]=h[0],a[r+1]=h[1],a[r+2]=h[2];continue}a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}if(T<.01){if(t.colorSpace===Kx.RGB)a[r]=(1-e)*h[0]+e*v[0],a[r+1]=(1-e)*h[1]+e*v[1],a[r+2]=(1-e)*h[2]+e*v[2];else if(t.colorSpace===Kx.HSV){const n=[],o=[];ba(h,n),ba(v,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],xa(i,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const t=[],n=[];wa(h,t),wa(v,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Pa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*T):e>.5&&(e=1-.5*(2*(1-e))**(1+10*T));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Kx.RGB)for(let e=0;e<3;e++)u=v[e]-h[e],d=(1-T)*u,a[r+e]=i*h[e]+s*v[e]+l*d+c*d;else if(t.colorSpace===Kx.HSV){const e=[],n=[];ba(h,e),ba(v,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-T)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);xa(o,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else if(t.colorSpace===Kx.LAB){const e=[],t=[];wa(h,e),wa(v,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-T)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Pa(n,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]}else t.colorSpace===Kx.DIVERGING?(eC(e,h,v,b),a[r]=b[0],a[r+1]=b[1],a[r+2]=b[2]):Yx("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Yx("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Yx("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Yx("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>t.indexedLookup&&e.getSize()?e.getSize():t.tableSize?t.tableSize:16777216,e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=e.getRange();if(a[1]===o[1]&&a[0]===o[0])return;if(o[1]===o[0])return void Yx("attempt to set zero width color range");const i=(o[1]-o[0])/(a[1]-a[0]),s=o[0]-a[0]*i;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*i+s;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):Xx("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void Zx("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===qx.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===qx.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===qx.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===qx.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Kx[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Yx(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Kx.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}const nC={clamping:!0,colorSpace:Kx.RGB,hSVWrap:!0,scale:$x.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function rC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nC,n),Pl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},jt.obj(t.buildTime),jt.get(e,t,["buildTime","mappingRange"]),jt.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","colorSpace","discretize","numberOfValues"]),jt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),jt.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),tC(e,t)}var oC={newInstance:jt.newInstance(rC,"vtkColorTransferFunction"),extend:rC,...jx},aC={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:iC,ScaleModes:sC}=aC,{vtkErrorMacro:lC}=jt;function cC(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>jt.enumToString(iC,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(iC.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(iC.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(iC.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>jt.enumToString(sC,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(sC.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(sC.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(sC.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Fa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===sC.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(lC("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];ki.getCorners(l,c),t.bounds[0]=ki.INIT_BOUNDS[0],t.bounds[1]=ki.INIT_BOUNDS[1],t.bounds[2]=ki.INIT_BOUNDS[2],t.bounds[3]=ki.INIT_BOUNDS[3],t.bounds[4]=ki.INIT_BOUNDS[4],t.bounds[5]=ki.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const y=t.normalArray.buffer,w=[],P=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,P),t.orientationMode){case iC.MATRIX:T(n,n,[...P.slice(0,3),0,...P.slice(3,6),0,...P.slice(6,9),0,0,0,0,1]);break;case iC.ROTATION:I(n,n,P[2]),S(n,n,P[0]),A(n,n,P[1]);break;case iC.DIRECTION:if(0===P[1]&&0===P[2])P[0]<0&&A(n,n,3.1415926);else{const e=$o(P),t=[];t[0]=(P[0]+e)/2,t[1]=P[1]/2,t[2]=P[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case sC.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=$o(w,s),m[1]=m[0],m[2]=m[0];break;case sC.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case sC.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)Vn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(y,36*e,9);se(r,n),ge(r,r),fe(r,r)}const O=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&O&&(R.build(),t.colorArray=R.mapScalars(O,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}const uC={orient:!0,orientationMode:iC.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:sC.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uC,n),nc.extend(e,t,n),jt.algo(e,t,2,0),t.buildTime={},jt.obj(t.buildTime,{mtime:0}),t.boundsTime={},jt.obj(t.boundsTime,{mtime:0}),jt.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),jt.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),cC(e,t)}var pC={newInstance:jt.newInstance(dC,"vtkGlyph3DMapper"),extend:dC,...aC};const{vtkErrorMacro:fC}=jt;function gC(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(fC("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return fC("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return fC("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return fC("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,y=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>y?y:o[v]}}}}const mC={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function hC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mC,n),jt.obj(e,t),t.nodes=[],jt.setGet(e,t,["allowDuplicateScalars","clamping"]),jt.setArray(e,t,["range"],2),jt.getArray(e,t,["range"]),gC(e,t)}var vC={newInstance:jt.newInstance(hC,"vtkPiecewiseFunction"),extend:hC};const{InterpolationType:yC,OpacityMode:TC}=Og,{vtkErrorMacro:bC}=jt;function xC(e,t){t.classHierarchy.push("vtkVolumeProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(bC("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=vC.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=oC.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=vC.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return bC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(bC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(yC.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(yC.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(yC.FAST_LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(yC,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode"].forEach((n=>{const r=jt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode"].forEach((n=>{const r=jt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]}))}const CC={independentComponents:!0,interpolationType:yC.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function SC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,CC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:TC.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1})}jt.setGet(e,t,["independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),xC(e,t)}var AC={newInstance:jt.newInstance(SC,"vtkVolumeProperty"),extend:SC,...Og};const{vtkDebugMacro:IC}=jt;function wC(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>e,e.makeProperty=AC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){IC("Recomputing bounds..."),t.mapperBounds=n.map((e=>e));const r=[];ki.getCorners(n,r),e.computeMatrix();const o=new Float64Array(16);m(o,t.matrix),r.forEach((e=>Vn(e,e,o))),t.bounds[0]=t.bounds[2]=t.bounds[4]=Number.MAX_VALUE,t.bounds[1]=t.bounds[3]=t.bounds[5]=-Number.MAX_VALUE,t.bounds=t.bounds.map(((e,t)=>t%2==0?r.reduce(((e,n)=>e>n[t/2]?n[t/2]:e),e):r.reduce(((e,n)=>e<n[(t-1)/2]?n[(t-1)/2]:e),e))),t.boundsMTime.modified()}var r;return t.bounds},e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}const PC={mapper:null,property:null,bounds:[1,-1,1,-1,1,-1]};function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper"]),jt.getArray(e,t,["bounds"],6),wC(e,t)}var RC={newInstance:jt.newInstance(OC,"vtkVolume"),extend:OC};const{BlendMode:MC,FilterMode:DC}=Mg,EC={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=vC.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function VC(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Fa(),t.bounds},e.update=()=>{e.getInputData()},e.setBlendModeToComposite=()=>{e.setBlendMode(MC.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(MC.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(MC.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(MC.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(MC.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(MC.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>jt.enumToString(MC,t.blendMode),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>jt.enumToString(DC,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(DC.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(DC.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(DC.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(Ma(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(Ma(e,0,1)),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),e.setAnisotropy=e=>n.setAnisotropy(Ma(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Do(Ma(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}const LC={bounds:[1,-1,1,-1,1,-1],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:MC.COMPOSITE_BLEND,ipScalarRange:[-1e6,1e6],filterMode:DC.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,volumeShadowSamplingDistFactor:5,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7};function BC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LC,n),Bs(e,t,n),jt.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","volumeShadowSamplingDistFactor","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius"]),jt.setGetArray(e,t,["ipScalarRange"],2),jt.event(e,t,"lightingActivated"),VC(e,t)}var NC={newInstance:jt.newInstance(BC,"vtkVolumeMapper"),extend:BC,...EC};const{InterpolationType:_C}=eg,{vtkErrorMacro:FC}=jt;function kC(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].rGBTransferFunction!==a&&(t.componentData[o].rGBTransferFunction=a,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=n,a=r;return Number.isInteger(n)||(a=n,o=0),t.componentData[o].piecewiseFunction!==a&&(t.componentData[o].piecewiseFunction=a,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=t,o=n;return Number.isInteger(t)||(o=t,r=0),e.setPiecewiseFunction(r,o)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return FC("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(FC("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(_C.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(_C.LINEAR),e.getInterpolationTypeAsString=()=>jt.enumToString(_C,t.interpolationType)}const GC={independentComponents:!1,interpolationType:_C.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1};function UC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,GC,n),jt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}jt.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity"]),jt.setGetArray(e,t,["labelOutlineThickness"]),kC(e,t)}var zC={newInstance:jt.newInstance(UC,"vtkImageProperty"),extend:UC};const{vtkDebugMacro:WC}=jt;function HC(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.property||e.getProperty();let n=t.property.getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=zC.newInstance,e.getProperty=()=>(null===t.property&&(t.property=e.makeProperty()),t.property),e.getBounds=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n.concat(),t.bounds=[1,-1,1,-1,1,-1],t.boundsMTime.modified(),n;if(!t.mapperBounds||!(r=[n,t.mapperBounds],r[0].map(((e,t)=>r.map((e=>e[t]))))).reduce(((e,t)=>e&&t[0]===t[1]),!0)||e.getMTime()>t.boundsMTime.getMTime()){WC("Recomputing bounds..."),t.mapperBounds=n.map((e=>e)),e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),ki.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}var r;return t.bounds},e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!ki.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),ki.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getMTime=()=>{let e=t.mtime;if(null!==t.property){const n=t.property.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}if(null!==t.property){let n=t.property.getMTime();e=n>e?n:e,null!==t.property.getRGBTransferFunction()&&(n=t.property.getRGBTransferFunction().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}const jC={mapper:null,property:null,bounds:[...ki.INIT_BOUNDS]};function KC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jC,n),ts.extend(e,t,n),t.boundsMTime={},jt.obj(t.boundsMTime),jt.set(e,t,["property"]),jt.setGet(e,t,["mapper"]),jt.getArray(e,t,["bounds"],6),HC(e,t)}var $C={newInstance:jt.newInstance(KC,"vtkImageSlice"),extend:KC};function qC(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(jt.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Fa())}const XC={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1]};var YC=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,XC,n),Fs(e,t,n),jt.setGet(e,t,["slice","useCustomExtents"]),jt.setGetArray(e,t,["customDisplayExtent"],6),jt.setGetArray(e,t,["backgroundColor"],4),qC(e,t)};function ZC(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Mn(c,c);const u=ni.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:QC,otherStaticMethods:JC}=Ul,{SlicingMode:eS}=sg;function tS(e,t){function n(){let n;switch(t.slicingMode){case eS.X:n=0;break;case eS.Y:n=1;break;case eS.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=ka(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case eS.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case eS.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case eS.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case eS.I:l=Ma(a[0],i[0],i[1]);break;case eS.J:l=Ma(a[1],i[2],i[3]);break;case eS.K:l=Ma(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case eS.I:case eS.J:case eS.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case eS.X:e.setSlice(r[0]);break;case eS.Y:e.setSlice(r[1]);break;case eS.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(eS.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(eS.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(eS.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(eS.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(eS.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(eS.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case eS.X:n[0]=1;break;case eS.Y:n[1]=1;break;case eS.Z:n[2]=1;break;case eS.I:ea(r,[1,0,0],n);break;case eS.J:ea(r,[0,1,0],n);break;case eS.K:ea(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==eS.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Fa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case eS.I:r[0]=a,r[1]=a;break;case eS.J:r[2]=a,r[3]=a;break;case eS.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Fa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case eS.I:a[0]=s-r,a[1]=s+r;break;case eS.J:a[2]=s-r,a[3]=s+r;break;case eS.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ZC(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}const nS={slicingMode:eS.NONE,closestIJKAxis:{ijkMode:eS.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function rS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nS,n),YC(e,t,n),jt.get(e,t,["slicingMode"]),jt.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Ul.implementCoincidentTopologyMethods(e,t),tS(e,t)}var oS={newInstance:jt.newInstance(rS,"vtkImageMapper"),extend:rS,...QC,...JC,...sg};const{vtkErrorMacro:aS}=jt;function iS(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}function sS(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void aS("No input specified.");if(1===o)return void(r[0]=n[0]);const a=gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===js.SINGLE?s=ys.FLOAT:t.outputPointsPrecision===js.DOUBLE&&(s=ys.DOUBLE);const v=mc.newInstance({dataType:s});v.setNumberOfPoints(i);const y=v.getData(),T=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Es.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Es.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Es.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];y.set(t.getPoints().getData(),3*i),iS(T,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),iS(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),iS(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),iS(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(T),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}const lS={outputPointsPrecision:js.DEFAULT};function cS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lS,n),jt.setGet(e,t,["outputPointsPrecision"]),jt.obj(e,t),jt.algo(e,t,1,1),sS(e,t)}var uS={newInstance:jt.newInstance(cS,"vtkAppendPolyData"),extend:cS};function dS(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=jt.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Nf().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=gu.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}const pS={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function fS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pS,n),jt.obj(e,t),jt.setGet(e,t,["height","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),dS(e,t)}var gS={newInstance:jt.newInstance(fS,"vtkConeSource"),extend:fS};function mS(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=jt.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Es.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Es.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],y=[0,0],T=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],y[0]=Math.abs(2*e/t.resolution-1),T[0]=y[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],y[1]=0,T[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],y[0]=h[0],T[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],y[1]=h[2],T[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=y[e],p[2*r+e]=T[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Nf().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=gu.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}const hS={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function vS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hS,n),jt.obj(e,t),jt.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),jt.setGetArray(e,t,["center","direction"],3),jt.algo(e,t,0,1),mS(e,t)}var yS={newInstance:jt.newInstance(vS,"vtkCylinderSource"),extend:vS};function TS(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=yS.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Bf().rotateZ(-90).apply(a).apply(i);const s=gS.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Nf().translate(1-.5*t.tipLength,0,0).apply(c);const u=uS.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Nf().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Nf().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Nf().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}const bS={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function xS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bS,n),jt.obj(e,t),jt.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),jt.setGetArray(e,t,["direction"],3),jt.algo(e,t,0,1),TS(e,t)}var CS={newInstance:jt.newInstance(xS,"vtkArrowSource"),extend:xS};function SS(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Bf().translate(...n).apply(e.getPoints().getData())}function AS(e,t){const n=e.getPoints().getBounds(),r=[0,0,0];r[t]=-n[2*t],Bf().translate(...r).apply(e.getPoints().getData())}function IS(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Es.newInstance({name:"color",numberOfComponents:3,values:a}))}function wS(e,t){t.classHierarchy.push("vtkAxesActor");const n=nc.newInstance();e.setMapper(n),e.update=()=>{const e=CS.newInstance({direction:[1,0,0],...t.config}).getOutputData();t.config.recenter?SS(e):AS(e,0),IS(e,...t.xAxisColor);const r=CS.newInstance({direction:[0,1,0],...t.config}).getOutputData();t.config.recenter?SS(r):AS(r,1),IS(r,...t.yAxisColor);const o=CS.newInstance({direction:[0,0,1],...t.config}).getOutputData();t.config.recenter?SS(o):AS(o,2),IS(o,...t.zAxisColor);const a=uS.newInstance();a.setInputData(e),a.addInputData(r),a.addInputData(o),n.setInputConnection(a.getOutputPort())},e.update();const r=jt.debounce(e.update,0),{setConfig:o,setXAxisColor:a,setYAxisColor:i,setZAxisColor:s}=e;e.setConfig=e=>!!o(e)&&(r(),!0),e.setXAxisColor=e=>!!a(e)&&(r(),!0),e.setYAxisColor=e=>!!i(e)&&(r(),!0),e.setZAxisColor=e=>!!s(e)&&(r(),!0)}const PS={config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1},xAxisColor:[255,0,0],yAxisColor:[255,255,0],zAxisColor:[0,128,0]};function OS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,PS,n),hs.extend(e,t,n),jt.setGet(e,t,["config"]),jt.setGetArray(e,t,["xAxisColor","yAxisColor","zAxisColor"],3,255),wS(e,t)}var RS={newInstance:jt.newInstance(OS,"vtkAxesActor"),extend:OS};const MS="resetcamera",DS="orientation",ES={MODE_RESET_CAMERA:MS,MODE_ORIENTATION:DS,MODE_SAME:"same"};function VS(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._srcRendererChanged=a,t._dstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===DS?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],qo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===MS&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}const LS={mode:DS,focalPoint:[0,0,0],distance:6.8,active:!0};function BS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,LS,n),yt(e,t),At(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),Pt(e,t,["focalPoint"],3,0),VS(e,t)}var NS={newInstance:Et(BS,"vtkCameraSynchronizer"),extend:BS,SynchronizationMode:ES};const _S={},FS={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=NS.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:NS.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kS=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;_S[r]||(_S[r]={});const o=_S[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=NS.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];FS[e.type]?o[r]=new FS[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const GS={},US=/instance:\${([^}]+)}/,zS={},WS=[],HS={},jS={vtkPoints:mc,vtkCellArray:cc,vtkDataArray:Es};function KS(e){return e.map((e=>US.exec(e))).filter((e=>e)).map((e=>e[1]))}function $S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$S(e,t)})),t}function qS(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=GS[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function XS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=GS[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function YS(){Object.keys(GS).forEach((e=>{delete GS[e]}))}function ZS(){Object.keys(zS).forEach((e=>{delete zS[e]}))}function QS(e){if(1===e[1].length)return-1===WS.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===WS.indexOf(e[1][n]);return t}function JS(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(HS[r]){const{key:n,value:o}=HS[r];if(!n||e.properties[n]===o)return void WS.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=XS(r,{managedInstanceId:t}),n.registerInstance(t,o)),qS(r,o,e,n)})),t.calls&&t.calls.filter(QS).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=US.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=jS[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function eA(e,t,n){zS[t.id]||JS(e,t,n),zS[t.id]=!0}function tA(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function nA(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function rA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=nA(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=nA(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),tA(t.getPointData(),i.pointData),tA(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=JS(t,s,r);return r.end(),l}}const oA=rA(["points","polys","verts","lines","strips"]),aA=rA([]);function iA(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JS;XS||qS?GS[e]={build:t,update:n}:delete GS[e]}const sA={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},lA={vtkAxesActor:{build:RS.newInstance,update:JS},vtkRenderWindow:{build:av.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(QS).filter((e=>"removeRenderer"===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),JS(e,t,n),kS(e,t,n)}},vtkRenderer:{build:Qh.newInstance,update:function(e,t,n){JS(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$S(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(QS).filter((e=>"removeViewProp"===e[0])).forEach((e=>{KS(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:El.newInstance,update:JS},vtkCamera:{build:Bh.newInstance,update:eA},vtkPolyData:{build:gu.newInstance,update:oA},vtkImageData:{build:fl.newInstance,update:aA},vtkMapper:{build:nc.newInstance,update:JS},vtkGlyph3DMapper:{build:pC.newInstance,update:JS},vtkProperty:{build:ds.newInstance,update:JS},vtkActor:{build:hs.newInstance,update:JS},vtkLight:{build:kh.newInstance,update:JS},vtkColorTransferFunction:{build:oC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Tu.newInstance,update:JS},vtkVolume:{build:RC.newInstance,update:JS},vtkVolumeMapper:{build:NC.newInstance,update:JS},vtkVolumeProperty:{build:AC.newInstance,update:JS},vtkImageSlice:{build:$C.newInstance,update:JS},vtkImageMapper:{build:oS.newInstance,update:JS},vtkImageProperty:{build:zC.newInstance,update:JS},vtkPiecewiseFunction:{build:vC.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Fu.newInstance,update:JS},vtkScalarBarActor:{build:Op.newInstance,update:JS}};function cA(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];e&&YS(),Object.keys(lA).forEach((e=>{const t=lA[e];iA(e,t.build,t.update)}))}function uA(){Object.keys(sA).forEach((e=>{sA[e].forEach((t=>{GS[t]=GS[e]}))}))}cA(),uA(),HS.vtkPVLight={};var dA={build:XS,update:qS,genericUpdater:JS,oneTimeGenericUpdater:eA,setTypeMapping:iA,clearTypeMapping:YS,getSupportedTypes:function(){return Object.keys(GS)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return ZS();let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zS[e]})),r},updateRenderWindow:function(e,t,n){return qS("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){HS[e]={key:t,value:n}},setDefaultMapping:cA,applyDefaultAliases:uA,alwaysUpdateCamera:function(){iA("vtkCamera",Bh.newInstance),uA()}};const pA={};function fA(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=Dm(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function gA(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function mA(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Dt(t,n,"progressEvent"),Dt(t,n,"progressDone"),t}function hA(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function vA(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=pA[e];return t||(t={...fA(),...gA(),...mA(),...hA()},pA[e]=t),t}function yA(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Bt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),dA.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){dA.clearOneTimeUpdaters(a())}}}function TA(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=vA(t.synchronizerContextName));const n=yA(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}const bA={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function xA(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bA,n),av.extend(e,t),bt(e,t,["synchronizerContext"]),TA(e,t)}var CA={newInstance:Et(xA,"vtkSynchronizableRenderWindow"),extend:xA,getSynchronizerContext:vA,setSynchronizerContext:function(e,t){pA[e]=t},clearSynchronizerContext:function(e){if(e&&pA[e]&&delete pA[e],!e){const e=Object.keys(pA);for(let t=0;t<e.length;t++)delete pA[e[t]]}},decorate:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";const n=yA(e,vA(t));return{...n,...e,delete:Vt(e.delete,n.delete)}},createInstanceMap:gA,createArrayHandler:fA,createProgressHandler:mA,createSceneMtimeHandler:hA,vtkObjectManager:dA};const{vtkErrorMacro:SA,vtkDebugMacro:AA}=jt;let IA=0;function wA(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function PA(e){return"/"===e[0]?e.substr(1):e}const OA={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=wA(PA(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=wA(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=PA([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=wA(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=yh(mh(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(Dm(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=yh(mh(new Uint8Array(n.buffer))):n.buffer=mh(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Ah!==n.ref.encode&&Ah&&(AA(`Swap bytes of ${n.name}`),Ih(n.buffer,vs[n.dataType])),n.values=jt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&SA(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--IA&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Vm("html",(e=>OA));const{vtkErrorMacro:RA,vtkDebugMacro:MA}=jt;function DA(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const EA=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new Bm(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(hh)return hh.encode(e);var o=e.length,a=new Bm(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Bm(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return oh(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=Ch(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||RA("ERROR!!! zip not ready...");const u=DA([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=yh(mh(new Uint8Array(e.buffer))):e.buffer=mh(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(Ah!==e.ref.encode&&Ah&&(MA(`Swap bytes of ${e.name}`),Ih(e.buffer,vs[e.dataType])),e.values=jt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&RA(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(yh(mh(r))):JSON.parse(r),n()}}(i,s.compression,d);e(yh(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=yh(mh(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(yh(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(yh(Ch(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(yh(s))},fetchImage(e,n){const a=DA(n);t||RA("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Mm(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=DA(n);t||RA("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(mh(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};Vm("zip",(e=>EA(e)));var VA=n(892),LA=n.n(VA),BA=n(760),NA=n.n(BA),_A=n(311),FA=n.n(_A),kA=n(192),GA=n.n(kA),UA=n(60),zA=n.n(UA),WA=n(865),HA=n.n(WA),jA=n(34),KA={};KA.styleTagTransform=HA(),KA.setAttributes=GA(),KA.insert=FA().bind(null,"head"),KA.domAPI=NA(),KA.insertStyleElement=zA(),LA()(jA.Z,KA);var $A=jA.Z&&jA.Z.locals?jA.Z.locals:void 0;let qA=!0;function XA(e){e.preventDefault(),e.stopPropagation()}function YA(e,t){qA=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=Hx.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=CA.getSynchronizerContext(),a=CA.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",$A.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=jt.formatBytesToProperUnit(e.loaded)};t.fileURL?Mh.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Lm("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):Mh.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Lm("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=Dm(t.base64Str),n=Lm("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function ZA(e){qA=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add($A.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${$A.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){XA(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];YA(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",XA)}const QA=Hv();if(QA.url||QA.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add($A.fullScreen),t.style.margin="0",t.style.padding="0"),qA=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>YA(n,QA)))}setTimeout((()=>{qA&&ZA()}),100),window.OfflineLocalView={initLocalFileLoader:ZA,load:YA}},793:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},490:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},22:function(e){"use strict";e.exports=function(e){return e[1]}},145:function(e,t,n){"use strict";var r=n(426),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},903:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},152:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},491:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},177:function(e,t,n){"use strict";var r=n(145),o=n(491),a=n(486),i=n(999),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},486:function(e,t,n){"use strict";var r=n(491);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},999:function(e,t,n){"use strict";var r=n(145),o=n(486);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},444:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(511),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var y=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),T=0;T<u.length;++T)y&&"constructor"===u[T]||!o.call(e,u[T])||p.push(u[T]);return p}}e.exports=r},426:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(511),a=Object.keys,i=a?function(e){return a(e)}:n(444),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},511:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},640:function(e,t,n){var r=n(64),o=n(115),a=n(965),i=n(332),s=n(65),l=n(182),c=n(293);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},64:function(e,t,n){var r;!function(e,o,a){function i(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function s(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function l(e,t){var n=new i(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.alea=l}(0,e=n.nmd(e),n.amdD)},182:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.tychei=l}(0,e=n.nmd(e),n.amdD)},115:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor128=l}(0,e=n.nmd(e),n.amdD)},65:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function s(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xor4096=l}(0,e=n.nmd(e),n.amdD)},332:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function s(e,t){return t.x=e.x.slice(),t.i=e.i,t}function l(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorshift7=l}(0,e=n.nmd(e),n.amdD)},965:function(e,t,n){var r;!function(e,o,a){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function s(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function l(e,t){var n=new i(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&s(r,n),o.state=function(){return s(n,{})}),o}o&&o.exports?o.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(t,n,t,o))||(o.exports=r):this.xorwow=l}(0,e=n.nmd(e),n.amdD)},293:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,y(a)]}}():e,3),r),f=new g(r),T=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return T.int32=function(){return 0|f.g(4)},T.quick=function(){return f.g(4)/4294967296},T.double=T,v(y(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(T,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(706)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},594:function(e){e.exports=function(e){"use strict";var t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function n(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function o(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function a(e){var t,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,r(e.substring(t-64,t)));for(o=(e=e.substring(t-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<o;t+=1)a[t>>2]|=e.charCodeAt(t)<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}function i(e){var n,r="";for(n=0;n<4;n+=1)r+=t[e>>8*n+4&15]+t[e>>8*n&15];return r}function s(e){var t;for(t=0;t<e.length;t+=1)e[t]=i(e[t]);return e.join("")}function l(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function c(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function u(){this.reset()}return s(a("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),u.prototype.append=function(e){return this.appendBinary(l(e)),this},u.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var t,o=this._buff.length;for(t=64;t<=o;t+=64)n(this._hash,r(this._buff.substring(t-64,t)));return this._buff=this._buff.substring(t-64),this},u.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},u.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},u.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},u.prototype._finish=function(e,t){var r,o,a,i=t;if(e[i>>2]|=128<<(i%4<<3),i>55)for(n(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,n(this._hash,e)},u.hash=function(e,t){return u.hashBinary(l(e),t)},u.hashBinary=function(e,t){var n=s(a(e));return t?c(n):n},u.ArrayBuffer=function(){this.reset()},u.ArrayBuffer.prototype.append=function(e){var t,r,a,i,s,l=(r=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(r.byteLength+a.byteLength)).set(new Uint8Array(r)),s.set(new Uint8Array(a),r.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,t=64;t<=c;t+=64)n(this._hash,o(l.subarray(t-64,t)));return this._buff=t-64<c?new Uint8Array(l.buffer.slice(t-64)):new Uint8Array(0),this},u.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=s(this._hash),e&&(n=c(n)),this.reset(),n},u.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},u.ArrayBuffer.prototype.getState=function(){var e,t=u.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},u.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),u.prototype.setState.call(this,e)},u.ArrayBuffer.prototype.destroy=u.prototype.destroy,u.ArrayBuffer.prototype._finish=u.prototype._finish,u.ArrayBuffer.hash=function(e,t){var r=s(function(e){var t,r,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(t=64;t<=c;t+=64)n(u,o(e.subarray(t-64,t)));for(r=(e=t-64<c?e.subarray(t-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],t=0;t<r;t+=1)a[t>>2]|=e[t]<<(t%4<<3);if(a[t>>2]|=128<<(t%4<<3),t>55)for(n(u,a),t=0;t<16;t+=1)a[t]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,n(u,a),u}(new Uint8Array(e)));return t?c(r):r},u}()},34:function(e,t,n){"use strict";var r=n(22),o=n.n(r),a=n(793),i=n.n(a),s=n(490),l=n.n(s),c=new URL(n(352),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.Z=u},396:function(e,t,n){var r=n(13),o=n(903);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},892:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},311:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},60:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},192:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},760:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},865:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},352:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},706:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(396)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "UEsDBBQAAAAIACeXmlhVf3GjIPkEAOXfCwAKAAAAaW5kZXguanNvboy92bbqOtIl/Co1vlvXGLKxcfPfqXHfCjDY3NQAgwUYMK0Nrpf/xV57n21nrpVZ6+acPDNDTSgUMSMki//7P7vVfbe9/8//97/+7/+My1JbS9Jos96sJE1UxZE8ktaGIir6aqSO9f8jSYoob379fz9i/F/+n2X+9//6n8f7sv2IWMd69VAVeLut3p//3jyqz3/m/0jq/flx//y3oj4/tufH57+vD90LSJuZd4d//l7U9xQhElzHvMDRs05cd3Hz+7h1TeGVmIX4A/7n38wjVPChOIsV9X7A61VmnKVm5RY93Hwh/ERbI73A+yu7nsfrsdfHA3sNbeRu0wfERaPJgqW4/fbjsYpOxJJ5+3/Hh/UDLGBosDs1hYMAwPJfcDptYkDHyr0/vndnZq0vxZ4Ok8Nkyy6K++zjKoLE9djS/WF+6aTNaKDMvBBFc7yAaao0AxzpuEXO26l68u5tgyAmjhVBf6dpJYiOZh9PVjKKYWlZHjwmIs5d0XHTvn7ICI6g6Bw96O2yVpYvqSf2x2eekUkSxfoBj8wCHPTOlSZw6ea4TRa1XX2Phzeildqqxv3+ffEK33Di8fFvF41WvlTfSaGxwQfmH6prX/5v/2QuvCr2LooL9bZvrtbKnEc9HEWicAfQCeu+fLWrfBhtD8JB/3Z8HQykUnYQFhFAyRJcu/zexyfH/JCjk+2Z36/fSMhhDTXV/QH/ox/3r/4G9vHoQqy4ytQd6DcfoZZIDce/X5+/8t/iTnrCNe4w3x89/SymxrZER/b8Xh7h7SuHzzp/Uu8ioBQ5x3TQ/sWNJcCw/qSJUxgygMfq8n3/4WYqGEaWVA9oj1Lsonfj9u3DAg+kk/rG/QdSz+CsG5vB/vDjEiAj9/j6fus/wrvN178Wuf2m95nQqFk08A/e4QVtaOuW9b18b30dMVGBripWXz66H0EptKtjBLtbJzjK4uaG38tbi9xhSIpNvYcnZwxzctzMvX7/Hd1OympTX6idEsiw+C/zs+7JqTxNqoH90kWBFUhM9078+0uBqw0d7I+e/KibXKAa0gvF+h7sjEb4af6W1wAiGIVkwXtmTvjmFEB/f/jhDtlw1vL1Px10T8H0iPrr17MfM8gjxY0o6e9vJG0xJtOO4ztNz6i/Gev99nvyezwTZTC/S12///0YbcnyVvH9cWem6+1eKunhOAmMB5iuuX2vcdPJonZB/f0XXWocI+/E7fNv+0bUtD6rpfrdb/9wq0mOwYuPTxPaN3s92zd1H2uwFhwh3cFT4RzPSpQDYsy3zbmkx3tLzbJGIVQ34u67+Q32F847UGqgAQfDe6IptKD5piGIjbWRplzefsyejTC79vQ7kIdtY5zbhWT+oP8zrSe1aWewv75EkoyHkN7EI+yCsyCL01Rb9/Rnkiu8Quzx+Jz5ziuRCg/15Z1LCiJ9UnP97q4uzv2LqfblSTsSzsZ7we3DKrSx83q9zf7+8K8bbk/0s/7c2/iKWab4h/j3z1/4/4wP/Rc8q42qpOYPeKmKCAYrxfqh/f000bK3/sZFX/7ewhZGV74+22kHHPA+6GvB1IUHWKr0TZ1uB0M0pdx+1nLh5TYqyB0ecBOCzQa2lER342VkWy4/Sajdhg4P46j2mi2YJSFf/9EMx7h+cPymMcii/WkQ3+2LCDrjpn723yYbN907sfq4eQ7BBLzGHNdwJ8jqEtk/2IdufYzv4Q7w8KChE9oT8QGfBw2UY7o0f4hPk+VNT17d1f7BPhd7hpipez1+McCjUWEqcH0Z9+3Hsd5wAQ+I97/d5MQNZdHo4zaLwdgYx1IEI5Co5Wv6xD/479s8GWdvec79t9sZ3GvL9SB+32AC5Nae8fV74YkOvTb/yX/+bT8OKnhHtmu+4DMGRvnm/99+fHBWId7jY5C+4KGrl7U1Mry+fdkLC6e4sVKp1z66ysarTAp6p7ZJQQbQ3Hz8EJ+2ItD0MUzHff5p7JMdaOL2Rt1oh/fIJiJv3yFaJtWi0/d/4UkRZMMDc/R9fHY7BOb6uJ5b/fifbSYvljPzRuNqB1Oyswf8EGfZS4fjZXj54ocoQZL1fftkvAE3A+VHBHevwEjeuWj39eOGI0MSYPvZ32+TtObjMtifSRvy8Uc199+TrWLRQHs5fRy1H36LN9w/CctMb6RAcPr6Qy53tcg68/0pzzVFFoWZ81/8izvY/3/x97rA0I0u9g94XYsWc/eS059/IAdwROZH04C791mXO6+0BuuT34yx4FKTr28jg+R1Lwf83F1fgazTM19fL08hs5dgGF+PN6jCkkg/rG+krrg/2154+9+vDyDgqHdN9eqvf7V7FOCUc/vC0gJsjOBqSn2cTN9raIrplTpSKWR69uDzI9MaM7cS3T7/sY2DMdPPsDK+t28n96GALwG3DxjfxrJ2NOwBfl7AN4r2vP/STwxZXgoDfuaZb2EM2qdowK0DCbMabbA/LeJz/3m5cf30+uc8/gxhUlxpuFzgE4rdtD8+8pyBuCxfnF/98r/6reHj89LcdM3ZbbA+8cVFOWoFnl/u/RTX8Q1Yff0mtwsqkFiJA/2eTaYwnfD80dUT9MSZwuVnVlBnevxqtZ7/C5kKdWT6nD++WWmU6jggff36qQXWuufz/TvapJjBjJkD+8hUtMD1mcf31zhoGx3rg/zH44ED44N5tGCmdk9ZagW+Xn9xMxSBp19nnL9vzrkJLQBgX7/JhlsX7h4cX8PAOMueNIj/Fg6gAO0N92/xizSNcAyMQf4VWLhABuP2uVyUmjxqVlrQ54elAKdQsSwERfOml+17bQ/W3y7wneSf/tux9m70bYz7+8utFAxhY3L/20hF0pr6FPXH98u+SORw/5q96ogFzWywv/zZVnAMtebx6aIyp43gYTA/D0moht6Jxwcwvj3AuM27W2/87rQwAHhBjhNFO55fTjDQv/+00B4aMY8f1a2OqD3din1+G6wkPCW+z+3/+gBHp11KoK8fyzA5H90O9y9MPGjC3fG+p8RveH7RxsdBfrwxoAPDXbWjlsT4+pz1of8uDiUowzXb9ONj7WjjrG13jonGEniXlZSz7/NzvDgLx7Io6uv3+SW5rdszTLTiRiPXRHvMxuIg/2yv+wmrObVsRl/5ERqOn27gBG75lqHBDcA9eWOpj5NdkmAAzxWhfqCCl2Aa3L5peYet++D5N4LScwzeWWi2vh4Dx3Au1kB+IlOHiaEL22/nh3YlpyKPi0J+qE/UXcMTiWUVtKZRgbEgy1y/wQwISWdYboW3y+hW2sfVu1FfWOhAdeH7Gya6zch57FTIXz0f5ezSBI3xt313n6I8ORDXJLMAJixaMfpD/94z+SRFSk0JZsbD6F7VQP/LOacVUldx/9c4SCXWfVAfILPjcwPauXj+Yf2Um7Au75V+pM7YgQtkNoP1I3aLTjBqwhMNjgtjbJwLnt/36x/HhpTWO79+Xx9BpY2eMOCU94f+tXEyAg+NHb7H8WZPAzazuHyiZwIyZrdhfNvkXH8XsaiovYbGzlivxH58xIczaMtFXHP7biO0hZvFEQ3sY7+VwebsBMnbOYNMKKSBfrE2A6PyvE4hdTj5GcFCGtZXzmV7gL7K86322/HrYesw/OIW8FpQHkFhO1gfHM33iPuj2TvRFjHPX9X7oP6CLSupy5WUnZpv20du3JigGN3GjZZWxk2YiulA//WWEahdb1p/fH9xkgI2ZY59gD+0/x41CXBntfPD+iinpgGv5z2h0IuxC7fSoL5EHqARysMmnP6w/vWlvAB1JnrUr2RwEbY3cVDfmt3gionPOqVuUsIn9J/D+tQuBUJpZjCjYezjKbp14mB+j2splt5KD3+wz9c7eZXpPZz/UD9rCPev9zJd/lCfcwAzWWy3G2ouVoDoxXUoryalCNCEsh/kiziRynfh7mjiYQHp7+H+xjbk85/v0i2NrgBYAjiKg/33kimCeKpsvp8fqd7JvQRLff/D/FBTymUwhocv/WL/xNu/UGpSGOW9+iWEQS1w/pr6w/Whm9cF+k1xolbhgJtAMh5fe/h9fzmV2PMnidYdOP+vO87f1OAOa2wc3YroD3AASwu6rXuTAAILwPkB7TjRVK/cv0Ip513j4FA1qq1BHe9kvn8nTgDKdj3hEYewV8RK/RY1mpAhHyrbQfwjTGURnB7CWWtva26LTsnb34wV1DqUuSk6HGAEhYVptt4yRDZ+F4P8iFhr5kN3ndDEeAcfPbbpYH4LNzbKc1YjigkwlkazHcyf7F22YvVJp9S2ZthGq8dQHseNWN52+YrG1gkzjF9VH4fyI1FKfVctqXOdCUTg/LPv31B9iQ1Q0TT449+gNfBv2qW5lQsDTilqJlBEk09+95/X9/Et3vbwnn0mM3qGuqzg1qtTYwfK1wCHyrq1YIfhntrnEarx6WYO5j+DzGdwwvkHllNjqVMk9vMT+OKsujyDO6LOaGtshHFlDvy/RZNRGexA0ch6g1PyctO+PClbtoJRpPzDLwQeP/7z/Ab8S5q9fVi/tFHDnasQGJwzGXBiBMJZnoncfknEIHtnud1ijMAGXLOh/lXQNiy+1IRCQwWJLtqcn/5n/X8/vr+4BG+tSKBpy7z/Z7yzYeYneiO8eX5M9hLHqxfF0LtEboUqpbyV11Vwb4RtCiyDwTmCU1a5DK7aXn2qN/9Bfnf2KR+JqexoHHtA01frY7/+TUpIEzav6j0Nqcv9c7Mc1L9x8HrcylHm1tTaeohCUA7OD7Ew2Y5KF+gDftDDR2uggSI5rxLjU783WjxoH3UBvMNIcCMaAwXsgK/M+/VxctTYmu2mbUr9/A4pXA7r83/54ff1I+yR5A3cXaI26qgWDDAXBu3DeQotJqnV5A+/JMfB+P7hl33++RSBcR6PZu6dXHecH5jXatrv/+iZiKJD5hYonfP4rUrPXWJ8W9+aH9gEhl1YDM4X7iJmjj9175Av3IaZBxO1cNYhl7xXnB+DMtNkHT7cAhezZMf5l5i2386fzAUYMpsWB4pFgee/yiEdnP/6G0rY/dgO4hty2TmPseoVcHZL5BJvq0H8aW+3cfYyfa8g8XgCWLMxB/xUo3DjOtuNp8Mmnu7gyR/mH73xYcIidtfTjFobH69w8RyObxqwlL02If1eHjkiKMq4lbVk/DlfwrY2OP/Gm3eigLWhlNQEe0My9Dn3Hz1cXDLGxkWe0FihRmdsrmkfRzHXPmveYN3nVyu8lhuxy7wCewr338dz8O7zszU4Hx0NBFx/1QZ6LJubqx/qWyUTQPlQPvzrW/3YUvksF2tlTxN7I7yELZr36yf4TmkAsynbUW/kwScKk+H+mWoNAKOMWS15K7DAjzHfv3QMlg14n3v10Z7/4Pjb2QGtWHo64hl4BpukOzed4wg7QN48Pvxn+X79lLxnQAIP+3xttMcR6uQQ8vz5O/k+PzHuzaME3dTj+2cMIlDedbP9Vj+wfbcnFm/vFY30HNboIFb9+i5RFolXNoXI84/JBJn4qfP4HKsFqTFduDr3+eUDKAt3Pzg/vxRQSdQTx5VdkpUs0XFrpQe0INFq4D+RumIuT7vCFY0elTAHs6U4qA/7Lqc4Izm1/qlPDHBC5eZSHnVxQj2n41QqXnJ+ZKSy1GgbnduPfUMLVqoHuVE+9QvjlfL447Aira234YU4qZonyBekat5NCwhYxWZ//nB/T8Ygkbpdo2RE6Awkm4P4gA6tA1GhLRL5c34Cp5Dn57P9Wm+Mp839T2RNEVs2mdAAl4BAT0Kpb184OcCUWXdx0iYgFzSjlfj4s52sgHb85uu7cdoOBiD0W6RukItFn/NHaUL0RHi93Dsynb0J20nZNb/ztxUf32FOSRvI0CrgM32OS2kFj/312UnO+CzuasT5h1R25a1Rqj4OrrrFotncLPA2S8RSYIrXx+1jZpTGqTPveLF5FewZlXo/v/8TX3vnOxBaI26Sgm/x+DNrRIvbxBiLeL9NDiX2c6/vf8kmA+CNK9OEN8T9m5vkVr//h+VoPKhayITjNTtAzvtWffx6VLBii7YdQnXVVOAg5YP48HqXtfPymXDTV2VZA81g5aD9Zi2X4Jj06nOD8a9jmXsFv+ydTw7w68qMWrhOpZuQB+0EKnfOUHr6iaXcap1Lq2nGI2kLiC0Wt4P7GeUrU8L3WTMileunlN1BfcTHKYPoBnv1t0H/Yng7JQbnySEuT1CB7zK/fe8/sZrQHHZVvv3Bv7IgeZTt9b6gfnkxJgIsxU1f3mnKK2g2Zdb3739xMh/HAGT6TE/GVY5WZB6afXkirmDC4nuxo/YrFzx9Nxq0j6a7/ZJddubx+/EhlaIIPuZ8fgTthDOYWNWuP/4/f0/qNyb3byXiuFjNNNDu37bewwPJA0hfLc2+PBKcWC3LR34Z5JdqYTHTfJt9+TAqjaN+DNNB/++gfIIoUTi/CyrBEkZoMD5CDYihvBF5/rAKuP9IF+nme/v7x79z/21zx+olpXUn2f3pAtHTXs17lRkvfZTy9heg0T7xwf0hPkwLeXTuthX8W19+UvcoI5tMQi7/N3/G7JgYIL2IjIbFDMiCNMShOeVUO1/VS5ocVsLSUCw+/+lRJ4ykwO63b451QxN8j+O7ItES3bybfdyJ5zx/0j1z0P5mQ0uYPXn+8Lu+TcTB+Cq9TZmwy6rkFd8Bd/l+2sfRQ3w65VrVb1/3s9DEHYwfcVI9A21La+qfGZ7Ciz9sf3mDMcyjakKj3RIERoQGOKcOUGOTk1l9nW9g81/007OPT36AG4vLf93vSVu3P39yfOIQW/ZQ/hVuBDBj564R0ifv/xlx/BAr2DU76qYYHNspi+OsbQAs4YgsH1x/3+U3ffup8tJwjLPy9/yHcPnwyv9ZsuoI1XUGnPd7aac4tJOg1G7pi4ZqIsz19ybl/izm62HWgdOfX7w/YBcVEzHi/D1QG0O7WX080N5IhZVYTaBcleNEjHW7Imr6yphsKyKNdVmQ9TtXda99cpnxpGkpiu9++659E5KXdjRFaFtNDbDivqh5imCB4ns6h0ypYe77xErhflYqJTnx9vHujASczMU51CYZSMZXPLC/ZCQhRvK48mDcyMJZSsTB+O3xGfF4PDWtH9b3VgJNyBNxAi29BI7kaoP1tcoP0dmNq8n38tZkZixBtzA9WDwVx43uhdO/f/D7fCM2l1APa6g4uDD7eORj8ABVIC6hgnjS9c5flkiIUo7KHIoajaIruuOJMNAvnCCef20yV+3rNwtloxSSwDbRcRQr4HYSZep/6vtCVX+//qAv3+BAkcUamim6FQkGGwvKf+7vpekS3mJZabQ7s9Ke/K/7EWC8NudQfWut3IVnUpHcZoj5Mk+JftVXjLLh8wdZoDmdIFkmziL4go5hqjRc34WDcdpz/V0ZcxSiPXC//cjZwC2iQmrB6Uh3XWc36p2vcXxWg7OxUKuoN7/f92O7etSfn7Zz2uadEM6Hj5OkKrUItl/1X7xteXz7ez9LaIRdwK6PvOvfz0ppPnGdww7MDMdrTSZvmUY5lYNbIuXcf/Xud1XoZUP1SLW+/Df3y0AfP03FKbUWuTHTSb2VgJMp46/7A8SSuH84nMpOlpIrHz9bbd/gEBYKRZ2CFMSaT3wOIefdRYT6+nPR1dgJmyfH7cmhc0Qqcf5jyG0Ky02t0SS+IxGvVO7fyMNpS7We9u63gC/+Arqa+69T5po8Xo5792cAhZMXd8Xynmd8hhUYDZhNe/fjAEXbEp6gfuH7u3FypMSvM0nhvOM8TDkULwr9I0j0mcjt6+v+jZji/v7w9k8jA48pH3/mnMVSNPl4STefJPCCw46a6hnzZS95/PUPFNXkhK2+/K/zZ1hHfHyqUy3b4OgZnbC9w5ydsSlTG19BZCTNYP0As5IEaDZUvl8/sNjQiB0FJvXxpeMuXe90FdbC6dqcQEZdmcI4QjGCTnqESpeNmm4n8Xi63jYrINrFmJoehSISPe7fOU1UAVA3uILlCx5gK1GZkuvFWAovIFrQW/Clts4K35+PpmHAVPj8f8VHMpmnHpQK7SK/jpDbz81+QVjHoUi5SweBEIz4/Pzy0DSjK88+0OTOCibdQ4lGGl8/PW05fwMbkbSx3IFOLymzIQ55sAryEFx0MOHyLa59mEiqcTPACM3gdlyL1ETIeAHlE5+Oq0SRhc3LNHFXghPPX1lHITuiE3YKvv8jbSY4wOf5Aylm0IIMKhL13ju+20rA/d/orDssWtq9+xfcf8eSkBnzG1+/+J3p2ei0cQpi7ppracRK+xX/8aXg9iEmvLdIQpxfqSrNoBHkLSXZWABCJgz4a699E14AECpnyI8J3q2YaIaXr/u72I65/ISuhWzstDx/u4XlpEwr5fXFn4Ai8fH/lSeVs/fZPuD8xJWueIsJGeC9/pN3DO/YXfP9oYqzEZCPR2+Af52vlHx/LFad2ozLfTK83waApe8FArhHZVjxwSnpxy90vQJgIDclcBFAbmwqG8hbUwOFaH0VCbQsR5XHUjDAyRlpa8HkWTCcdgFfquCZ8PgQ4iVTQ/FOg3mCc5Ijk8AZ1ppk9Hol/ft5lrIREj3OKwKvSUtbxy8H44tEka/f48DxO0spCyAa4NzsgQeCvANwfnUMZxxEcT/+RniLcvyc8P79VSA2XRMN5JMuAjv9ZvD5bx6gcd5US1LczeM1eCb6k+I4FM5C2/H+Z9Nq2ro8yf87/5a6eM572F95++G48BX0rmHfPq33iMfvhbFbw27eXRJ1W3Ra7/6tq+rGXNAf7AzBPQ1qdLPJYH1jKAA9GtEZnEWHota3zurWkw/9MYyRj/YBXJvBu5R45/31cULI+ct1/VrD7U03WQidQX4TL+88PvvTvQOZQLTMME2n339wMQRDGKWTGf9fMyXT1tS8w/KOdLbsxJoGk4kgG8cFvfXlhQldMa0WT315x5WB3Jkrvv+OoygFil6dabhPEPdX4U7jzDYP3fh8B339/DrfwZNgf4b6RJzk5muN74jNXyVLY55/xYdEnQnhFmdw0okOX6+z07cv7zm1FxDGSQvEp8hpR3ga4HA747vfm7082C0zVe4WM6tvHzgYG8i4G/QHfucvb2Cuay39gT/Cf/9zvrufyv+MtuQ59Z0O+CmpbmBj3OdPBnrywYmn7LKiX/vyvfwne0OLKdPi8j3e79/X4J6sZruof766MNorSy88P/ZTE5mQSJDz03ytly+rsvr3l1Ebkys8mfQBT/ubnqgpGKzf7/yMvh6/+euqsQb7oyx5fvKkuwec7rmJoEQzBvYdljDH+rP9wT+Hkw2yYf5+oe/x3vxHQuq45n5p/oD/lSfgVBrloaoG+nvPMq3RC4R0vIhRA4/F/fydPHS/b//U1ZzfbLeWjh8Mn5gc5af/uj6BVfCZncxP/SDQJEc192HffkJtyuM157QzWL3WInjn9wEeLSU4wlktJrDTNamRZko4yM8/9+eFiVQl3L+UaiOvhYG8yRLMjWTE5RegxpSs8rDvX4KRKziCPjVnUPJMH8bmeSBP5hr83Hfg44vGmgLUphvg8cPkpHC85PjZd1Tw0vvj5/z7GOIrWdzS2e/xrQ68/+uDGiy43+9/vo9Lef9RdZ9BLC3ClLwWDQQ7Wty5f9zDFAvCAOcMFoAS0urZx/+OH6tl2ZSPRr/1xz8fy8/zq7HDQX73qX+jyKlmcAdzx7VuYDD+UKqNCTjkn/XZ1YR50j4UyfG0OZftJ76Q1R4pcE/5/EiraXInbAb2GbxD1MLu2V3gOqWm646w1t9fZMTwCq3IgfNLzO1jnM7E/v5BF6ARQ08O0l/zHPAbr9Iig/rdD3jiLzVPOFtkB5vGjN1onJHB/v/iD9PDHEot81qr6dH7j/88HHl8SV/EgI+xTiBXun0n6bIpgA3SN0WnJ6mxMpuNYRe6VzdeqF5BRo92xs56+6a+SqFOcDd7wLztnkC/WH5/fNiIzC0Rrwfjh/mZEySgic/58V+cpOC9Z8m4OPLGef6HwYn05VF+xpjd5xz35hVwgJXPLpxG16SFUzronzhvssXu/XD5vn9ynROI5ueD18PxqW2cMnSr49f3GzjyyBy+xRTm8NLF/f31mx9eRAdKPEXLYbQb4I63wimhIcdbbX2Vx1cn7u9v/7KFT/LY8jQ0OAZPTpXNuL//3IUJDH2bVQ7UDncf4pgN5H/Vb4S7xtvfH/WQJqo56N8qSuNhLGwxgCdfk0pBWgzatw8JrEgmpg4si8qtE+E9aJ/TMsRIsTQDOBMCOZPfWg/n/P0kGUe+f9IAbhuRZ4jvOO7zryhNoA6PNpcfeQfFkck7TnH9pBkblfrv+hu0DN5/PeODtMTLgB/+vj+85/pxdo2RaMcy7u9fa64KG4A7rh91J7+b9+09mF9yyrQbKJdEg/GkSCmCzUA/YTUyiBCrBw0+SPeUhcV0KH+dmikB4wOAF5oZjX4ayrunEQxJ53UynHompeEiHfLfbo/36GB3GrRT0srSqRvM79f5EhJHsw5Onu2M26vE5c3J8wLui/vtz/34y0yDCzcblSJrOT7K2zuDiXml8ed+BWB73r/sFCk0V5vB+H/V543JjDTwks7GjtA+YxGrq4kHF3V1pZa61gNj5pAOYqN2oDV+D+rHnrTVXoJj7uc/1M+8takSVr7/1tcH/AgdXvYCTZSpBIVw1pVdsIED/V4+H22OIT7Cy7yyW548okH/4Q2ueDDeI1hra60ZTcaD8cVRwPN/gb6kH+qD7RMWxJhPUR9vdaMpdXavKaYuTEl9mQzut0VHFjNwNU9f388iabLv80s0fU0D+I64f8CzrZkjazb9of9krmAXGeHM+n3/f9IM5md3Dw2Ad9E6//xH6CIpbsKygr37CRDDY9J6SpgHfD6daazLzdy9UOR0XN9LGWzB+ewSauJkcL7gBSuywmLZzqGdOE8ZUB8P1ufO2QPuhIcIFo0yaf23yfOrerknbPGobhSfIx7/UMHt/9v5IeOTP687c/47/1+tBvVTPJoLM/Ccc37Uq++bWfksZ2pe/7nfgKq+feEH2FvMzXn+/rs+u+T5c4//jm3MYLjROa466E3k5ac+cKWEhfJ4EJ/jFVLW4PGYzv+qt4+7xQVE+jvf9+MPmgWJVV5s90TtqS11wnK57+f/eEofCzB/8vX3hCVScLJ8/RBfMLziBZRm+0cf9897m6kKO1FrucMmviicv9NMdKFZpIPxIzoFZ0PjWoJtkaiOlJ3Urs8fis/9CjQ5WPAVrpvSEBMj6OG2ouulkQnv/vgQPEZtaYD8SM16a02xjWYIPjHostdhM/BPv/P3l8jz56cmZK+gGfiXuL2Dh3CqeH493Slz180nQ/mZDjESTO7f7TzRGhCoQ/xzfgr8hPvv176Rz8p+wXEZb/ISNDw+/P7+Iefys01yS1poJv348ys+CtuYx7/7RHRrN1kM8F/f34CbnhIYN5rsvC7R4PtEb6IbnpCrnH9lW92s/dFO7Os3QVugGZprWvAE85hnAaeB//JloElCMOH8o3LWAOjGUzjoPJU6lU5RvyjJGTTJmXF+Y9/0sA4dBDQQSrsE0knR0eCcg4e+34joh/x1M0PcP5lpH0fyOaZgr8AzTV6BYYAmFQf54df9piw80TCzjEZYUN7/1/ffULQH7SsqDjEfPYFnZabKrbAa5tfTrT7R4TOxQXfNQCnv08H3ma5RfW4Lb5sROIAzaCRbHuiXdHvdAfRMOx7/QluBR2eY/08nkNMqpQWwfroOTKyjN6h/IclIDFliGjwJmZDJBuX6aQ6bO2AZj19kLWOKgws9wN3d5fO/EDfF3eoFmXvVa4okCeloqzQn8PDcNHecWTSIDxOHD3wac35y6ho1U9X233FjyqnN7/h9BlF//E49hy5pSMXdcpCGNOiUAQ7pG25RWvL2veNBa17JbtD+7/zgxuVr5T5jyT0e4Pjq8/1XG5waRV6iZer60sNbij/3Z4zVleNsHghAPMYxt7eEHpj62T84R0iE2z3vX7/PQDYS84H8r/N3YWVw/GCGVh3Q82D8UYWxSfKWjy89QKig2zganH9NJ5ihXcD532uhYIataICH9Za3r515+9H6xi1kngzwX/ZrNCaniVcx91uv1of6m4oYY0o5Hl1dh2HvOpCPHw0uINjz/DcZH27nkSRGff75+/vaHcetArzPgmdFff74i58jmvD82kNirNjba1SRx7VZlSr46O/1NEp9a3P5K9Q/qeBuYP/eag8kfWe/zpA2tcP328Ma8Bu7gFeUHXcHKO5lPQPd0+nbdxDPgQHMGDtwvLkv2lhgXn/97TODNmKXyQEipOQ02a0G+yNxMRSJN3sHMG7BKHlHEz+F8yVawMqENbffLdiA7eYlQ7iWRWdUMi/Fe6H5lIrSC3XaERShdkEJLHzzUFvGzh+cL+eQx5/5be/AVd7JmTa+R4P6b9kJL6NYfGh+zp2s+cgH+O/3cyRuHwgoyCXsNMjPzWdrnPVzZCawPtGEJ7rOAMfHAJrIvvL2n+oMOO1q2P7v92UkLr+qzvfyndpRikJtP2PyZ/2C+wmNELrx9S0yF+U4mYR9+w9Xc3RHrV3N4EYvZSDhfdSPH8R9CJouirz/FrdnFq+vg/VJpK1Zk72Hz3AZdUbznsIB/yHa2/VRs3gf4LFJEyVpJ4P181YjUyGrVcez0M09zC19HgzkZ1Me/d0txzu7NWurGtaHiNoqmgFVfIBTe22UPNkf1neSq2YI69WMwF2S3MrRFoU8n4GtADdnnWt8XjkCZEfcwcc+rFv/YPH+v/hJx+NLJPtCCUwbZ3BtOmMwptaA3/PYYUwAPs1+uH8R0bNgAMXrHn1+t1LRhAX6hz+NNqosXN6HH/izDXZaCW5+1+d/sLhMfZjn9Eitc0ZytGnJDhq3wlQ84TCof3nWywD6NOLrr1bMYgnOQhMfoq0M1qp7+/p+EhsVX19ByEaJrAhhipG3k6B95vlXMDnz/OOGzRnnt92rfOfqQP/moTJmwJx9/Mfd9ZXkLg/6//39XNbNIIq6Vaafdv7AP+4r80nux8MMSl2glEB1Bv7Nmp9Mk5zwbAZdA5SlqstBXz+upqsH4VgfDjwMaW8wdmaD/QPvlk6AUxxKKFYhZqafc/+WF3jNHsf8TMljCqdYPxwyOEmctnlZhNv/ySpJua3p6et8iazjWQBX68J33eliEJ+caCHcwFKY8W1udXKpJsZAP5AgqJJN9akffJ0v+cP65fbC+UOucP43Qa3Jok0ykA+QCBAYt5z/Ccvy2RiCFQzqq5xrbaF+5vHp6w/RQfu4zWCOL1eOz43uCroRD9O4IBErizq/UnMj8PxiOuX48QIumWzngYjdJzPgai/eOL/YQYFnbNy/dCk8KPi4DAb86Ot+usT5gaFUdu0u84H///1+wn0WwTWoaI3uqTB43+WrvuWTQX5z4iSkNF145PHTN/kMryT67d8W+mD+v+or+Pj5NIO6pCvH12Zgf7/535i75ushaRyVBQPcSWPzhNiWuwTTrMMWqtFgftY6NGOUWTz/e6nnJtOl18B+f78v8Dl/W3WOmEku80Vy2DxpqfrKhfpvZIyBveT6IVbh0Oi19vrjD9ylMNGjFe9/98gXShDGvol5ErEsUZbW1OJKCZEz4/OrMkcGY9cY8IPf9Ze2O8PJjDycbvIv9a/gYSQCyjhOtZwodroY7I+EWWQBhYbcILsdhLP2zAf7Dxp7FJPdetbBzezWOePPXaB++6kGMp1dZg0MrixVbDKOU1Sn9ArN+/1CMc8bVQTzww1Gs4OSdZcxl49WgJRxUNfUe8UWxbtkdoCykpRnLVsP9EuojgTcEt4/qPIVj8Zrb8CfdiYuEGNcfvdmJLfbmTvQbxZxfr1ZcPnR56M2T8oH+ysKlvrRWFWkg+8tURJJWHN+jkUI4CLn+W/YEQEZScbH/2x07DruzTPJMfh8XLCvzn/qa1InwwfrhHMHOE/uj897YAHJH/+0WN0RjazR8P7dPTEO3P1w/3a9yEIyJjUZ8P/mqEXgceL429Utasvbwf2QEAHiouP6QKBrV1ZrbaHJGePsaQBRTk88WQDGTheW3Rpauwrnzi3oFcD5/l3mPL7PDoTvjyPQso42PF+Dq3fCsF3w+Fi8tJ3xnJMALo+M+6fXFfX7N2cvPdAnCY//+zbFrcXpw8A+shg+SWVNAyjVB57BLM5qIDybeAL0I8/PXG8/Qnp723e983dsTicu1Fvz3j9/Fxm1XYxIIpKVynS2K/UHjYgklMLB5mN+AGox+yUmfX776/s+iD/ULJdTs47fq8H4wmUGBZgud4P61iqhCus6eKFQM0Cgj84vDzJcI85HdL2vP9s6CY7RSlweXjMdjONh/uJuaoEYc2kmw+p4BrKm18P6ZD1DBV6O+f5+bdikhtU7HuQnU8GY6Lsd9/+7GWdgnD8q/fMTJzBtGypsP4FE4N7EG70H/DAuZ0Ig4Jj7dxtyJfgqGYwvNjWj0/XwU39e30nr24uBf4mRAPdkXvP4tFye37Jyrwf+4/f7Pg8+v9cltVsHikP/Ue0MQ6CM+7/5NLRyczSs//86nwEIf+JfB8aJhp6D9n/f39lw/nxxCxO689sA//3+0mf9v84HwnBYn34RtMKiz/G8K1DrETDA4/lDQPqk4PbVOnrI7FQc4OZrCRl8P7nq9sB5nMfGc8hPFkfiQ1chGuw6ZinktRzoN2pO0IexwuOHpJzvAMTn4fy+7n87n/qQYRLqOflwfp/3zUAqmQ48G4Wfxw9/6P+Xd6STwOG4wV1tbcH5QL+/2z/x+Y2NRGna4DaQ/83fLtz+ZFV7Z/LjMcwvtYnw0NU9n3+Pv9KI1WwsVdUP58PWDh3YqtR5/N4Y5Io3UyD27gego87jG5uzn86Xv97f2DnvBHzeR4GdKw7qp7NFOQNILstG/9x/1fN11cdJFbbcn8rVnvrmVCBCthvKew9GoC5WW+prCXgZx3hQn0UOBXK5vhwOjR5744nhuqUIvr3f7JObDgznTr1++3k4deC7BWIzXgecXxkiNPq4LzcSwDQ7JYa0FSIjmbb9+juuzhuhXD8/7weY+vhovCvQ9u9XfPvXkz/wMAlm8mH+z/dtQ/wuAb/cpApsv5VH92PzAKAUne/vh+BKj/VyehfRD/c7uitL4Hb8+X6kjcFRr5LB/ROUEDZlOGAWNc8H8KmAwHF/fDoGFUh24py6bwwpycyBf8YudxSA2Pn8+/7JXWIB27T5ihtqi2r0ktvB/ZfISl4l1dvt9/ND1E3uYOSx1Q/3Y/J7eQZYqCc/9O/VMGKbB91Rs3njmIwPcFC/DNYtY1ubldTdnVBFXOE1qH9+3Z/R04qGzcrQjLW3s3r94/mW+QxrbPfD/hEmjV4+spDx/Nzn+r9sUD+/JGuPp/qhwwpqNytgGMUL9+0fzg9gBIRJuKJkoYIxkFTSHx+JErZkPHYsqR2GWgP85NDn71i90oJRsV5RWzsCx9gfSD//JXsX6OWqyNdf55cGXpgD/TgqnMHnFZZf+aswPVX9/YWONrMZs8I9RY8EJGC+FQfxO9i1CE67dkHjwsAxugrD85PbCz7g1Ux96hDP2Aj5EMe2NYk4X8m5f1MNJKBIG5zPoLtdtp9nTY9f74/pbsj9y3/+/mEHx4GjlzzUuSkpDknO5y+LjbDReXYVXQf+C7lPHhSXYrj5uv9NipE56D9KWxsGO2VPzS7j+efoIfbHj2qvVMDuXi8o1jSu39Ib3P8nIIAZTI/65Ov9K+DdhvMbr7cSuL5lNVESWWiMjTLAoaJDHbZzvv+tdocUbB1m/fo7PH4uFR5nnC/9et9adw/48b1+fvO3BervT3ING6O87rSuGTGevRhwgQb+UdqDK0+YklvyHp8FYKQPNFj/dle+yiI/PxspyhBG18/9//+8PhvYhJ0uvxrmmti67Sp2PjTvRvx6v7pIh/WXGa3hdGNyPqgWwg5U9mHwPnHH6AxKl7tHk+dJeIC1NbBfaGwSqez2jNLYl0EJugb354/P3PShGOoO5yeWIBlauuvXl0i4SBCoORuk7mGMVRzeDn3/SdicdkxIeKA2g1gAgjIZ7A+s+smxnO11p3VGktPiQzvdQX3mqEBlayfF82W7Zc3ikDe/v59b7B/D/c+jA3pA1DobD3R66B8suH2nlkv8lsvHQsOAjZjJ+eSv90Py98A+2W77ZrGn4kb6fT8W9+0HZ3J7ho9rUjTSvsW8PSWd/Jf1m/8XfLC/8Raeofi52oJ8S1gKKpstv/9+1JkYoNHr+eGH70v/wQf1v8ssOfH45MLW5BnrRojw7AXVC/ekQgYdkUx5RsxcS4RtFH8e1hXhYXB+ZWIYsNt4JiWCcxQ6PWIT6fv5xQcVJMbkhr9/X+Lv/jrCTXkzEnXD1wfJo/IIRvahadp1Bjagdmbov8zv1dff2qRPhvU7bLEMsE0Wuohgd8qJa+V3h8cPgZO7a0j9NtJs9WzE824MPUvTk1dR8vglR8mjnM8zqZE/7xeiCxt834TrB+cLtqCx5vMwK4YHX4y+Hd/f79cRnOtnVVZLxRbxPG6XUKWgbgxRglfUTffRf7GPCSzURk9Ez7BFtCbCvFwstVejumMev04B7//rj9ORlPCcYAcXXiFR6+NfyHUsOT0cwSvvP7c/7889K/AS7JfVx+HuCk22PRUiDRQe+bHTzUkf//M3/jr/FrRy7nyP/9GDFXyHi308kM/v83u27+XHY5rkEliC6sHbP9lg7OgPJxHRVW9KTsuY+O/tQziQ7+FJUhqOBNfUJOiy4/k4pK//Mr7n9zipx7uIGbSS/uDMXP/H+f+IY59iis/d5/Dub/thC1g509KO4q0gSIKVmAe4R6bZWvqGjz8/JawsrLDrt1+VCXepCqImHD0aWJYdG33fP14oDQX45L76uHU+CI4gvhOxN74+riU3MN49B3hMHS5UTs3++OHsxOPdrUjFP/en5unt+/k7hyf3Hyw1GzhtQpSH8D5o37z4xkOXtmZfnvNlhCFWw5bi/QmK8M2qc19/x/vnYy0mttSlNnqTlZSWffmv7yti8dafn7ogxlmMptTEKNnNmbZVHn08ybKR/OItmkT0GguscPj6Xr+/v59KdJG6z5Uw0a/WP+nlL/1/jigZe1Ttn++HR6bc14/wamV2LUORWhMB23B8T7sf9LfcGZJRGqL8Pf57fyaD/Yuvb07q5kfGZ3PpjI2xUvj4zjdou14nDfaP81SBIxCl6qBvtLPakXcDHNucaBA15/Lemyc19igarB8qt+Cmb1tr0P/+ASjwVRe1v7+fDbn9eDInlSP/Rk202Td+Ob3eto1KZoLB81Sxv354dNqOgClh5c/39f+yv4Qi5i5JkaXkJYtCYlwscbC/rpPyUgquwxrweX8YRAa3H+alnhIHnztaf/z/sWm/vi/zOW7W2fis1W+Of73PcuTj761/sMzGyWiccPvQ3+UFaNbsmnw7PvIwWwmSDef339oPVM02g6d5e6HBCeETfGwH/gEeteez9LuW68qqOf9yDuJgf9y15w48qVt9vX+k++uqjxOa892R7pUdDeUrsIRtOmgf8fw1BZOkqPrj+3X+jy459y8Eg1GJJkXdx828cl1icZw8t5x/YQPufvA//rQRyvLarn/AT+tkXcIlI9STXXAAzfHYjy+4MxGD633iNVqAkY+z1dC+A7s9cH4spjT5vC9iJOsBTrajRi05Q91QB9zBXM/r7+NX+kN8GJEJ5MHHtFovhvANk/P38v/8/RBfqn77ddx0QNy+kwqxVYvhbV2XfVxuHCN5TYukwgujddh+Xtl9vIuVQEHTOZfnbPnMGk/E7bf9I/9RjsHSb2c0ft2Eg+E5g/2B7iMos651HUouV2GmJwdx4F9Pn8JGU1U5jcncuADf5P6djUzfDfMd3x94Sz14mugD+z76hZNb45TbzzZsuvI1o9kP9v+Vv5VV/fV+uTB+DPgJEnbNCCxPdfX1PgOeHIfrX0VIh6hqnzSYnngiHH38jzNLpExpOYcizYEnsPWyvXy/vni6KEHZGHn71T6aXHh8yg5wVkP7nvTX148YDJGkHsl3OG17+No6KGfV0vn6veegA6uApa3ltjAmK20wPzI+lm+Q1pDRZE/QFJJG1Przn/ngUMplRf7crwzTPg6vOJmXt7l+/cr/jGoyiD8Ez0oBSOv7+uv+OVgsBvGFzOY7kUXzz+/rfL0v3gzjT/F5QdE7iNbX+w8gYj/px1wj6JKbZPb7h6VWauCsVNyfBA0O4f5qapCKndjIow2PH5fKCpmXn06N8vk+kOwbHv//aV/8rv2+feJoDhPYrAO9Ub7eB434+P/z+GS4CTo1E++f+J6jMgbXtgpa9PV+xjNt/hGZhMjrErEspi3nf1ljlIK2/If/fPB//vUb/vfBSfsoQ6BP7+L3+L/Lw3/m96v/r+/fa84/7EeB3jCH1aD/doNSNjHTFyXnO5+fb/8TH77G7wK/XF45f/39vteC79+LFFrUZht6//0+aNkOxhcauU2JbtO/359xfj6PjLUu57x/bUJtni96tOjh388PNThnYKU/+zhWuEm3vkvvv98f6cxv+NVHHm9DNmZznecPv/YPWr3nTg9Hqvp88xny/CUcU1AayeNI+v3rWzpn+MX5oeW8oIIUKPXl/338/fzi2/W1+vLkMGURe8ZFS+HNhyfMnd+38oP8xfKo1Qbr00B/v74vA5M3j3+tl0iO6HL944Vb2mVgpdK3/usb/f+38VPuH+vzQZGVw24g//v915s00B9YbHUwbXl+GUkdyklipaCH49NxB3kqK77+fL9qDuX/rX9oaj2cLK+vBOaHmq/f1BYuQGRi18PRUgV5+by77dfvL+Ej5fJPdPdbcjcH9vnr9y3wzuH+79f5HEzXAxye98LZeI7Sfvv/Pr6Pf+vNb8mSAkgRndLkkaATOrG0v/+4/yyr0qzq1Q/7/+okFVg6LvnBvhXMHCgw7ZC8sxVkJFkP2sd8/qBkVbX/uj+iLzbiAM/OiVY6y7yg5PRAGNdV2t//OL1Cwjw75/zqq35Wc/+wfmZ6KXgLbl+Psl2w57Sa9sf36/fP3HHI8fWFuTCb1N/wu1/t75fQgLe4Ovbxg+siGBU617845bSUekH97/z41/rOBaawoizlf+f3Pf+b3m9f71sIs2ygH4SeAionTK8prjuMUZfz+R0Wtae4yZkW+NxMJiyN/36f+oP//Sb//zU/NX2yUk/TC/0VP+BNnH/rPwb8TnhBH5qzJy3QdBIfwUZmdR93xmcJyCL3f1jhIbW0Y739Yf8mpGnKBKTbP+8TPI/9/rEKWpcV1f349X0mEtr5YP9d34kBXpgtKNS4F0VtbQ1wMm3OwBul9tf7DMi+f+8fB/z41mp6qZQxLchSgyYzD6I5wBdnUMrJlPuXr/MtjW3+i3/65+9f8CxsLfj6vP9nZkvBE4Q1j7/uKRslgplR/bv8bWAfL07CypW7lpr24govg8fKG9xnhZlb5oTb54mWbYkE0evnd4IbWi5MOj4/Jk1N5smHd/NerNEV3z2z7LWP52N6gc8dQ62VzHl2+bwP1geKFU+V5bFI29+/z1Lz+PSclFqiL568/4WLTBZuufyv/MTI82H8AllyKem4OSTCV3535eu3Rmc9AfqF9t9H6/HP+HQbJwrIOO7LrQ5Pck76+cE38gP+SrSzkhnlZ//wZk4lbs30z/uLHY9/RULdOlKigX/9/f7Eccg/vn5/pmgf1HYmPGSVydD/hi/oMMtI2df7OXAFxX58Iez6TErEU6Sv3ycgpszjT3oCetLJQq9/t/39+0Alz1+MAuif9wk5vzlfacVJ00JsuuAJjsI0EQf+nQ/hxJSW2weILjw/RlLVQURcpPCcnvMTf1pKpabluP11P5m0+4F/JUa286FyYBcabQukkpPwT33mV/uCDG2Y7evZn9+/6gbxDU6K1oWqDg80KDoef2M20A8J16VYum5t//n9PTzQDyTRDrF3FyiN9vX984rr5xLmMPc3n/i4Pix4vL9POb/2FXARtDmfnzjphATEkOOxOLlD9G665n1vhKWh26n8vX31+PN/xgHczlmQu/trPKjv2hZsSfCx/9qbgVJy47hfP/r1+6VYlHv+J/6hvvwUCh96gMUVCeznqJyE5oBfSeeU5F4pJXpP/tf9T92DEvdPriOfxeVqgHt+LnRgT3j/9eHM42M+p31+QOQSUWQIVQnt/UFplDwZ4OZsg95Y6qozPMqhW5vmtff90/jr90sMU+Hy0iF3oLN4DObPTR8vSHfl9msu5VejyPfEREXd8nzJrwb1XTcB0nkkqPEP9dvmVYVKkphhX3+/3+e5cP+0dsMgt8ssGqyP9Ob+Edz5/r6dshaAzor64//1fjR8nzm/ixx92ppnIejLh/MnrNGO9eJL8EN9/s/fsP2/eLq5LTPFWPn98f/6fSLSnfn4Wp6KAWGc8PmlycSCdFV9ez7g/dB+qQTPBJDQN1F4Ssbl3G8H8hFne20kXrl+bndK2ENzB7hWirYbblzYt5/4yMASkEfP//f+Bv0vxi6tyfaB+uNDlg1mQn7l9helxYriXL7/vd83/vr9St25cv1jdlOSlqZmv3+ycbh/Hj16+rd+yG/KV0Vc/KROn/+bfsL90+Jz/uJr0MkT20YhDCbxu1SL4nv9/tB+Wqc4dyPTuUNlIYilqdOBPJpUlAaPz/cuX+tX5N+2b/2wfhvloJ3fWjhYX1eu4Yq4DueHs0W7qTEd+d/If/aHV8x0nv/c3B/w+b2lirW9+P39ldApjmHw/xP2bU2r6r7DH4iLoqDAZTkoIEcFBe8ULSoKCgrIp3+DPs9e9LfX/r/OrJk1TyYlTdMc2jRBYP9lh2MiprnNqfPzb//DDXw/OghCznQd9X37epIbOezt0wtYYICyM4b4KnvEN0wU8E/iDE24seOYmvweYw1f/ZDa/wxXbA2lFResUqXkSJYvnrqfWj27yBuR+G/773O/oWezGD/32n/cX0VxigtrlMxDZVeD4drtU2r8b/4+V9jD+em3SBaVB9+f3+8yK8X3qT38vhxOcNWfT+TY1v21oQXEHvL3x352IcGbK/iji4Vs/wf94C0Qw61ai9J/eiEzStWfXzrlvtE5tLRZ9fFOO/yYihT/glc85z1rYmuKJzUcbg2fgq/2aZjK/tj5D/5839/dH5T90O0I/DuOB/vHjot5I88syj4o2o15iowI9hMZvNIYF5vSv+ZoIRfK4wXytc/rZ8SVw/zJydc/wG4H8d9BsN3YW60p+zgrVsyIMY/AfzshU110Du5/yPdPfn5CzU8V9lIuzh2wX1bAzxr9coHxv/2hLY3iT7cMfWMe+ED/W6gnRLvS9ulb36Abuf+yD8ppBP7XeJaLNcstF0P+6E8BK+qpBP1+3KbY1zVkUPrt2/+s9x9WZf8aeiJYQ/316d8ivzPQj8a+e9TSzrSH8E/9UeVUDPwLizof+P56/fLcZ3Fh48siUZY5LvHGEv+qn5z/0H/b6YVBzdG3E+V+qEvk/w9+e0pcrHSY4s/P+7iAFXA3NUKsRFt3OH8c9uezcgnxjXjPq3yaBN5f6O/53050zkOlDfLpeI2YKkeWOt877cQVeJRX9z/O764JbxUL9gLfP8rtKo0ckcLf3CNB55+1Tuk/K8a+vM7B/t1mlZ/OJwylnxfyGr9xk6z783GCdKnaUvrdy2T0FPXT+vd93a3WQ7zOvBg1Fkvxr3mFtuEQzRnO/+PfIfMG6/vQ0LhG2pVaH3nHMeC2pjD+9/7RuLlD/FlfpVLZ7gbx89/403//HUVNLihvan2ULpYVVX8N5Otv6/O53zk1S1BShiv+5DeItP2znFQz8HHpVCoEIUb6tGn/xmJ6V/89oecf1vJZRidQTrVf4EY/3Kj523LI7EXSnw+5Rox557Kh9sdP/+MM8Mutv/LVjPubfH/u/0ahGcuB6lL8PWloJPkHGP/7vmeTw/iVf1piAdHny7dV9/I6s3Kqn/3hFhS8STkSTRT/b/vzo3+IcEWoDBZD+j/9GfCrgP1xzYNNPn01f/NPPvrp3MhYzmpziK8Eb+bEnFmg39nXvC68L/pwfY0qgfjz2u+/fMuVZHrF1hD+05/uCfgHx5ug0fE4+4/9dTnpPPdeeboob2dpmRLGoOY/UojAoTNZJD/5DXVCwSsvVmPL98G+bJ7ojtR3MR7KhzztS7mItTyk72MfRPMB9oOMLoiwI5GizznHjIyaKdC/kNm4MRvclgP/c05y5so83hDfJ8+yQ2/tjIf717xt0FrcnXv+F0TUR9szN8Qf0M+0KiHMsUSdeOSwml7PtH+x34YKVoknV4oY+K9Uc3xq/nMjWfjzbEXZVwu9GJl5yRBfTx6FkirxWaP8g+1aujPPXQb+1W7/jEY31xvi/9TH17MaZ2vWjdVdalPy158fofQF8fN6ZuSFkT0W1PpfMXORHhOt+3m/8HJo/+XbfxyBfndC8ZwunPFiCP/pn3nMBOyiyi7sGFH72wxuWFRwqQn4tk5k7F1USv/82Ncm4/DuxFqNF04dSn6//WkToC/pkKCLI6QP7b8ZO8B0/wz0xbNgE7ErmaJvIeRSx/CZVmN5r07yyW1Cze+n//wU/Nd908iNNR++75l883PxLAf+G11wRm0yRZeBfOjZkzElpT/fSDeg/0xVwtT5Ul//R4XQHmGzsN3UyQxqfMVwcSWXUYbw65xg3jgmBuVfSC95pwQK+F/Rs6x0Ls4o/a+2E3mDLRn4g9RUb2bX5ZyyD9szTtTaA/9udsNzsMSJTZ0PfM+XBOCfdhOmaDp6KEP+fuJDSX2CfHrpRfRG2YqKP2ZvThoxB7WXH95YFlpFx+c//cdFwO/ERm3sRJQp/fvNP1+FHJ6vGh3iedWk5EPicKiSGdA/VfNJxPlH6nzASJeyrRIRvv/0uJaI9vB9I8gHl0pXSVkA/1YpKVHbpR6rrFqnQ9ohefz250ZahMvzns2le069f/v5T79//8DVrbWssF6FDwp+1fpu0pEfyqs5vuBl65f+IvWZq+RZYfQ9/2Ckgz+sD/BT36NkI5wQdaKPz7qvKe8r0km4qm6+eaqZpWRl2ZA+9di+7ig4VdT9RV5EXSTtDYr+OV8oc1mYw/f9AqG83dH1bX7eJx0A7u5YzVDOFfV+bjD+JUBjvZtevVCdyZ5D3APb/gd/phpao+u7E4f3J8GFE6LxOYX57dljgdoL4bzpN38+Bf5zpSHzngb8kU8eznG3t22wz4nEiRfur+ujNsP7lz9whbMbK73cU+p+6JM/JkPUpA3wR1/5rYG///f9Pfn/3M8TbE6LVaOcW4o+1nCYmbSPgP5mhMbRdHP2ht/ne/2Gox2sv4zJS+eZ4g//6flJM03zFSHyNNmp0yzl4nxcd9/6ehbEn5nlK7zy3P/J3+nn1/e3FFWUBfhWsnIxzw7U/HnnpJzl+YMNcNyKJsTPyM/AiZMENFXFh68QSRLE3A4DkIZaypv1c5Af1PzWLxTDIb5a6kqAmznOhvh1mIv6pNz3+Y3g6JLI9W/+3CbKTpGWmYeRdBFqQdnC+Fz1mhPFim++Hp8ZJIos0B+eUqPRyM4HM/sgJvIEsfRxIqEc7ZaaN6T/D32D71/d/j5BVSn6zWkD9isxWA+TJhiTd2VTcKvv3yVfJKDvyl5GHPc80vu3/760q2D8USggnb3ofqheVKzgSI2mHtr4sEJ+lQV/oQ/4//5D34B/XvG6gqsCjv/f4U1UM4hh8Wo4P3Ubq4XOt33+nOLzaRTb3m//jznIl+NYXM2mMiUf0vImdeJegPl/33dzmII33/NTA/gbPJJFOlMTWL/rHBVkOb50HtqPsaYqS8A/7OCz+ikD/jQdNlIwGLGvTg6oRPKD0l8yLj0GmdfkSPm3E0MujHsA4y/FukN1Lp587bt/MND/XOz7R9lXoC+ugL/LvX369kdUtmt6/SOdVCQl1WHIH5IlcqytQsA/thCKnys+9nVhxixFcwTrY585oe4CAvxjJ/WLEC5xfutTrmB+XOCbxoLL+vxUxZeBkenWNy9bRVO68Ld+rhVfQL9tfWym02lz+r5Pxtsx7P86qdR4trlBfPt9v1IFk/q96lApIa33D/ua/ZYHcNVUiYCq5eVWs31+MTOyYf7p8fLixjPiVWpWehLZMfmqlvr3D5jtwgF/K3kySu20Czrxr/qx+rO+Q/08f5QIiXrg26r5buPUm6tcPa2A6Sjs9ddzFYzribn4478C/k9/uxrg50k50d+PM+A/roRBY6kmw+9vTVaOjcUMYrouTWO8fWgG5V8f2dCfPxsvkV3tKJIIY5uK3z75m/PLH/+Rpv/0KhFpZdEb0tfxcyWT7R3QV0DMpourNzX/sQyOnfLUQD6PQimSxiF/7ocA/vYs6SmtGNCPn/pY4nVNzZ/r63fJdQVwMYz1YnFZ+4nM38gNOWNhWjd9fQ6MHlqA54nF6ZNo59uKsU23+D3XD3VrPnEs58fh/q6U99gREQ6JONQPnJ+PI4acYHz1zUTovLiwtdT3h8FLQxviD+n/gz/ZcLzezjQ/UX0E8m8sgwfI10jZqYLa1zeecULOihY1f7avD60sJJDvaZqZhi1cAf+N0RtdWvKuu45DS8lfhx6+v1it0Pcyhd+edeD/3QB4eazmjTJ9e4P1q6ff/hmLjOCLkC7jBWjiRG5sryTKXL/WbJLjlXqosj0+e5lVGG/HS7DDp8vUaPvzsj7+gOVnIf46p0bsPV+wPs9ZmuKY4w51V01hr94bmB97YGXekdnefoPjk3L/k9/2ke92MQb5dFimQtgNKf9nuxMQaV6gC2VSps90eaqo9w1ipO1ilzdAzDvUrPGkb/Y0gCdnNCb8vXNt1RojjIwqpsY3mrLzuIjxbAhojw+i9flDA/gSdc+oTU6uhre+p5KNb7+HcF/TOZ1LI+c//LeNK84KVeWcUJms6yPZCgnlvxlLY+nPrR2M/+0PPsMUf/rH0IYnrN0MLxTY394mpr7viR4TdTai6vcO4AslEBGYagf851mtk6fFUvx5p0WQziYrqj7vp/4avuawf22mrLlJ9aLqB2trVbGVW+8/W3Iip0oWUvXZDF1QYjW8A/5lz70gRnk6/0Hfqysb1LJjl7J/f+C3d7JsZpoI35eSJkhlZh/WoyhTsFLqfX7OJsaFrl3doX/V1K38kB/993/9R+ev/iX4p2NO8Bpn5w79A2T151NPAvrJzLBaaPjthmBOl346nVnOb36IFO5/6pccJoDvtI2Wblz9VXPf/tuYJdhrLKEerRH4l97BqYlqH6tamkL8obYy+I/lHT5oW0dHw2FISpIf6fMbnPFGavK58x/8OewvJSf5gpPJ+StV8OXN3epR3/9KyRHQ98/8/+o/D+Da3+FPqXFis295qVzAiUxdZX+v39/6hlPQD2NetA35OrX/w3/mnmxYWIe9M1wfpEN8gfAb+BubceDrduv8xX+vQb7MHaq9JjOd/xj/H/qH7+MG9BsHO+RV0bQzeesu1+lbUa0h/uKoN/qI3wA8y/EldVt9PLRvf+an5JPGTkXOOw/h3/qMY8fWFHHmlSgN8sdw/AnirdQ+j21NtZV6jIRLcBvif+sXJlvgX8i9cpTEpVaPRRsnuEW9fT2FQX+eYWfqZAY7R70Ez5rt7+fFrJevb32zvQ/jC0zqpejojb/1Jfr34UP61VwjbxKlmjyUL0HkykgM+vlXwhFGPUF8yKmsspCPCuj3mWPLxiyPbPiavRTxTX8w3rgYYUY1eni2bRbN7Pyyh+snKWO0ZWQB1venvmWuZeqyevFEebOU/hLYmdXMGaO0xITBR8ybPKUfvvfvOIH5h/cWp+bI0Cn9VoZerPA3+P5217ipLsbLIXywfm8LiSgcZQ51vnwRTV4JXFuTpxn49/sdT8EfemGm1lEE/t72HkPehUHxz3olvm94WztTzi62seFUy6/+k0MV+L9WkpC3PR3oZ07eAqlFqvuusmEuTIEp+lRfIjkqpDSk9PuSV2JT7Pm7ENEZHAs++vv85DZBJZn6PvV+hpnup9yozmB+sYWeaH4QqfGlOsa+bbUA9+ImTpNDTOWnjg3fS2X7DfR/6x8Q4zCEy08iccyln78tpEYayOnRd24AVQ79/LVI8/FMgP2Hk86r0Norot/+lJiST/lwxkpab9N0OH60wSq/SFqQz1VJRHLz8fk/5v8kqZMuHuKFur//1vdrevr8ZpOC40ed3xSk72BX9vMP72hKrhuN+n4cVL6PyQv29z70FSzNYmp8TxPeORvB/H/6TyjV1be6C8OJRT//uMwMrHUwf3XskDGZyMXZn09vWFExPX/lvW+Z9GYXt+H4nKK/iFAA/TIenTJsnnzqfdX3/tsC+jBzluf4NLIpfIQ7gcAeB/g3PgtZOr9VRWL0NioYX5g8WVQ19PvHAX8n+BUR5PkU/td+eqA/lO2OeZC1WpW//SmU7Nd+5CD/P+drAVv4n/cTjEnLvywzzzfaeUlF3W9UHcc1LQfxjaKijhx9m+L/euaNcmSrfqIoXRqAP2BsKf/ik/8lgv6Q27y33wfx+ff54d8fpX/kdTYzFgEB+TgtvA2ZKSFF30/+qgdwPTwFaXGPqfcLa0d/Rt25sn/P74KMGv8+3T9ArayBP6vlcotjKX76Nntn9gj3/AtE3m1kEVH1TT/7R3b6+HYaNiEEObkD+mnxYhGj+5R/udH2U/29U2H+Bc/UpBrT71O//Rced6q/yqc/qOpOQX//3/l7BNdBGKTqOIPxd1r9JH1XHGr/JsUKm3gH/Bnd4T9Hzabg/sFYpAvGcCtlcm0VnIxs69/+e2G6CebnoJ9jsdhQ+xsCyPxdGeDfy9taJnvOMKn9s/BGNRfW7jA+GvpPn/OTyxHi280B9IP5KOIhvr4U7UYRFy4VfyoLCAXHd4j/z41v+qZRucP4r+37Q6rpGfwXd8MbDQ5N5z/i53IZ71LPX5gJ+IPNE8svWv7QBmvpXNzMKjk02yBtQBf8+34r3zkJ1lqUovuloOzjXdIlNG2Pjo1Pmb/A+9Cmzmf3ERI5pD5tURXjeouQIWpDOGvys3TBP5z/4F9V2GAhNqZTqWGGOrSP2fCv++s/5n+QvZpj5ZVDnR+YDfjvTn++QlaqpKMwdSj+zk1FwW0D8mlU4iwG4bUhHtfwIn1tUDAcnwsv77rJZnallMlyjGPlMqr/5t+JyqzzOiQv6vMQrluZZVjC2E5wZ4H87ouKsv9f/9U1bVs1gldL4mNJze+bHzgOAL4aNXLaBdxpOH5RoSpCk2A4/5r97q91f7/9qe8WRUD/JKoRmXhnpm7eL0ZAy97/+vavsV92paptfSfXLXnUoz6/nHmx2a9/eXjB/HYLfAd5sZK6ZbYSQZIK/uO/v48p//n/oq+HT5tomo+OL3u4Pl3tMwcG9/7f9CmMouaS2aJMmjpARVrQ+qe2jmi8cqwKz/fHKSg9+n3XdCyajSqWLiunFvbTs0ifH2zD2OHxewL8ediMSB5u4VL+47c/ju1oP/UB3gUV/9pzfUpG2sITcTUG+9wFMWU/BKyXOqOtPVHd6BJHFES/DxGf1T11Ys3SFHnqCiQOQmr8VR6ahV6twL9jH94ZGVOR8n+5izrNu3hph8pddWuymcfU/D/39+pqBvbjW5/Cbih89pp6hm3tVBbfrucs7Tybsk+f9wuOZuohfp9cES1OGqU/1ksV5KXIgf8zxtshhCJnKL9L3XjguXOxRDm1mROZrFZdPZJtmZczMfwjH/Zf5Get/ZEv+y/2o4dvxlEa8RAlVFg1QD5Pqz21P9c6b8TWFVusetAPCPmThLr/kzPNwY4WWCwGxb9NT5OCsu/pMUn7556Az2xSG+/nKTV/q+wkIoxsU5N5oa5QgTOK/4ejx+STO4wvC5piY3XC5hT+p/9T2M8/iSE+uYzYGYW/iheparsw/xnsAIJz36fW/16AsuPHjqjci3SLu6Sgzuefx2gSIaVzbDW94hOeTw3Kv59yalRPb5aVKbN5raBnXVLxq6SWO13c8ABvnukUr5BI2QdSY5vXJhrM71w8BcI/NOp9v6uqu4hle3itYh1XK42yH9/z0cMK+F+Evo5XBFPxSXBLXWMx1WD+rtkm2Mkx5V/euHJcS2rgJCpOnTvqWHp934ImQ1AXGYk6yiA+CFWD2n9HzT83yktbVLg5HG1SVhmF/72/XorgX+jkbaZ1RuM/dprT4G0M+mOL/Ri/k4qi/5ufFIluIt8DvMCjNUu9bxNvwpZjdMfK5OX0JOE8ZTjKPu6NR6pqYs8fE+yL9KDxlTsn5WI6Um05FsD/sO2Yok81jB1emAeQ34jzWtRNbSr+WiWdpHPz+1RlBOa8STM/pOKDh6xOI1F8ewlucjQi5cGn4qdvf7BWhf235FyWVAaaDOl/tcaxma/uQP83vmDp80/M7Xf1KOkWIdY9MkGbG62/965QECFfWRnuXo2ND1pU1aN9ykQMi0OCwfGzsew+rFC1lr6cKnXe/e18xx6eH7F/9Me/4ZjSL4sohqCgUy0Nj7pXisKXTfHHETOr0WfI0tRTDfRLjEbJ58XlFUPrJCPD98MJ9j/OKP2yI/E8XcSSrql18TwTVGNavqL9FLGqDv7fNz/+IFL763v/it/gXxlbbOFHyFLxzTWqboUiXIH+e+cfMV7T9/+dvD/qorBdQPyvOzW5jviaWp9FuSXckjVZxVq2PrjadHzCalWaKszD0mR7f3yRy4un4mNnFiDEu8SuZB62MN50MSW/+po3jJkpWQkOOWyludzfD7CmdEX5tPePdHTXmzJYwP7i0ZHIcRAP13fjqYyOyFgL5dfrdUO5aVPfv53swvDW2QLkT8R2enqSkNJvLyMq5msG4JpOfDRaZsoQv/WDLuogQqzkTSer6ZrNqPh4SvZPIr1elqgk3eGFIN6i1iezLyXh0/FClFF6ynEw59jh9xdidCftMoP1WcqNnh6IQe2v1dHOfef+AvjbB/ixiskQXisWz7ElA/L3yFMF6wJPnb9cedJ6E4FdsGoRpDGWZpU3hPNb7dDYhzuMP+mT/CrxT33Rj37EvhK7+9esUpK4nhIU0+cXUtZBfDeHMEIRD6meCnZDnX987pe8eLWwf+o7SjyF/7oI4JSuMrB/8x16o6RpqPmtNlqKZdRZIp4LQJ8lNJR+zaRwVuiHJ8SbDgb5mjgGLV+l/tQlbWJVsthfMtX9fckAbhf2ybfl0rIV1LRq2lp/6p/0cO3Mzww7uiBV8gPgxtYLKfrO7r5BkwzB/jkvCUM2GyGtx+VbQmI9Bv9akxK/sMXZIlPqo4tJJnLTofxWYJ050X8arDpWXiXR64TyD7hpg2N3yukZnj68hoCHS/Ev5/1rPH+zi/Anft5VlP+23ucjbxxdQb9OR/iUHiTafvlBsyvMY2LZeDv2WLQZG9T8Lgcwam53NlkcL9t1Cn+j9Hvs5ryHzLCv398SnzCvioq/v/0RwwfQd3EaHWfy/9iva18v+foC+vb18pE6Bqb2zwRMGBg5dZbJIl9n6LYpKPulVcEISW25yOSb4BCiZBrFv5lYrA1srRfgX5UY5I0X7nXzmx8J85+gbY3e+eJP/h2l/7m5+uCkNjZFORiRjpSvsqT0x00/RqAkTFHlG1SinWi1w/X9Hd/6D/+WZws1tk49f4+sF4D9u6yH+PxIqFC7rIE/M9s/pZdXGlDx8ed9w/iw+K3vFGNq/7MKdpr5rTCzn/o5R5Hyb775W7Mj0B8n3pNsKmP3b/1TYAviU6bZpvwti/6tX/gj8E+zYf+v+/PrAfx4ZJXGuUWiwByrOiWLNX0+3VzIJOeZ7SxRogPWUkVhqfOT+Bjda+7ZLmxw0tIKk4c9o/WDKiJUn40ELyNYn/vMp/RXXHFtPj0RJcSLAz6kgpZQ/rPU+ZohC4LByonVrNPgFeSUfC9KkRPFo6mpt9JbokrMKP/XtgJCJHlmhmoLKgzzl4L6fr3BYC+cePGX+7N+/X/h5l/uF3t4BQF7JD1LGF9eHZ4oKW6o5sRage+5GcGzOQRG7koC+lmXeZP1taT8H+RfKjTaemC/xQtOsN0Z1P5Yk0ub88nSDPEoqCcoVRpKv2h7i4masWOEGKK3Jxp1PLX/0JtjvDZTDBEvVqdzuoIQcPj9XQci6aboT/67mtbiNz9UyPY/9fl5YojqzntNyTtXzSH/DVCj3Mjo+4fktW+l9bOivg8O37RGxUJLsGkQQjTDE4b4jRDwXDPidFudlUglrJ1S+ok9qCIRpzZroVFANujJdMwQPzK6LJeSkVnJOgv272A0lHxr4A0a3sowRDlbwv5gmZQ6/7o8LYE0lq6zeOumYdreVep8yDlj7M8PJwPsu3VCeD3SpeH31ak1qcXHCeJv3UQnMjNp+/XJ73JUt6+3MFUOGIkmlT8kT9O5gfNglindzNMIO9+PhuO/i1LyYI3AP51p6RzLhnWrp0moHOWZx4L/mxV6o0tv3VakFuJL1swvw/HPd1E23GNr2LJ3eU3I+KxP69GtYkoxcnr9+dEv88qo8Obo8URYqqPf+70lwJ35fgwW6ilZjGqkAi7G+Xg4fg7aLnb9rSYqxbExMKnSf+qPffT7t77kRq9waDZVyvCEip/QC00jYczMQvnaNE16/jxd/wMXylLw3tMA/EeRoJxsJeLXYt+/XbVmEF8ouoEL3VDBxbqW6QmPVF9v1DePE+XpAxzk0cDmBY0GDzSawfn23uXqvj4A/ot96eGf+id4Equ2MnucNpgTPOf3/n2l/X38If5f67v+BT77D/hV7tO5Rqn6H/mxCyUE/6vEg/5F/1/4cP7Pes8RdO074v0VX/drPufixSzBt9GJx89t0NZsZjE5EyxA/r79fyz+n/wxG/xgZfSY5ExxPJ/A/kLUvbjb/5yv93BjIpmGOk7P25/+g5ujW6ljKZVxUxhj312+R1upbVYHPI0rPzbyyz/n+z2+aalqqhQLZYKDGM99Q5P+yT/r4Z/6SeIyv8hYvqdyascvT1RkrVmkJs+Of/vX2e/7T/28YOVU6sxq4hTxPsDrGQTV4UtZY/6YLn1rdPyHfg1PfWuWyFi5XZQt7AfgpxqJ/8y/h2vRkw+YPVFOA/p++jtM0vHf6RvgD+hjbDC38nvsVfI+JEe0GGe8LxfIeKn18z3qm3GsCvfkO0P6+qQSX57GyvLf8J4/f4X/3m/x4yH8p7/gn/dlPf58JzMlwx/Ozx/9mCB7uP6q2o0l9N6sWjzPUeVx76stqgfJ7/C5sP95nxQr12991cnS/Wf8nn696t8zMPf38+f8ORHtIX887a2nqp0oLfZ4X8HyfPGPfHz4r4ScjLhEkf4tH5/x//D/U3+MN3M7UdVV0/cLB/rkzpEscade1thc5ihCegn88dxjR5JNMfadKBOQRFA3hA/GH8Affldyo5NqD78/UxeoY+7jYIb3fVFYe5ralXoUCYsgmBn7ZjQVZuhA1CF9A/wBfQK35zhxotnU+nCSZIqjkTr7N34PH+ArO4/RxRZR6+uqsurLryPg/2t+PXwwv01olfkUKc6QPsM/ok58HroZdrIqwMpoYw/zm8S+PpHCMFqAR6a2wK6W20P9p64FsJdByQZY3dQN111sO4RAur1ju73I9ej7fi0Io8H4cvfaTJHnb9beYPzxOJhEI1en8/P7+gCygVgLS7Jh8Lgifqi88nSenht1Uf/cT/GhhU9G6sbyxvCG+Und4y5txfYZet/4ZtT6ff1JO11gXbHAP/VsrKkXAuOfxhfeG4Ul/X6AURlTxCuAQ8zoN7pZUflfn/sbSbJhfhs7eHPjwnH6N1XTDWNdjt6v/b2wP+9fxpJP5V+xzUaCMbwswvkoWxWL/dEbjv9OM+ShcZ8fq3jlOxdnMfU+4t3X95Wna4A/9tE4GjsJBR9lG+WlIjmzMCn2Uj2ObYDLZ79KX6V6qCcPCfh7T9m+voXa6ex0TuXfNd/+oGvN+j0ftD0N3MzlHDuXwKon1wj7Mq8C/1cr752Ptyz1voN99E1ejjbgHw+xatijmBp/3L+PwjUb6thaem8kLEyXVYxzLRH97aX1WwehZpJW03Exz6uab+6Af1+TOwrtYF+jYyetmXvfP9fIOEZvpoSaP3dqMK/urwD/3t9Lg+/DfvYmO9zIVf99ZtUsC4O9D97/4BRvGmYrbs/w/UNaqLybsZR8Mt0TxxCvwfzeWebxBh55rHqbLslcce+zeqRY4H/MNeDvyg0A5vsUftPXRxODMwvzO4cBb+QJ9X5mjCtZUawa8Fk1GEfs7kHhswliAqbJMv17P8tt7L4+c+GdUWbs3RpVvpLKmgP0hURTU/2UA/w+bvg0G1ma17zeSiYbNnzfneggysIadDJYr4x0Fhd6XTNmcvRmYf7f/leyTH1f6O0rviEIPZyXpvLa6kblj/7kx93g+zXmPd/leTeUhQvOUqPmSM3KstQi3oH10cK95E3SPcDTV9qm75Qc6+m3/8cd5v993/PKAb5ju4IZ18dZ/UsfyHd+Mdx4diSUfPEsBv95P4Hxf9ZXp/IXP0WVJFsE/aN7EHS72HQ1nPVGrTvWVj1qeQahadvDoxj7SuhT8+O+/V/efX75SG8Jm6hU/qvwrQ9ggf557qwXGR3HDgv7qelwW5d2Pf7Wl3JZD++UPVez7zXAT3KfHwgxeD351jd6A/9+8scVGD+X6yuaSpdj3eqGbMhBA/yZzfM34uQ+P5rEMJWNiS41I40lCbkhfH8MjhMs1YvSP5N5olRyHIL+5qOyy0fTK62f1nvsypMuA/3DBlXO5DKVX9pdVYmI6Ar4eKsFsZrcQD9qeqvj+kq8egyO4QZMF8CjE8ejZjKC8dvAj7G3R17N9f0hmMIE/nJJOUFisLdZRVkjjGZsYNfctz5JDPDv+/pEoL4/3T2YvXSI/smPflp2pqRv5BIJIRvCzLu0FPGjzz9Wc5SPThJlH9rRGGvKVQf5Zzmhjhie9VhFtyC+X4y6bf12bfCfm3Hf360sJ1Gr7UH+d9fGx5J58eu3IqOD+GgB/q0/snKp/TvKXjiVg35/Jam9bmYQI1L5zfVVuiCm31+I+ErsFaqjKaNbc8fooEf1RHszE9TwwD+LiEY8i5+U/L4tT96oZgLr+62PbmSU/KF2rDyU0VPzsOrjoHFjicIfzwJlLu/4vr83m7q8tidOpvDV3UCL4ziqxb4/rCLmMP43v7N//zj8/qvFLub6/nE3SX944rYvCXG9EYucRZDPH/vZgs04Pi02H+22HtjfU/rCdVYva/Fb32AL+uvbf1kaeaF8wfUKNWYZfvWXqskA58391JumB8q+gOgoK9mt/vQHXIH9GG/IhSw++qXeK6H8jAGO4rLzWkug9LvqbeRMQR6M/xT0aS55pafJeJou0jSD748XrhSI8632T39BCeSz4/v+Z0+0qxHT94cXDJCvu8yNuMm7z89E1wbizm2wrtv9WHoyrQH2/ae/+//Y9+/7lAzW55tfBUwewqfbEq1F4Qr0NXxhGvNXR+kflBxkcP5VWL9vf79KA/14WyAGnTcorLn1VX7JawXWD50qvdCuW1o/9vW7pcm5f7/yeX9W2HT+/3orr3C2A/qeS+wY1nbsakqkkCvaRGXyq18U0H+in1g+3h4o/OlzrlSg2mD/skR/kP6Mi/LvAPBQ8hb0Gwo8VLdviX7/yYZoJql9f+gssIScUytKfidWJE1EbQX7o7qTlhvNa8o/k/r615JzA/p+9C+h8tunBZEL1fJ7/AYWXi3uTiavL96TvC+6XI+DBO3FTOvfz3zPfwVqfT76G00WoH+V3HZ5EDYK/nl/pdodyN9bE6porE1AP0UrLyJH3qh882BIByTcQD5uC2FEmFGfnxvPj2+iFH1/0PQmCci+Z7/v58IpyFdZ1BkyL+Xd4/v+FczjBv7l932GDv63uh2hJcqu2stXJhJe4T3tf/8j/s23/ujX/z5yFTbmekPD1Q3MY7/t8w9NCHpEtwP4OHB1dK2yyrfCTCoZ2HMRFqeN7psPTOUvfupnMp3Svy/77P+tTOV3fur/M94W8O+xNyLNlAX69wZW08dUzzzU15dBej/+syjHER8Y8H3fWO6wDfbE677101cwPudarT45zYE/GZfOsN8k4JrOjtJaKvv3J2+pbry3pQP+LAenxevrs6txCvF7vqL4o55N70ysd4WH/Bnwj7fJhCQzGG8Qv3zvVx4I4p/jsiaoauOZb6xn4H+KLDuMn2RuBTZTdQPkdX/ip8H4m7i+oPs5NYbff09FL/UWDMCXZ9cnaiqMvfcplxnsjXr/pK9Pi8Y9XO5qlizmJfDvW/+sh6+jcsKxJthHWE/vSsIuDX3v+/7jDvwt1jqbC9cF0PeIQL/t2Mbz1dcSRdKxh6/aAoINqbevl2f9QhC0XHzbvIB92PfwXZS6zXwG+Oo0O80wYu3bb/2aHs7U3Csa6f36ffufEfDofvqz9uuHkrzOO78B+QlGBDhcirqvTmYQ372u2nB9FNsC/jiy7Q/5Yywav/BUB+DdlSDS4j4/5ld/RL/9v2F9cLBOrXRcFCtf/ubf0euDbyWIOvF8mP+f9fnmr7+YXj7vaY1NP7R8746ku2iPKPlQnzv/hD3ZCIf0fesbfeafLhorZZp08+2Po7w/81/zq9Q1+vz65I4PWG782J+3MWMypyvI59c+oh7/W3+1aXa/9e17/AF/1i9wuratFv9dftX+dRN5yjgZwhlJcwpl3suva6YbfDeKnb+YifJYRTR/FFXF5zQiVTTkz7f+5Bv4Iy9WOEgXhrH2f/q79fz5rm/gAjydkhSJJ+PozyFwSGU2oOhX9dA3U81P0yF93/vvPcxfQX5qpCxuTv6n/q0y6ud/nmFsGL18Y0usRWInzd63+SXeqc9e/tjTpa651urfFym+iw9vMfX7ihWMeu/hA/4ddV/HoyY5D7+fSMGbtFPgD/gHqCKrMDz51nmLC4xH1PmI+nzgVRrVDRnyp7+8JJ/9KU89kC85Ng6+WYuIiJ/9OUKeoEsdzO8nPxvzF//Tf0E59/Or71VgLBDIN2a37SM9nIyr7zIn5YFDmn9YVJgjKnGSDekvHrZV2HwvX6zZ2Jg5GWd/YZ/kuRL08sVWodl4PX3qwoHv40Q7D+kbrM/3/WuT3IbjNzd7xsuvfn8lxUtHay28+l5fn1eUaf4ooxAbOEcwvwF/vvmdOuhnVXBbDivLOPf1/n2xWtP6GYuGhAhpkmL4falMNN4Ua5gfIx5K8lLSwrd2C+kqar3+mLnkUQvRHNa3vB0ZNF8m99/36fT4yvQBHiDByWM4fv1AYt3081PSKfLQsrHv3/phWO/nl88tCEU/66uu3nusidqNWt8/+h/0U0yQx+fD+YteUOet1+/vb37USSt9rT+/F4N+/csKIZ1ZzwAfbU4Ndtr04bvjh3RHZQHyO+DvPPVksvDE+3D8ViMQ6lorqj6K+boqsbIpWfDPFwhx3PhFwRff+GoF/mdacCWHNro3tN9zMWMOjIZDHd/N+pkz2oTCn/X1NxhVgPFfc6GuuzKh8T0W/B/uFA77sw/gg/7s3/upMdv3H/nkf2nsyzfxWDmr+Q7wb8t0Vsz684/h+N/zEy37qW8xfb6p8e1RIS2lywT85z6URY108EOZl+slSZBfffvvifMss/DGiMaETUuqPsanPwF6rQD+ra+b6ZR/86nfL69r8D+XM9GLdQVTcGP/6JNWMMjnw8pmvHOLqfclDt8wd3G8gPX/1r809lR9mk/9IGldgn96LSrcyH7rDenzvvFBHz87FkSH85aj3v96ocusxTUC//5L/+1Jfd8gK3msSD6MP9v469SUV9T7YuV6YWbitgb8i2bPCstHFNx96KDIVh7M/+1V89g1x/T7Y8LglcJvYXwx9cSaF1/0+vX+r2R7EB8Q9TLyxMuaWj8T1bhQmDPI5/kSTEh3Lij5c/QDPsp+f/75835uReN/6wvxML6MeNlQzyX1ffVAkCmaV4j/5AKbseddfU0xuvpC2mdV+XLfvwzdJ+Dff/OHJyqFP5M0pEpHBPLfth4i3bqvufXSvARF2/T5Wz8q6M83HU/gOH9CvV9Xwi0aSe0B5PPrvxkCBf/0j5EXCOK39pAuC3x1qffhDgBEfH31+GnlgD6NKLgegaPJ7CxYPwKAxrEIja8cQX5e49ACJVdOculVUu/bFxkH/tvxAvyrrpcReYscDe/rk+BtBPvvq5+RScHV0Qji45CB8b/+/ZKn3r9/3meKxRLWz6rrCScxNwpuAnYnqn38+D1fXUbuX/TLAfCZVzZrvKVNwX/6I2H4/tnnRh5zfVD89aK+Ptcbg33gIDrj+PBJ0a+3FwVjtz+f+ca/cU7Vl/p8X+Jq0I/zHe+m1kmm4d/+QP39gp5bbT3lJ9T+Nb7xuQTysXlcSu+tNxS+/L1/2IP81wdUIUFvKf3iLlt5qug57D9/qem8M3/S4yd35DBvA+R3ua4w7+U7Cm42FwzxQtafT0+QqEvpCeTXfjQYEyV8+dbaU2I17kC+v/cv0Z3SH4v+/IIRStA/VRIHhiGMqP3/0392BPx7syGO8Z2nvv/TX3wH8pvhmove8wW1/p/+7nK0Bvl63zuWQ2JHya99EeSbfN709Z+u3pvwukKt36d/qqyDB4rvWmoUYIGo9f/pv0cAv3wEVdRKHUXfp76cXPfn28eSt7BXvin5cqsZc4cICtb3p/77g4Krq4AZMbeu1588x+SjVgP7s3k2DugriH+cB4Lvoz3IL4osQRfEyg+VRnlxKHOL4rc+XwDyO/YNw5+lSt//0lu+UjbWKt8hHdOipMhUrNscW7ePyGNVZeI36UhMKt+NN/JC2a97+5qgd84sOI9VzJ2/w4pZ63W3DBES1X1/59NWPl7gHcCft77pK0fiWvQN/ML1kR3ab1l5Gg7Dzxa4lv7Y72/8yJzg+y1qDHzeo7OH+v5UDLcB/G/+Br/yNRkEC6d6qF89URPxTrZflH+gdjo20lkV1d5g/EARam/cDuqPwW/GHxhPdOP+fPaTn68D/ao+Af/y5Nu5L/fv15T2BPiMA/oNpRLwz4udhEgVf/36L6LKAPxbfzTv+VeD4OOtFGdf/SE5aUbNX6qeE3StAX/gv/yBK8HofEtvNfh/A/inf6NZumCf5Ow1I8UK3/3FayafsUQA/krwvNFEEeyLwmKEN2tY/099EOUqhcP5y760NPAejLk/mP+AvknjcehUg/89+P6Ly6uIVXf9+W0lN/BRMfP1/v5M3nvU+DiqmBrd+oytwfjpIn+TDgE+npduQYwG6P/0L5c++AP/Lny4E5Ih/j78vt7YM2O+3YH8b9MjQaxfZL7rLPAYAiGQ/9fhwnBvEM1QXTPYTuc78eg7maJoanwB+Y8UTU+NtQXyA55WglY813hS48hH+aCA/hLyYh7bmx4eb44Fqu2I89COk11MtgD/ns/qb1j/7/smpPfnzZ/6hQzo75OWrbDnGcC/b32CBOLDn/4wR6D/835N0jrwD8793dZ4rV1+68NNe/71+Q1YIwDfvCE2dDj+5OOVKa3R4g3y/3O+JYN8fPtHVVnqK++tYqtZQq0f9qXUwnsP8P8qX+puB4og8yD+HPrPKrv0NZD/TImWqCVPAvHvR7//7/qqdQGhquFD/DdY3z9wZUfSNV6CszuEX6tS1IXDDPhrzdNdqnbgP5uzVkLiCvfnn/uLQNhbf//5fV+o48cXzqz2wN9L3T28aQTzx3XQeGm6g/hYd9fSCYn9/OeSpvqmBvZHXuQ1Ius22fuOlqCL1PX251EH75rfTAF/Nm9MvLLjrS+LqrxSb3uY3/1WS1FXgf+GWZTaeB0mxFfEMzox9YjmX9uSC7FRsx/y71MfjO3591NfjPDb3/68NP+U9wkm92q05O/77+d8yqui4fgD/h/evoJRilOKv5tAJOJmAvJ3IiTpMzTXvh01SiIn/fyw2GDftUG+sKwRnih9frBlbJml6HQAP07jgFf2GPC/5x8Nu/Jtd6Gs1DIB+Pd9o78G/j4iX0m5sq8PsRKZK7Jqav/KoZYe8NKrgr/Tr5C0maWgyMO/zx8H01TFWxJ6Q/yvf2sBf9X7xTfTWc0vfXWcKjv5f/iLswpNEWm0eDh+xAaiNxL68V9s6qYYVZZv7hdIFrlDL//f+y3wyOTbuqnw7OGrvtWcGUdaHGj9KN9rHhnI14f0fePv8NzLz9TjIBypfLC/EzSRYhbomy5sMEoNyJe8KfAqfaNU//r/6Dii+fOsUw1zWDP+Qz8XQXvGp2OEhvZNXQZixHr9/hVY/EyzulB/6y/S/JHBcL7QHGv+cPwOWyPCzfv7z+XyPcOvVuU88V1irIp72D/CU59yXdHnFzzyk4qNpSV56PFQNupqzFLymRRogw6+2nijv+kH1emLxp9gjsPvz32dJd2xz48Yc1JMNssEYq3NDqlisqPmrxYdk6GLx5f/sT+m9crHra89qPmhzEjNuw/xORr7K3xcgywr9khOsZCCf/aM+RnvgU3RZF8hb/LmWcD/3s/26/PTX2/s/74fOvCpb2wrWZStFein7mlovv1sQH9fbbmv79Q4v/UXQa/+1Pfa9vkV/tvfY/7Kaz4+icwTif39b4rIFEnjI+C3p5bgXZfm/vxwxw/5moL/Hj4EPpfQE+zPKXv150w+yBIpZBtPRcD/7v/IBPjy3Nc/NJqVby1zvFPKGuALztBSc8MA/euguQD3Nd03XYQ4pi0BHsh7Tp9cgT7MRaC/mkmcwDbPQMjGPX3gcczixaUA+HWcGrgTqtO3vj8Ywv5+1WK1xnkWffxKvBNh8yT6rY/s9PHNp/7B9QL4tw3InyaACvjob0m0AP7zPt0F/sjaMyJubz/mi4mCVXsH84cgU23mHtgHubt6Y+KE/P63v8q7z8/59Odb7vxEeaVoQho9ukLwDvEN1nv/oHhrWizbpp+o8444hFMvu1r81tcPIT4wHX6ZapvWE5WxjxZo4qqyh/r+VrK17f3PT/3Pse+JmEzJHbQ7d6mbhyWn6iTo5f/zflaAPSO7HdhW4STc6ynDyY2yusH+Q9cChBxsrq1cbstZ2lrTnffpjyufu6F9+VSAZkg3b7Ph/m5jq9Q5YTesD+h1Ic/MmOmJwh/AB/hSkNnGrIopOPON/y6wP77vI7cNVf9xunkp4G9T+3eYX/03/SSqCkgLJq5QD/37cJRoxvw+9m1s1+kT9E25qD/+lUJWsD/272DC8UuZrh/Z95/A6z5/6LhN9GZRHgHePpornq64bY36/sqKysH6N4TVfOXxoPBZb4Q6xujznz7n1/oIxpfJ0mtQdIZ4mp2IkiAu+vH/qZ/y1/oJ+u/5KMQcSnJJy/QcqVHN70r8ll8XkP/v/eXeofg7PXlSKbUXoO8Va4tYYUuq/uPP/WV/Pvg9/wkliv7ReSblCHxKC08gVtXRqKTGFwoG9m/Yxx/f+g3nC+CD0D3w4jBe18LYYHRR7PPbPvVF8YKuzzkRXxA/pxrEzxexA7eSJ7B+TQ5OtSqV5Dc/qY8v/i/+9Pl/v/UDqPqV//BP/T/ha+Dvyam7aLKsqfm1RcFYzJyH+PdxEuep9pSo+hXtkeC+gn5fXweBOvWqGwVHqx7/8rk/raOKTPUJjd/HrEr3CgPc3sN5o6u1TdVPedZoJNbb4f3JED643w2lSOSmU42qn/KT3yRlAX6olWOY4ZOCT771//v6q/tHjA1Nte1ETQ91SdaNIMP+U2FYt7+f/xT1mi4tu1JGz+MV3Y+57f3kn/T5S/+c7w/3p/qX++NELk/OlbD+eT3M333lnMAJW4Ha/+wY4YdyGYF++6nPVdP1X7RWyZSyz0/99p9ZLqn6M5IIQbt8cYC+9UudECEYU/V3xt/z2yvw3xIuL8TGoTfEn5IlImK1BPp/zr87mr7cRkup7c9HmXfQ5VNlSuPnqbJS7mafH9RUOjZ3Rxre94dQyQPml0SGHCv2GOCdn57Sp1cTbzxCyJEaFuR3eyJlLinEG76v+Dl/7fG/9b9Km6qvy337f/bxt7aG/TmuHxR83Nt39ZqA/qgy3+Ydi6XoG50bJVTcss/fXINRaxOfrt+rpNITdXU//0dhxo41per/Tr79gfv8JTNSO47ZTyj8T/4bgyWALzTRa6zmTuFz3/rPfX7r9/5tVruiOvPwC2PCEW8aHBldmu57/6AEs9ggYdC/AuOf+mn990NRC/yZ5XjD95lq5UkX8dLz53v+fDep/c8fCkZF60l/fuzwlj/XGIo+1N+vMzbOfs9HJzElX9z4KB3ESZ+/++kfypkRhf/JjxEf/fnv3dMCYz7iKfw3BPpIOofwffWkPjmxOVH84yc35so4PujX7/1XhAH/vsGbdAUxgPfJf1O4EviXTzsuf290qr7VdFwwErOew/d/8guXbvUb33Sgi3v/REVToD87FWpqjlkKn3U4mVfVos/v5II653Yjqv7VD34M8J/39REFn7gYXHFPgO/zGb/iFWFJzZ+ZrlAuxhB34fyojiPWelHff4/XTIBePujn/bG/5MoaGH/ywAkuEIL9w7gKlp/9/dg3vtqx7nD95+udlEv3bc9fObV4Kzv09TsSvMOTnn+dbOKbzPT277Gy19i2LlR9rjeTyRv5Ufb2Tbdeefeeu8P9Kff1o9W852+LU4VfoBNVn+rH/n3yZz73T9aO5o+xw7xyaEA/VXog6lxO65+f/FND+6f/5J6Ci94J/N/0Afsj4j0+59WWol+wZfBvpv39iujiObZIScGZ/nxYivKev5rvYS08UnC+zx+SxQTgK5L4vBqv6PH782tVl2D+7uvSIskLqfkx/f2bsoJQG59HtVTzie8M96/zPR/rz6eXhaEZ2m3tiErs4hCbvXx+9Lt66fOPI4bVm/nZcSqVk0hH/EZNvZ/3jSaMT3ATpuYJU/wf9/2HxEcvP9/8glFEr0/fnwQpNfgnj4R7kW43o+zLpO8Pp75VWJ8wsq3Gcl4UvPuen/f5i4cnqvX30qbru5muYihHAb7/7c/y0qjvf+JbedXnD/7EZwll/3j5IZ3EA9vnV37fZ9wdW650H+be//vJz3zB+OahULAtVc5QPtVvffAzxB/MlrxqCbVOAhxLjfSNwP589Bcz2cD4n/qK/PtKfX+0kmRb3ofgXxxH6jOavGYU/Mf+9fnZObGXWI1Uyv/oLjOkIuEM8zvfeaNQVIuG9/1zFEv/5374vaH4ywo3+aW+c4Av+P1TR2YK+BsH9N+SCATCoM/9rd/f73I4MBzVsIfy9XM+pgP8duRarpFcx1a2WX1Dm8/8v/WZBeCP8zD0VLFo/40BE3zDfn8/7EwEHk3rMeX/yFsendCzhxM/nWHFlCj7KpUMY6FT35/h5HklGRODrj/Y9+dT5L6+u9Xw69Qxebq+fv8+SL7cQL4qy+PJ5FlS+2tkNKD/dwp8f1XkbzB2K+r7QnRl1qixYP9869cmZ7r/QF8/QXEKgDM3AkHhbUfJb/t2mZnE9/nzunRpozcOqPEn7xNTi+QM+/en/86Ksl/NKcOVcudAf377l4QjW1TPyumaniBIrpnJVL6psxT8zwiiW2NuT4G/Uue7WAqDe436/r1K1+eX/t/15yKcLfkVllesnSh2BqFOPo2ymu/PT1Srz9/83r+umN7/LdI4ncz3Wf1jn/r8mLOsac2McexKvdn1Gh1CfVeP+vstZaaC/1kZtVDzoSwP3temA1H46/vbhVqKSNIr38RLJtUa645n/4G/KTmemypjPMSXT40ylZOuPiP/cklzcfkAf/zP/LnkDd9Atsui+BYhNM1ynOGjxezJbLsf1+zphuDPbh3+aQBu4L/+CEgrYgJTYdXMbsAf7hKl+fRPxt0BTIM/r5axfuwg3i34NMb7F8THjLYE/bY1mwjrGq+mWJwP+qeBfv/2N7njEnOFIHGMRaaBNJaX81R380UtTHdCy9g2uaHZHpjs5XOmZEb8yyE+1sceg1x1rOY1Wgzpf01xjleBqPr//FHB3JjVsN2iaSmeQljfVRNt6ncuMxM0a5kQ/fX9tYqiCWK8GPjDl94k6sInv5de0vsG9mg3qaVVPtmixZYwaKsII32yCcYqWlageMjdIzU7WyKLmY6QjV5dsU/1R8YIzH77WpDZpJ7+vl/vf/tL16JRssdD/Tz4pbtYx+57zAgD+jynnB/Vxxa5SD7tYbynPex/lFr9/pYasz8fWdfTvA3J4H4ep/Nv/Zr8gn7ya64m1T/pcz4ntnqA8CKssK/tVArf4iw8VtcJxB+pENQ6G50pfFfkGI6ppA799k8lFH0mZ6CLVPfxy09+R+OFsmDUJXKP5OK1ixmzFacy0C9sSFmPwH8fft/lBSXFH//9ez4DXtrw/ZxLAoi/lQXop+/5USNTcHl0VBR1VYP+5J1onIvlhMaXGXxW12+AG104x+rLsqn5zfvzbc6D8b/5W6D/h/ha/75D/ej/b30i3bCp93vf8/He/szq/ZjrdBfGV+1mjVlWf3ldsIL41NjT+a34jFeYt616mJ8tzaMnx99tGF96E0ScAuRbuDRSjUY1wJfbUvTa7kDVP1vMBSziUwP2hRl7NRKNsR3K7yW2U+V1qb/+i3jDgD/ttDnvutfh/k2VK8cTaTR6C3g033Ne+/SH+g8rbsq3jLNckd/8oU4frp/KGWNJDFYKwZOOl2NLGxtD/plf+6GcBWyGMfh/gW8M8X/y0zwV/LO7wNWjnScP79eBRdpLtQ6d9+dvQ/1mK6UQMGt+JeCVWrYeZ0+ZC9IXuEmdjej4Sty/nzm+VR2PSJEWeDETLcYguE3Vird9Uz5yMyYVzjU25iXjtRMBD/0LVR3rc3BwYH7eXZz5TjMXBMnnIdoU2lBtXFzqK3nzfF9wI3spN3FUiDdlD8/TzgAtIn/Phy5KiffLeNkoz0QNlcDHE2zejFljspZyxsb2DP5hUKOoG2Wz4fpiUjAIteFK/Xv9Bhl8kkZ5hW8P6+dc0HmDn16YYFYHyHyBfv/Rf855j2vWUMB/Ws3/H2Ff1qwqDyz6g3gICgo8JoR5jIKCb4qC8ywov/426voWnL3Oue6qXbuqdyedTqcnku7O+VACbs0NZEax8ThKSX9sWR398RgbU4zl8IUKjkqJomlmG+6eFYg/+/Eo+rt+Rcs+ymmTxLjJML7RtEp8PkwUDiIFH1R/A/7a5/6Votnt9RtuCN7E2GASNkYpsdzVvSNf4ac/1lmF+P+aUeYXG6st35o2IhwdjUn+U79ftjv4zf0r5aVvYP92csZcZeS07Ztx2KBE1g6qiV9TCML1cdGp/6MGDtjH7em5/Xt/aNM/jmTnp4SjQBokYrBWdyrPF3s8vaRGZd2fmKP+aV3i+VzTMBV1bUd7QVDkgYukcqgfuStCy1HTHypUQv517PD3/X6GLMDXwnhVmKJav5zO/m4PWp/2NluKT9ujnHMLvV3fqPDKhUzlzSuKMB9oLNXyk905n+5Wm6qkojneh7yaWv1R+/xivQoknxuPohKMdoTMajE0NcoysOdDn/nM7tv4QbxXBPZcqdTKDU9ajPfrJr73C58Zfh+NuLoXJT/6mYUd/bY6DLfoqFPpez9XaO6nGXhtFNct4kP5kik+Qset9O1PfBiD/VkR5OYvP+yFKB5QFfgD9u/Tfztjnfd5wbSpL3ZJYfyv/Lf7Mzb7L6gbVavr+ud9pdV5361Lc4ko/ROMfx2fqKXrx6DDX2unpnSgRBK+CWhQCpLdgb8vpQBbtwJe9IHe4SoKOvrvk58Pt+W3/oImBPz3fsdAGobD5n0C7jlRjS+DY1k+dyfgT7lFGzQ/572wty3JHJQhFfB1bbnYHAod++WtB+jJHXdgH/cFb2Ffnft/+AdNfHqpsiA1CyFowz2v4EpOPcH+9xR5XJjcwe+sr5jRihwOtP5+v35e2v1bCv/ONI/2S5CPz/vd5v12a/3m9SK58jnaHvG8Bu+k5478zvlOdFrRTQnrC3oW6IdX877an4QaclXeYKqAKQbXKdrii1IPj5JlA39FmW3wWigIC15TytRwFV2xvU4qQbiYnf5BVo+Tj0oxoAushdE+FAPFaa/fPk64hSxPYH92upQlQ9LUP/2FO0cRx1Rm9Rav0wgJg+Hc7chf6KkXUmOQrx2vmVVQq04HLjIFItwlyM/9YO0sr7x29GN4bpo6D1KAb+7gH2u+7HT05+f7b3P/4PN9k2U2TwbDJ8WRYenMHY91gzxlkF+mUe4oaS/Qn8M5XmJ82Dks7L24p4xskE823UqJvNp15cd3aUas3RbsY5grZo/Kbf+k0E4rfawabBthskI9JN37nf5E9PO+W45CfN5nceWLud/FN4dIzjbbK54PbrSg14nXkS+pogEJLNg/prNxZZw4X6NGXqmFU/I+I+OYZLjv1S4ehmCKesYc5C8l5RMtSeUy49Ofbhf99Lc6njv1R3wx0xidj2sK/gsbg/2xO/R5ixv4G4eoif/jmBbmK+nwxxGu5KY+mvexGz6LYSrUxf/0f+Ahfv7Mv88750dDGwUOVoOf8+FLkHu3Lnx4VE/knf/5vI9Ouc75ok39Euo3+bF0hwZC35sA/Lliy0KLt8tSis5qQA5NfnCjHHu5/MQw/sqqpti/h1mpvFw04zbN+wXDv5Zh07akU3831vt75XEH++m415tQSWc3xpwaVmg6BvmhN6mHlPH4lfzUd2jet/QFtM0lF/vM1RrZK7ab+qc+zczeqSdarAu2TeForocQ3+zROsIrbrEMJTh/zfuu0kAPX9aYU99QjXrXkfS9Hyg/OusHo4wENG7qW/RqV8zRwO7wzy4qtOBOa8393l/TZl391PTvIk8f8D/376X/wV+nhL+qFcD9HpKP4o75f5zfJv/pObQvCJ4I8IWG1eLGX5dlL8uVuzJ1gP+f/iIB8nckeiArvxwgIPvWp0gB/tynTqpJm874ljHi9ujW5K+d01U+9reO/0d84sH8i/kpPLmL/8Ef0lylqVTA/9xv5uwOvq8vuDM3ue1MPDeS2uxzo47+//ZvHcQmFg6oj3obvmsfPu9fmvz8R/+MjY798x0V3dGuya+vNsXCCqxbR3/qxou8yLS5n/B9Px11zr+9XmgWeShg/z/9d/f7Lpz0mncVL8D/9j+2O/rJH5RKqaQHoH9Q85YYXHod/88a7pUrxNcA3wTxBozJpE0f1voY4hXSfP/59vew3JheR+sAp1wi/3xf1gGenXf6ybSn4J8lr3CTG6ZMmNsUuVPrpj5ExZnKsU+6/sO3v/Wh+X73yX/vOvw1Now8MJ809+fB0iLlHnTwg16T+OrrgP+tX6h1/BfN45EtX6Lmfg/BUWpfO/FlYQyOxMPLJcjP17/sd/gLx6rxQSsYf5EL/LGOo45+8F9bZYF6HugnNxL1ytyonfj6/b4L/GsY//N9ckU64weTO0c48MlDPGDppXAn2OVVA+dybq5cMfz212ve1+wG0a3sP1RPI4ZEfOwlLv/5PkvyAub/3C+Bbezo58/3Mwz0f+oPeXKHP/6eEIcOm/oSbLWozepJO/jebKoeaDAD+5otTKXkk6pb32d7UBnZ1wDfSQjltdHr5i/YGB2RFIF+H7wgXnMi0+LJocdCPD1hnRkqpmN8j4oSa2Yk5ZIZQfwg+OE9n0ySfdkfHrmZbMRrE48Fc2hWk0vHvjif7wdTON+lVZmYenrXP/t8n5VAvsfAslOwUjr0OWFfthX/sK2/35eWpCN/+nyNRvL4BevrCSYvvIje9W9na7Bf+YGneCrdDJH4Wkf/fOsLHpr3J8vML/Qe7uif7/va5nx8vi+KRQffQh5XIg5CU5w4XlBp1Ozqr6nPCcplStH3+xrZduxzYMrcXZ6ZsH4vy4emHHTzOxoHQQNYQJCPcCnr2BRe3fXVa5D/sQfr//TXlG4dfPfz/ewG+ikx2Dgl0qvDX1vl8QNffeDPYbZQkufl2sG3ihHxSL6F8+EU214y7E86/LdTX8WgRpr7Meq1SvqnSYc/+qd/phT/xPeR0IEb2xDvSJIA/qd+TTHoyI9+HykSd90Bf/ZlHIphfevGB5/7rQnQf+RkFdaLO/Kl3l/EUsEdN/+ur9nKz/b9a464GCmLdv77ySgj4NvGiA2pUj6VBW3nZ1q/MomtVE11IuP4iHl8x0dW9vcePtFJHsTockZV+Oxf1IxaXCEURgVquJ2//Yu+d9FbVYyKBEdqrTQZdLWd3w3oRDkjx6sgTPqH/i7+f/eXWt9n2vebNnvZY6HEhZkq2YttzqL5/ac+m9+83/vBz/7Gh8DIBOOTemBW7rmTO8ualZx+UAtVffERtiYhOj6NAvQ5MMJDgcw9S5lHSJGNkdqh/7lEUyRUSVZWFUVbebgeh/g1lK7gql/lKypnmGDwdl5l/2yZJ1WSwL+brZPBkQ8S4O9FLg64yjKbBUhEa84pNwn2vEq1QMFqnfz45/vR+uXiSw7aMKyuRpv/rd9PfVKz8/3zV37+rF/ags+GmV5oRmXI5LUqh2ioCvv2/v/8zP9l/ummIOCP12ZGBxhPCjwyt6Viuqin2P4jRlhfSOg1WOr/S/5ftTWzCKul4eFZlQ/z6ND0O/33/1mZym9XL7R9UVpymz4W1UvBiag/wPrJ5zZA39kAwyvZ+f+GL0blCZ2ux+nfcNy38gNyl/WubME/+aH0APK3tAsHG1Kiffqfq/wI9K9ag/fT1K9rn7+v/mzu96iMD5gbaQB/bcMlOtflsuRvL3RFm+b97H/y+2f/KcCHaL1yjg7AMyV/5kM9T8re2uDWzff3X/zO/C38sUT7+Wu1C27EkNESbfjFqBSMJ1ogXQP/YAAWIH8qrfs98HMmGjdS3vX5Ts5JP9mbq95Z332Gh3SwW1Mc+LUkVCuqtfE9O+Aol0n4+J98duT7v/wfxHdWJJn9eKV79FTjQyE7eVwqNwiuZYU+Ezx4XIWkUs66THyjfKDJQFqUcjlDW24yfy7wf/nX9vit/GuvNhGqlxbgh7OQy/1X+Qr7dsgtlW00onhR74wCMwno0xNyKybqQghrWwP/klhs+5/+U//Uf8If63vXD/wP/l//pz/vZ0b/n/5nf8Fxq756hM8sUUr5MO/CWUYsmjT5qTVOTUu/PIKMLIdhkiuHLSlraaEcOSOH/edriBTl2yjIVNksGdqqi/xn/n1Tf/Kdfyw33fsrzfsfVF//i88PtZ/hVR/i276WLz/18WjUB//tP/r/rB8d4vNctJjPuA6cNt+HkNXE58Y9Hlc4f8D6VnYIzqJ6hPMT9DFH90fwX7/5xTPgH+RqXYD/NynFaw8RbprD+r/9zSe+RwMPb/CS2y7K7/02tc3fP+/Xun/A2/wP/0/8Bu4eeWLZ5a5zfr7vS0/PsiW/dLdej/B6eB2E0q/8fvJHag347ouQYrvxMAt9TDZ4P1yXmC5EnBK20D1VeoIhnuzzWSnQnEPKKllv/z/n74pX+k4TteFev+GLkQ/yxfFYllzG4an6RAT9Ld8t/wOJ4SDkt0s4/+wFTuH5fOy39evf8//anz/P1x/2S/9f8Lea5VmBqKgeUUFfFCOKUMiPctonFccoHodXKRFPRJPJvZfnuTlMTRa4PsT3w+hl4uAo+qm27VFZnV4r8Af48FQ+f74ftfTrn/cvfuRDauC/39+5Jr6kfdzkj5B5Pw7ku3f7vn+RMc8cg8khWuzp8lt/xMu9m7qYFXyxtDORkQsIiEKO0RIPB+Ul7yOldb8JsWCREJ4M0miCN8ewJ/ROeaf+tncQwb+37S2ECU5U5gOtAv+Hvh5PVG08+ed9Kapn3/zbLfJumN+he36+3J7M9a8axIRnoO+bv/L/k+93/fBP/+JJNPrcr5fionU+Hox4F+WsBA+Af/pDhguvA59vtZX6OtIZ6NJTaAWF26mP/n2ftNzaGBhms9A4MTi8Iiche6T1GP3Ud7uOIS7yXaHktwXzCB8WTkFuGdAfjYUrUlyAf+qX3oXf+/Uw//t9r6pY6gA/RrkU8tNH6/7xg/nLpcpTTaYEy/2jnFT6oWUfH8wwZY2ju15kf95f1qtl837CY+fme8CAqXZTX3L9Unt472RmqovDbv3zuUpUYk9rG0/RSWV00dzftyN8KXp7LDO7FixLvc5eCs4uwiOUFTts77/KnoqANGer46cvPEzukgRtuJ5beErXEfXxpMq5sgofWKbHffjMRd3aMpNTpS2qhuEDhZ5oimaQ6B7pcSWPzqK3YWQzawoh9YoaE24LSlfPDU8d8mUvN2Vxw+hIRi5E2KA/fvWX+jhXdlH3xYK17O/HP1RCiAdverlBabjzGbleFF++9NAcSdMTqbDbjH9OwyjnHjuN2fcjueDhHOL3z/vvQ6Pfory6FGPD0hiezmVBifpV3daf4KQVeeZ7bnv+20NkohNcIT6a73M7r4qTwzTPoStsumyB771aNPt3Q7+pqg2KEdysEfP3iXqDfzPQf9dUPRF61TPaGzCreKTWnNH7EN3R6MYkzI2vvDlkiN7UrQpufc2yCfNPEDDIRxfim5Z/komFXhwOxbRN30lIDdEsHdDvwq2aFo7kjZgX8Jwv+69RiR/zcmAq6l2XVbMX7vPXtVgwH9fgyiEZ4IugBv/udUYS8vPyhpyIzX/exzvA3/+kwsK5VC7R7HKK2/eHfuFqdWJm8eqJRRselE19BPAePTyEaDEv1vz8Fw6/oTUqNDpFVyWfsmMhLL2gDb9gmYi4IMCfS1K4xWJVLZl6deREGWHgj7K4lgnyApzRSs15tBt6mza+oSWiMEh3YF9yEg7zq7lbg/4OwD/E0vhbH6O3xU39M8HP0ORpXdk7f6rsZnGEDS81TtYjauqH5eB087Ighe/+bMpxBPApyJul8mV/q6z5pv6BKC+ZfYqVtZKTLchA/6Rb3umk7rDtIwFN7try5/2qSSPsO/kOVRa1eZx4FZxHGeizJ0zjyEmo0bd+irJxdph7VkJxme12n/pieGM375+sxfCIxsyLVSY8p4Ucx+dPfRM1aOpjHi1+lHqeCfCTjYfgwZwII1KGA3Uqgn9F7dPYMieup1GEKw4v17LJvvdLmvutAu9NmHow3R092hCPn3XeYTiqiQX6d+fijVsuQ4UJroYfGhz6RKiCT/1/bvSC+Ga4rx8m3196MZ3Mxnt8Y7sj055EfZBVBP7Tpz5pCvyn8zCPc+JbR+bgKZFVX2jy9/UuZB6fAf3VJpiiXm7tWQhep8RlMsA//dcdGF/N8Vosbnm6Y9q1hhFw1K3fVVzKOq+RuG/X1xo83Z75mqpOrE4pKzBv7CL2/f7E8xS7mhWzQE6a7yePcpCfHDh/PsnVser5sD+OrpFK2xXWTg20UMmTe7r8+T6fbmusl4mS9B+FodH1mc0KOxCXzNhuhwpXB/X22x9z+gT5Os6ZUwxGpzFzuYQ4qtjUP2HlLqhC8Qrrs1ehkO8Rjtg3/8zB/nzqF49oUx9wwRgGR48x94rAf3ipTf26x80WHfUO41dqtcZDVEyYIwfIlM1pt75bfQ0HiM9PUaf+WM+VBGXVzD8wwjFSwRIyH83ImJLJrsNfrwCvcYQ8s42/0pKqHCScqxFrVvbA30sPjCgqTlVLA/n51idZuPy3f9ldPjIXfJ++yvNNflyIvSroN/XdkhcLiiwoNp/6M2jUvD/6vg+QPY085XCXz7EF5+Nzf62JH7avsMxRpIB843nT/3mertk3P90H/98YWKZoDEF+CNgHs8iVtPh5X9uVnyY18Mznubhur29ZhwNTnp+1jF6OLMPTRJ6y7/2kJv/j6bJVeCzHsro8QeA3HfNg6y1mBWpGx1u8GgviUXZusD4/LPv5UjotmY7uRCanSVPfRuLjVMczoG/pITGfrKoV+A8jUK15c//a4fNnCaFuU1/vVD7ygWgtfuoX0aY+5Pv+mgPyRa9PFuHFPZ0x21yQDZWm3f07p5VWiOVt0V5fRrO4MJcr4O/QWe3yKORPP99XmvrCn/rGpeBpqjha93GxZGdmiUdUoksP+O/lli9amxXQ5/fKNRoohcbIlClbBUegPx8h7SMUx03/5rf9vmk2Mx9DkE86BPk+kCq2tKrhj5ixBA9LPmHugagH9d7Iv/PAGyuMDqCfTqtwivb7YvdTP6Jq6q+j01h0zgXQ95qGE+Qibc/cXcLVij4H/qGwGImm+gS4+sizvLhVjGmf+/MnGJ8+kplZLUNHo6t1XuXHlwb8aepPY9R8n1hZ0c2U1ibI1zZlFn5m6YZ5Y4M7K/y0eR/5LAWkjNaehpNxQQt+WOXM7dmIyPOmPtKp4BeVu1i6vLoICrMY9MQxs7y+0pOxAfxLn7J9cvvE2anGNXzld9NbMbAaXA7+QVP/iTEvxeMK6D9RkF8Ve4tP/VX6OMH6kguaJRKduxqV61zML3xTP3I9VFNVIBB/X1bYttTjzoHzp+eHnHG36Y9+v8Ymtp/mOqkiyY3J8ALx3eoax8z5vF9YAH+nhyMscBg08lHgojgWgK+WFaLKfAPr+9S/F3U43+GpcPBO8oqf+j2v5v3S/TYTDaOA9ZO4lNA4j2ef+mbyHAN+KVtJGg7mzfc/qbyi8aHKGPm8P22+v374X4ya+iZlUz/+6Ao/7xvMmOLdgtaJlPBhTJOE3cFeWuAvN/3VZawCXLmV9xzVTX0tJauiggwth9kDQ0FyTZr6MO/vy2FT3yp5QYSGH7vLp/8KdwcfH28T6ZX36TCM1ctI2SBCmv6Ln/6KFMZPhqKbaguAk6BWXmiTyycWCjw+0CFt3i/qoo4D2gf6xAPi0WSz2zJ/4SkK56lN/aN3//MS8DEnb9Ri8Yr3zBmMCBy1ZvyP/XMPgP+wWVQI5LZi2uKm8fiJIoTL+Cibg+ulqTXhVAGuXvGaqZ/6802W6UZjXOmLBr/OKwePODxjXlNfgsgNvnZKBkfpeoT5B6x8otU8BvtxM+mBgLOKvveLpAfge9dwj9iJjZiVUDhfpOEfdw/RcTgEN0TtU/C/whr0v65Q0IfJvrp+v58wyYpVVXzqRTHKdowuaw3i8SI8oE98lM3Avg5DluL6ZI2Y2VsBfaNbZWK99gjzsokVE9cMN/nRuOXMluf6TtX4cgXxf8Kh2h5YPJ4tQDAGl9OaWWuZGjjYFkccriiX86Fk7b71bTenObMfMsjntiwWePOsSGokzNLokS9lFLpywny7pDcaPHKwh2pspFbuB7G6HCPwqV0WMfsZ6ExdW/UV5+kJ7CVPA43orNpiu6nP4rm+DpHcfpuDvkj66Dlr6vN/+luf4g1zmSzd0X4ELpmVCI9EGjsgP8b+0UfnCeg3U060sbpabRFOhxoTzfUT+E/4cYBXO+/wU59vAvCNewqZcdEB/8DAf9mvMcTCA4ZyOcxg/xDNAmb7EeDbYligZMhrn/prdOM0+/t+X+LXIN92jRdFsGI+M3NTQQqbgnxYh6QfcmYZ8FT0wml+fhXmj/51awHH+1t0Cugg2NGM4mexH3gee3/f5MY8Lb/9z7OVHatjVhB8U/iIadsh1+OcVdOP4t1/RBqAf/w451J+I/KYhZnFgX95eh5xdpBewvC1CTVyGFbHArxbyrRkxtky59YSFj3Nx4Y0Cng89XMPTbzbEeJTUwV7R6iAd+etFHJucz9Sf77An9xoJ/a9f5ZFgD/OgpPP2UFM1Ue5z7XlCfg/L2RJJlV9xMNTRkTi2sFOjS/+JH/Zt0Nz52tYo3yzLfFVykxMXOb/1/81W33qi9JJBv7/p/6q+fJ51avyXs4l2YaF9yZoVvMox/enPGPUOYH+HLvVsph42ZKFoBUNenyNc1y5oiVa+Qb8N/DfF/iag/9JvQkekjWD+GPu3man8JQ6PD064Q3NZTxljnSAUOY52pi4B1vKqDp0dlQbQfzJP0A/hP0c4oNR+aKYClcZSePM3uFKCVGup6CfzPUcTeRJuU6++m02DZv+4+Ux54Nmf9apvOcUF+RnvLv2BWkSA7x5bVwchQIO0+f+qwvycxjXj7C2xyD/9M6MolfyCxbuMfjfF6e5/znfSsJgMgL4wwm53NvKBXP3Ki2w28BXpHHiZi+Qz/PmEeTHpXhm3/elE5i/bhrbmi8E+2sNQL85XOwz//P+fUol3Jsn9bHuH4MdoSnTCxQ3+QtjKS84fwr7J+9c0ZScMci3Yj7TotKrHbP2AjHo6NJ8v3/Xj1xYgL8JwhOacKcF050HZyv5JiqxNqwVodo1+NUL7H+mgv8dUl4ayJFcl5jXZduynk1/CPOC00Jdgf62M55qOD+BfH3qux/6oUZdGfz/04JfM388Ugu6HoN8S3bqY4tr+mvMelWE90Rese/9KRvgDqs0UQ1VOB9CUk2K+FzMmGbtZVN+JLD+9eOK8qd6CrXv+UO7GOJ/XXvRp7+V8IuCW4Ejx+ZVQ68mOJWLBbPGLzi/orE+Yhfll6R/vMP8/OBBcnsO8ak7DciKDg9wfkbnxb0cJkc4f8zH8+JF0jELjD054J0N568oUG1KetOfyknyNRIytmemMyNz8roD/FO/WxTsGN+dHCKMedN/VQH/n+MrYuLzVPZEVydNf6tegfG0V20ZeQ3Ul8qdAd/s8zHzJB34vz2Fg3wwvBXM79UkpaFc19/8nHlv9kfEKb4LYP/e9WWR64D+4kwtKFxPVWW13Db9XRymdfIXP+mPjJwV0P8LUnTyD+UiUcKK8zRZTfuFiVdptm7D9w+sgj3bGR4d9sIiX2ZYbcOPqqcy/z4yZLJZFa/CyYX+398f6e41kgvLWwht+OR05XIxWZmZqnhogWKhwv8L/UJS1MVmoP0v66MzN8wRd85gI7dU1NFMCT3Uwkcz8D+iegsWf16QWI3OqGlfYqlVeJ2YHh3rKEX3beX+L/Nf+xCfJfi3v2vzO+kL+YgWpn4jS7XYFitasDZcY6mVOmhnyDR7YLtQFnL89/jq1C9FdPVBvo2wZ6zw3MpPLfrxumzycQveZaYJMQ3pGWHaXt+CL6bYskE+WuOmEMqHvexgyBB6Q3yaztOsDac45ML6PNc96lUM9Mfmlv4v9KEiHyB5D/GpP9lSj5ph9WzDnQ0Eyv2DnDF/OsSaqoDDhuQLj6vme6JMr0ZF8XGWdfj3iW/FTJPpgYV+Hp4ssw1fmgKHhutyJJM4L9bFg6U99r1/j6IzLsvmKsL4PpLxrCqzXF/e+syYzuQ753rbfRv++b37I/7Cg/pk42BXdeDeQNI8CuHtswVXtabo1ky0em34O74M7geALyAWwXFWCEw7O+Df9MLt/d/5m/x4a35nGorJ85iNPTUOwb9bXj2B6ZODptFDj+4/3yfdxwHguQT2oSyyHqMuHQ4U7wHwuSerTF+uxu3+jt/+D8b23F6fH1ZyoUaF+Pf6WvS14N/6cOIIxu+tKhQcUoHREdJuxHa2T5zMEArlizLq9H889LFHaxXgtsnU1BemHbgzn2oqJgkdYHEhcLmQu6N2f0y/PIAoBTOIwQf3zGTh8dKhj0omXalnu1Z+6svjcfv7UChTKpJ+BvN//B9rObqpUYkU5K12/E/91RDgFkrtE1nbHf7pe3U44EqvHuClnAuopy478vGun4wGE6r83L/VR218f7uA+Mqm9fNbf02e/re+9/elT3/TIYy/tSyC/WU6bvMHy1vVUpFen7Hqlv1wgOpxRlSar/Npj/VYaKsc4V5z2N/BCqGEr67jG7ksQxkNKywy7VO/akPPONzFxskYeGOZ2OlDQhuV9Znzqb9i1fcWvEVfC/7mLxK88Y1yAj5j+xX3mG1Uco/r9beDf/Hf+/uLb+aRiPrHwfim7uSRVyxyTfj5/rate7jkJNEcStq4zR/KzhLlOAP4G28xFu1r3uHP1z8pgb/f+rbGuC0/cOSku7JWQX6IaYJbuIw64/sh4bay6cV6C06uV67K90LT3/UXrmWFVvhBAfhFFe5QlN8EZt8kbi8/tB3Bg30MSnRwGmfUd/IDqlTgz7u/AVrKMfm5f34ZZ6qBy00ucrzAPDSA/Z3LO/IvfW/5/53/XT+s52j/yfd7fz79pe4a+cqXEnX4Q5MBB2H3CPj3D/57f37xf+Ff+ZK8fhsuOaJuGbYB+KNRyaODKvfY937EgdcxOyF0fKZWh77gbJGUVGvNxiMzFJFc6Z3zY28eSqLcBVj/P/gNfS387/sWmJ84m9xC/RD0a8AN8I0cj5r+vf8aix39EDCTM+V8qLXHJ5cbeuR0DvvbGv8TX1lz0N+Eqw54QsG+hMPm++N6BHA8BVfc1MTO+aXWnZNkXv0L/ub/L3y6jw3mWBnYr498oQrkJ7O5RJmN4jY+KWs2Kray3G/jv98HGS911Om/+7mfVQP8U59+bHXg7/wYfsUgPzpxuRw9Hh39pIFNLRX9DvJ5u1nayc6lUab65UrKwYXpsaDpv6YEQ97G+ZAnmM7lDr7pT7krmvV4H28j1Ddrad/R71//N4f9PXspTtV8PGrvL0TH6Iwyv9m/pn63xU078O/7lfPuj/nf/Zt/54e4j5402tD/iNmyOIVwvow+x1EukrQO/sMu+sV5YfXb+O/7BcrF7cjn+/4qnky0EU6KGIv0EXXWj082kmTltpv81J/Iwb6oQbEolheRZ8ZoBWF+oQO+dZP11DseWce/cIbcRB4t4xFOUdQThLxkHf0pHZWaExe70bc+3xZ31v++v0uTQJv8S/+7f/gv/b9wYj/IGOsWrL8F/9gXOQR8qqJ+TlIM8vepD2nxsza8tT//B/x9Pn7hH/mMcjh/w0lY51ozfvC5P3LswNv64xf+qa8WHLr2M92AfpPzePkv/vv8/+K/3xdVTt7hnz40yYsI4m6Gp/N6WD6zcdf/qSlHUHjaLbHJW6TA621n/Hf/O3UBoW4L/u3fbYr9v+Ft+fqFpwYYFod/gX0Viyouisb+fN9XDDvw1vwt+Kd+0rrojG986mcpu/23PksSdfj3zV+M4/2/4zfw1vhz5YqEXp139BvZX/FQzUeAv6OpYwXLdYc/VlCQEzkpAH/3JxOMPti/zR0x5Iiw/yFZIUmRHvy5BW/T93/A3/b/Fz40t73yOTfGMhUSbBZeM77pJWjPCT5/b8Hb8vML/7xvyPiu/H3q1xy1Oz4dt6IgbsQOfb4xV0pZGPHPb38fme+sX2vqqxF6APwPf1a9Dv32slYdStju+S99b/32S9/sRvumcrM7cNfHaKJkhO+14FTS8AnsbSM/f8Hb+/sLf/8sOova63/7D1xSdOHDHl4XSwHiqxb8k38Zsw5/3u9fiazserhQZFXEp0lnfq1OQP/277sBfubYrvyX2eGPpwgQMeYDGP8h1ULY2zld//KpcrW82wP+P/T/5/986Mt3GUm10bKzvq/+iHmlBadDp+n/8Jafv+Dt/fmFl0eIsYPdLWqfD5XnCIQddQdO9qNCKKgF47fgH/qx1eGPMVNR0wp1T/4d/60/fvElaadWxurRWd/7fZ66nevgX54LUnizcYf+d31+dXGB8dXiiEpJWHT0C/70r7cb/H3SPw77VdTeHzer8UMN6l4bTjXvOS2WCd//G96m7xc+EqTesefgSKbWKpdzu+G/Lqy4AXejE70Fb+G34PNF5liYDTvrf38fUuVI1z/9Q8lV6M7f1Lem16yn43AkqilRtp31ff3b4q/53/bjd/5UWChm7asA33n5Ej11WWR0Y+BATRt8895cRUw1gEt8eMxxs//v99UKUrrwX/r+L/hb//3Cay8UTVmRo67/tSEBXc969kd/VRvUkc/gCHDMEd3HMT7KR/E2iNvy8b4fQOsB4H/q1/XOHbh/gH+oSw/gn/7m9BrJapJVm4JNRPFzv0T1dL2NT/vL8IjIsYmvfvGjhayeHH/f2Z/3+xHFcSZ/zP/Wv7/4X/9J7JyPb/zbB/x3K3bJW8beNz+ZxsB/7wJBWx71fOw4KWWmVXfGdxZ34qh9tLd/+nsIsL6eHc6RdoL46M0/wo0moy9/13ln/971G+R42Bt99d+17MC/91OFvf+p/99P7p39ffd/Ux7ixP93/Pf5+x2/Ba8XYZZPpKzfhr/rI/GncXT79k8VgX7/6eFYxeV+9PN+aNLhH2nerxKZB/n49MfQaWd/VNtHaxScAD8Pj6LwauG/9WOT3yDcEPDv19i2tLPekc/3/VBsn4C+d/7FLg6Rp2obPCj0pAL9u31wNVfk+gjPJtd+zu1Z13586p8lgL/ntz0BlY/xH/w9A//EvB4Kz2PVsU+BNOLu3NCD8X/hJAqrCu8b+9aCby9JvxxyYdf+1ltOUE5zgKuS5TCteIxvKu9g8MdHp96nvxf3KmH9MqgJsJAAJ9Oa0GLCxQKzhBPoH6uB/0Pf+3z+zv/Ob4Az1dHf3/pWFazv059wcuv6hw196DTW/4C/5fMvOD0UJMSFAPFnCz4NZP3kqlk3/7AaA/2OCvJbzMxhwlVph7/v/ntUtJrzg7acWZ1P3f1hHL4QYwb6wd1e+6HoaID/ya+MquYZbI77dObA+lpwWMKzKAJPaMPf8b+YdPfHCgWu5JYPmP/T/+skdPjjLCMS49MO9MM/63vDf9f3C1cvSuigdQL8acHf/bH87Rzwd8LawKPRrcewdiQaDfcw/z/8eZ/vX/5QR5JKxQR8kkrVtPCCVGD46uADXXTx1bH7qHLuCPO38N/1Ofil3Y1fm/staD4A+1e96BCJbjf/Yt0XaCGbaAL2eUEHx+fuCfODtX8WhAD/A2uLnuiMQb+KGDspweuO/LzvX6vreK9j2w25UpA3Xf43jYnx8QH2aT8PRYHL7l35jizuiZQZ0PcP/W//6Zf+9/2Q5wnoo8eykovzo8mPUwfVH/p+8cHeFScMLnC/jR8MTCXvDc2RrLINRGizNeyPOpRBfygZwG0BIdR3AE5mbmHhmGv43+QvEJ/9xb/3+n759wtX82u4yu0mvm3B+4fCEr3jEuKnYw5TpWvg77c+jADwh34yLF/qdfIL7/pE9FKCf2botZAPQ6O7v7OUk1AUAr4+o/2QJ1pXv9kbTuDcHeC/3+eQu9rl/2f8HeCzmyQhaUs763POK7Df92D/B30t/Ia+6yMXQmnb5Nc/52MF+6NNFjigg/+xvnlv5GLS6JcW/nNTCseq4Ec3Yg3CGI3I7T/5GwM8WHt6RfavTvyqhxPky4/rTvkX/vbPfuGf/tZyDfSV9yrD2gP2VzVOcH6G3fHpk1T3ph9nv43/zu+Y4003//bxD71YwVovtlN79D/oO0/ITt04EJ+8/TOec0YZFW5okjuNfnvnp8Bl0xRckURJkCB2vz+5A2Uh14I2wOImBP9g/+ysz5D2yEQbOx78S1/Lf23ou81uONU2zfwEMbAnzfn55p+a+RGupZwXXp39//bv4jvjE03OVfTO37TGt8R6mEt41ZFf26zRVglSiP8CBeRApAXg99UiLIaNfVQ/9dHHwJ+BUGlgDwGOw1VZo3sA9vGb/2zg/4z/pu93/F84cQhXItOE+KMF/9jX3bJDnzEn3FUWhRji/1uEEq5fdPNLIwWV8mkN8b14cKW8uoed/B0WJezg8QDi98/9qFQA+tmJgT59y++9VDOMbK33qV/iXrr5E1r1wb97FfETk1rg8t6puz5nbEJkpvd293/nf9uP3/ndWTIIObEP84vrghb9QPuPf838LfybFPRR2uSXWvif+HbsM5lKKYdQtYb9eftPdIGAP4ejqDMtd7v5y6Y+A7nruz/g7/j9F95/JQqq1WZ8jEcRtpr9JetMEeQt6uCrpMR84TXnr4V/O3lWc9+S3XBlPrj80dinb/2Dvnb+5tddibX3V3vOcIFfh90ZY/46QK886tJfDJvuH2ttj5VY6JU12I+Ofxu9uLW8YfEZC55oFW5pd9bnZy/OVLgV4P8z/9u//Z3/Uz8zAvrVPcn76NXoR0O9IF8JG/qRmTond+J09l9N5hicMbezPtV08jp/86c1/tv/HsYD4M/wkk/zW3O+3Kb/CiW33R4LmNdFvyewtnzjT33o1279L/wtX7/wcpBpJ7eA8VVHyatcf8D+GeJJNYjUHZ/E/KqXB03+qYWvceUgfD3Tjv780n/SlljbiLrlTYNmfRPMFRzhe0w/3OB8Jltt/bFP9ebE2vi6F3ORMopg/DN37JkieXbWp98hqKRPl1/+i/+2D7/43/xECPN/vv+85fPT/7qZ/1M/SDc6/FGb/gxYcOLlt37H9d49n5/7vUetMz+q0CD3RNBPrfnf72MEtuvK7z4gU/WW72Z4MJbkkpMOgK8OwnV+3zTfp5r+P4o5g/H/wX/L3y/+p79wAvjf/HtuCT/57VncxleNknuh8QXinxb+Oz9ic+fwhjMaank4Y3D+tBc3UCrchf/S34I7W8+yzNDp7J/J3TFT+yo/wUHcxOpK1tk/+8yRmJjrePLZ34pYHf4bPYwtEswB/q3fG3b2911fRb3K/Ohf+t7wv+hXi3lTf0GvxDZcN44vJBAKcPteUCzXYo/RIFEfOKvi2Ve/rJ5hJz/c1M+SJ/xuiYuJyyF+l4ed/NwxRXduM+dh/sCLi9CPOvDv/VBtN8H32lNFS5p1+BvSghRYWO5G/87/1k+/8//C6epWmIW8aOz3L5xfuA+zuu3Djv2/D5WrwhbxCD+bSyeeeg/b/A0//bcqmH+Tlnf06qPO+09wq5GtuDas79N/qdwFMoncUM/PauP/fOrP7EF+v/cDNoGsqhR5+a2Rz2Atgv8zbeAf/1H87S/yjj83A7Kis0n8B/xtP/+EewYui8cM9FMLnp8WStlPZ0HHv/3kd+x434LTXlNKIGvlfxr4Xsyf4WA4DbLv+41hwTM/OqEjmgY86Kc07OXVkPfb8kGb+gSycYvXH/sjZS+/vT4v0ZVSng6Af6NXRiy/vwo6/v2nP10Pzs8/9L/hv/R5u6QWqlz1O/rhU1/gBvqnDw5vqt4mfud8LbCyhh2A+atH7Fl+fum8v/7qH0+bYbWPUDKUD/6NnuB/F8G9sT8zlyuVdQX689ufaO5lWD3nNQKXrP/zvsuNO/DW/v4f8Pf+/sLHJQTOnrrybt/3v0YTfzX18ZRbCfTfzvlT6JmZ117f+36OakdAf7GTylwJJ14nv+4wlanHKcA/9c+epifj+z7focXN41nY9AeTt41+UsPrCyLUpv+FXa/NYve+f+bl6lxVtnB+WvDf8VvwbFmxAt+vnffn7/fvdKB2x2/tz/+B/5bfX/z9xnweX/Uc9t+T8ixXvEJg5sDEU6L1tBFGJa0FMWjgalRs8LEoej/vx198Z3xxyvG5Ju567fE//d+1Zed8En+iTtU4Afq2XPQyFasKOvn5T3/Yg+Z/8wP52ZeJGuBbYSU3nrmph84yMjvro8HqSXEvTsX2/FccIqEy776szsPqWNieJTK3qZ+u9HSg3xhXJgv5fvDH98lt7H++LynHoHP+jexCdpRO4Hx9z8e2o1++/d3HoP+0eKGEg2ISeFTiWb+wmvslRFygiBu8mvsFUWFhVU7BvqaHoi52etNrGw2slO6vKsQXVDYqau9a7/cR83Z9hXJBpA4+/X8qzP9n/xq4Jg8kX3ma43MLThIhuKIw84Zt+F1wubDWtf/8kwbfR3fpyi3LiODZ62QwLwT/jo5AMArerST2rb+3fCl4eg851J+3+g8CfnhjakG0J9Vb86uBjSQ0L+N+e/53ft11wX4TDHYOHa47EXyRmFtwufVqr4+8psUexyF7/b2+/+Z/tOHv/lKybbfW92BGPZV1dOApwawA76f3iFv0P5hpz9WYsGutf+onOLcRxB+zaoQLCFUb+ewP79ycbsn3fUA879RXoGC6DqqURzZ+WKxI/Z4rRwpaFNNi97Kkn/s501jHYAvkvH5urBvpzdiimCzB/3M+/fme0ROPvIxggzM1GSfHyi6aDCxzHzv0lA22VXDuLu6oerb6EwL/rbWkccRcUvDf4rAse/dbpz6CEWVoIe8u2yW+K5Wf2sdVp76GLz1RJMe7eo/7WhxZoTkJ2/Kn6oq05/jNdoKXq5A7Dk5hRz717KWl1M4j/7s/tIkPxhLHod4Q/EM3GYil4mUb5cd/6nfqS4TZkqR4tKOgn+9X8G8vVac+BdY5zlW0Ex3hvVtWSLrWbka8QzjIJ14M/iF3UwbyfrHdY4tKLzQwT05G8Q7FebUH+bORBl63eKAQP8Xu9ThUhl57/3SzOXjitgb/fpftKhs5royVe2ih+0vuM3WeKE+5P9iuP/kZQVh36nuYZsWNlNMZxjfqW5Sa+3tn/O/5wLSHlWtyTKTFSaFIJ6GfB3PwD771U+c7HU9XZd+UTt36Isbe5xC3aOg7rKO+2ZN5zyMZfdT57grn08WOlHPsQdd4H6S0svDSBf+U5jEaZqLINCdEA3maAn+egpQdq+XG8Qi3LvtodgP94MaMjsH/jsANJ/E01daG25YPsiOKKQsnuv/WfxFNu73/3/zKuH7icZT6TD9u3Tb8m3/gYP2hao1EEssd+X33F6fZBuYvA0vFhr01b/iZrErUL+MhI5uFrCD9BvgCb4plzTX1e1rjP0YoQat6O8CzqeicVKeG8eorhnhsfZJ+3k+ZGsEXLFqp5qyU3/4woL/igJtwk8uOYF+KOBNZttGm//u++wb7c+2b61xcaJ31B5qk1DIcIIJVUhBsxdlwIaND8MgX00pg2pJTZmhc8wTzeBdYej/iFq35v/X7U7APP7/mfv+gYLh3bN7HTIdogHr7xv/4D06OZbDKZ468Y8HrQcZk0+fbcFCvpYt2UXpg5l3CKl0z3m7jD5rGkusrnrNv/Veb11tw+rqWO2SL2YyFwyV9NE+Dnti8FQmjJ8Fpn89v/j7R2uO34N/7ratde33EA27h1/I2Z3Tel4mCAtrBH8tYB+JOM2YQLC3QsdFvLfzv+6DTktnToVWQ0fN1buPzg2pUjK1TzrR7heeYe2za46ugrexieF4cyqdugP5LPfAfWvDzsryC7rTG7Fsfeca34d/3EwvgR1CWsiCPsmrQ5t9WYbSIpIIx/zSmK3Uu4/b+qPu9IubzHn9k+PXgJDRKwD9pjS9CAI5SlK2ZV91VDQuZ1p6frHPw3/JVtvx5370H/6nWzKcw8J92xz429dEgvtq1x6eKAuvnjiedgViSC4WD15EvPcN9vGJ5L6yWZ/VGD0/c2Z/rtEqKjSvtSukmDRO0Q6Xcfp/y0ti1mJ7rOFS2pWQrez0X23CdIYgVcm3JzOYdoZycyRofSwqaenzUZXIU0Rz+CJNSKJ7khQd5V75TFzkoBm+FmfFBPeHaGnf4v1/kRb5juxHoH3UYKo+5Ovm7Ptf3+7gD+3uBoxy+yp4u43NS3tDeu55Knl7wRVWHHfn9nq+FqP08X1K1Dny0Lq28SArKrKb/qDLpxR35C7R8m9sakkJRCfBOHWpRZ/+POePh/NeDkEtS8JMRIaS9PwcyGhfn1VYLBfcOFMbXYt2Gb9PRDYaN+PK54mmlyi7e/1E/k1bl8Lc/y5/1NVv9W1r0HxHb42BF5RCpPblGT5u2zx817QeXj4exB/71GiHusSQd/BSjLZok3pQ5osxd5UJeKx14Fjr5rvlQ58gDylP/ue3AhSQs8vmwiJl+UTifKy7rtn7Aq9x44boMzj/9sbevNj5Nho1/m+R3EI2hydHVZtzmn3riuBeKFKkOe7UP9mUbqh35pxYL8VjiHWZIEsjHaf7steHxhMD5X2Z69a0vntUd/aUscVrspcyt3vcrybTxn9vj+xC/7CIzCofTGTdQ4vmzDSePivmFKke7UonGnM6xaNSRj/AcjpBFLcLwyQITLlxJ53xrXuUVA2u7CwUNpIny8bpzvrgxeRXHYvssnxbYF6qbHfugnrf5IY9Wml4FJJJ6cliAfZ4OY1x5QgrnZ0RWo3wbIKGUxgeUI38B8n00j0pYXZDhtepXf/uzXsD/ns5vhPn63fDomh85xc2ifFm5O1hff7Zp7x8u5izBk2cFom0N9FR9nlRws51YPQUXpMlEvCKU58lVLF9ja4i4gUoVPFQqmppwvm//zd8rpdWTO6MI0/v/53yc8W4ESq7v37Wb+jjfB/mVhnzZD9ZaQMQT+Gf3OpKS3lTSPAweUZW7cv4q6/sYj1VZjzr8XwzWh6IfXYWy3syHidzDmxFOtpZ+soZPQ1bNdTEvDL28lkPF53z5nHfsq7rY5ZNcGNV8OCArwlHZJE9s3SkniJwL/lG6Dhl6zAqjen8/wnqt6dizwU4P+wddVj2JHYr1WLN++lMtwD+6JR49ue7CzAiS1teiyumrHM7QoOSSx2uGr5tEMp8sNDJCWXlGWRUdy6EvOA91NX7d2+dr5lZWIaO6KGVyhf27UTL5W7/4tMfl3HZK9P+P/unY900OinfwqK/gD945iu5s9MSD5XEQVqkJ/qOa4Fkx65lRKck3FHJ2OCbf+pmmZHrqAMQW4nenKBEiiHC7GPyDxRK8+6dSmaB/dsW40AYlGK+m/gk3L2F//m/6/9KvbfgE90agL7n6ZvzWzyxKTgzRlZsqoztGz1w0lUBw2vb7ez/yAfY/dsOJydPUlnE6CpWcd+QnI01/PW5o7WbYX1zRUZiORp34BrxRV4ks8N8/96cOh058/H6/xD0C0E/Cs1ALwytGbf9NBe02xT0X4Mo100SicB389/sZWskQP/rRVkzqy6kz//t+E7Ei8O/f96NFdOiM/60vJUR7PF27UiLuYoB/v+9Zz8/3EyzyYF9+8SnOqxeeZbdnG/9zv+78GmWEn48mRe0C/re/3BjityK/2YU/nnbo/95P2NAnXklXORe9euSRxaNaFBonVp/6XtjvgX743j/qd+J/i8YkxnoVTT79YR1n3MlPkOFTGqHRYzv6vo+8LmD+ZVIU4L+msH9IUz1KX1sbV0mpoP5A7/DP0UeKzQ0CiH8/9+euo058GYBvcMOvHsQfxmYrluL82aEvuOQcCOWh7n3vt3K7DtzfpBxRKhn0Y+aCvXafvbDNn29/sGs0wJvBdWC+rtNufcnXTT1gbw/82d7BqQynl05+BTx9TSX0tIX4sHa5su9sOnDrpWJGkxfEb5/3MfuyM7/mDLUDzWoY3zPMYa6YmIF/rVYZ3m+LJ1P5SC6517ke4NyxtNTFFoyvyNww76/k6ie/k8P6VudQDKXxpLM/3/qVt6iHH6/UTD19xG4EXZkG/L5VjPo35akkmA6+73tvMaz/plcGdlYgH9/8+Rj4/+2/I3Tox/MUp9TYgX41hosqlx/bzv59438Z4rOzVlgnw5138gvv/A2364N/+blfswm7+YV7CPb70ORnZzgbFcFp4nbO/6e/raaN8DVHZSKWk8742uqsGmrqwPzqGZXH3qTnZ6RMUYzOgvhktnLnapmm4P9eNwv+qJzP3o2cRK7Mb/zuv/w8g/mHQRql4VT0O/md0wlv1IQA/ePb9nFE16Xb1M8MnrlZea9P/ze5HoF+W4iihYO+3dmf7/vWsL5jhViWiB+zjvx8+6M171vf78ewfO3gf/t3RdH68/1NPjbfx5dmVWO3b1XMPWJyI2G47eH9OMaW48tMJnmBNnmhseenvh0WzxD/fvu/Pzr8c1+FbHPhGuTDuIDXwRvd9auf/vbbWMfpSeqFYroK2vRrhIB8iTHwP9wLXCnrG7+9f1o1VZ7y7NnYZwNHBalnnfGxMAH/uiA8wX5+lNAzW3bGJ9xMyRWleV86pMdBIkQ0yL71U0qtYkSZczO0sGD+FV7wiRCmvkwdAXHo0Ohfyx5AIDG7QfxSB6IrEjYMOvL98c/u4B/6yY0yPQD9T1C1uuTaLnsxtTdFS8Xd1pOPfuMGsw7+tz7fAugHwn2L6JsO/cFmq1okM8H///Qvr+0O/vv7Lw1moJ8OjgTBZE/s5A+/7+MHgH+Uo7JExaADN+VSjenTAvoHkx34sWwe3lQ8Kfq4wtqT6eUQ73BfBPouvWudoOUw/Hn/arKK2XMX4rN4Cvjv98uvd/3bmK+0YhrHoJ/kDVpzZcOfi7vTRX9vdPKfDlsqSy6jIL/3h3kRhOOrQ18oJxxBUQ7+5bc+itOBf+lr9Nf7faWz9Dv5Q7yK5VIJ19HzY//08bajv23Vlp7KYQT+AUEisehmE3b0UxVA/PWowH5X2+3L7KXd/C2egTNIRxWcj/f7XM+TRxCfCbhXHFZVzYz5jTZGJ1q27XfuBre8Mjy+bb8fqeakai8F++8IjxI4rckMj54QiAkybeOTumB9fHzGchs/uaW0IHvl9/7XacjU41omyiqj67/8D9TGV3dbyeQwAfpmjI2L1cEaMnpX9EAlT/DfJaMchvJhN/K+33+3lcz005jryXYB8k2sYy+RT7PO+O/+McrMAPrf+d36ko7a+UMtdCQTqQnot+iSOYVPORhf7xOjUOc3GD/ekinxh9EZz3VwWIkz6eA71l7jVNsE+j/9yQYuzL8fEau4y9rwp77aLur4T5/6NZNq0F5/T4pQKR0M0H+G81SLWBRFZtwz8sLpGeLTnKuVRNnOmayGFPyjvaJJzNyUSFGUZ23jSNMc0ZeszvcpE93QBKUH8F8+7ze9YYd+D6ySxKVN/uPz/m1xBf/IldkcIqCmvsGnvhSC8bnLyU51W4X9dZORAY5pJjK8HcpnRJr63WfFVNDweQH523tEhSDs1GNka5CL6kJIiefbmIre1oT5B/pzhDXXgvGjo0IUA9FJiz/f+h5c8/32lz9m7zo49u4XwI+1coBWEi8y/9Mf7wHre9dv0LM+4N8WTMTDS3P/bhpKvlxegP/mRLQs31oA/5cKqzG4a4PP/S4aPms4/2qhM7wbwPqEJbEwfwb6gosJinl83p6/98uLHoyfuyXKRR3Ol6dGygipzfj3jCfMFmjn+x65TrQbNi04fxPdlc0XkNSRfz1SDTpH/ORb3zU+QnzssWpa3J0C9lerCVPhAC/x3G3uXxu62fn+Qzwi0t1aW37fz67Mzvzf+gsy6BcnSNBRGfW79M1EtEb3K+ineVoLiSQ18GUTRAzFk8woddU5HhhNfRFw9cLeYNn5/vi+/yxHLzh/9Sa5hPxlane+XxxVsJ+TBdi3vWRp2BhZbls+dY5yNoddsM+1kBGmy1zn+5l3FEC8rwPwP4c2vQv9Y9T5PmbNsazLJx7in+piEeYO/h9nb9ecPM+sC/6VXeuUXWW+MXPmL8CAwU6AACe7AgkmkAAJiQ1MzX8f6RKoJT8kvmdW1Xuv9NO61K1Wq7slGftb8//r+8ltFj/fgka1Ys59Tf/h8rH5YL6HDH+tP2caH+9Pdt4iNn68H7z74Wr9X7//ZjH/TktGeXqeXDT+9fsSZZYfNl7Q2ruj12h5/X2Be2xG7fO0GRrumuXP+jZuxR33jeGfW5YZ936q5m19PDH8Ik3ttN9KdP1KbNPWXNmjpuUtWLGUVpptVb5TMZy2/VRj9WMQsf1xeRJp94d4f2rB3bP9ifj+Hn/noML3Hs/NlpGcmP93vxeXVWldDzX78uezCz8vbP9mmakVDQdzDW/13tmma+Sz/N1kVXDk1FsavvNoFt6b/QYb//dz/2dVetmFpt1JVh2j6Y2ZfawjCyX9mOERn2oLPwrcKb8K/3mImpF3nhnvzTHOJ7+tMG19eFr/vULFTp1HXr9tFpWfSrVb0/ynPXbZ+i+6jI/9efm9MNTm7xLU3wu9hNWX3rb/k5xbrxrfbr02J8bXbmxbhbFbDwuHQOt/4M8ajaYZMft+GBcW375NjY/3ZxdWT1vm//PAr/bWleF/5s99arD65aM8G/idx8eh6QafqWWtbOY/OD+yLjt+f8mNUpj/hEs7joZlo3Zh9mPFbLNWOLS8ltVeR6HvHIba/V+7/WgHrjm6NK1DKWgxf9bvp/H7SXf2xOrz18H+ce8F8+Ed/Xv8/ShuMNl3ntoa3n6uFHZmOGH1r7gfdeb69yXMSqFSOJYY/tu9/LCtRFHr/1rfT9j8mjWmf/ASavxhejS+zY8Niy+fu/7Xyvzqaf0HL4+FZnP6OB5YznHP9t/HV/78TD89xdUz/z5FaNhje1tj+F4zHe075Smrzwf80mnNNjNRKL7fEnjd6/dNCz3Nfni/pRG9bruWz5aI1Vt6Wnyz5/z5wOcHJh/vhykZEw3fPb3xT8T4fP92sQYzu1LX+Nf3m7e5fe3L1yo9f2n9u/uRvXTm3e3E6rhLr2r5b8HSeXmMn61e7JssXz1bbedrP36wgv0oCc+H9iBwnwbx0np5YuPD82tO54fpt9hcTkbpxehq42v+2M/W6Jk/v4Pvv6/sjpo/+t1Zc1pI9ix/GWf+vYZTRce/+oVa4Wcynl+/H3yo+6wiPYaMVx43ouGLaXvWoM745Y71Ue0/z3pHy3h6NY3HU9C4nW8k48n1/df9aajKd3d2Y1HwXi8v1udiWp6Wg0lkun22Aqy6XyxGg+O7sTLTmK3fzqHoxZ2HAaufyi9xxepWTaX+PSn8a+94Poz4HxuzW3UePO35WP51ysAaeqx/4js/NWNp/AyWRZVP+il4RT/iO0P+PcmgFZdV/uUSt6r9C6/vZidWnb2Z1oXFp03Ldy8vbH1evy/In+8R8bM7K7H9YeSa9vyFxR9lfOL9pq19WR3f9+OonJz6U4b/CcMOLxtP4nzFfp+z/tflTTVsTlNNf8fYWEsr8Bl+0gpLOyM8a3y/EbFFV7L5+7s+OpVpyTyx8V2f341rbP1vvB87/NL1E/8n3q9yZ36cw8CorzqbqKrylfkfz5Ol0b541fv2VfpX+JXlV80oPmxY/8tBIVkNqlbjlh9PLL99x5fC7mL0+fP13dMoTi9scHYldsvW4MVl8fGSeqnb6EZHd/55Cq3ZW7EetXZTtv964fNzXO9qnbRy0OWL95Px97fh/S0no8fwn8f1Y1y2x7Vo0J+b783nF5b/l6dVYXpZnTV8v+c6nluyWf7svm8aySnk8n8MqxxbbZ8Vm4fPwqgQcvmK/z5/JixoPRfLqn++u5VqWHlOGN44sf3LxGPzMxh82kfn4XGk+rc16iXPq9FuXL3v/4p+Cr86Siph4/Sh8QMWWp+sjyPLP8VJUt/Vxm/a+MLz0Do6Ps8f5fKoNi2FbY3vDYJmv9ncsvww/NyVdo1WV1uf1/PnT1YfNRthaVr/KGj+iee3ncork4/373b9sb4+xfu/ekw+fl9mR+9s/9B8SwLD+/SLkTVcN6bmyw+rL6eO14mtp0j7fUXvMqufTPNZ51ccK47fu9vifb47azOtepVtWeVf6xO2/7L6C6O5+qqwLUl7WCpMjcnZvfILu7km//p81ZKtL+rfWZ2GrFRoHau/6Ef2Vfj4/Ym76Wn89q5s752PMev/en7P6++fJCwZyTPbvwye2O7ESnub2vX7v25X+33E4OGjeTEXO87n83+aNLXfX/RrqdV2D03mf0EnmvjeqKE9n3/9fkCN1T+nYNuK/eIs1OJP0WiuC4Ulq5/E99M3Be35/ev7Y/j5H/Xv2NvVYbXw90W1/0LRbM/a869w6Ty9pa7V4vxr/dIaq3ylf4WP9wsUJkeNj+ezCsV03L3VNzPt+1TX5+O/ttf3h1USX+P7tY/Ce2GwYfXJ4nXbtwbva2afx/XqY/Vz4M8PHxdNozmeMXxcmV6Sc3cTBu4oNELjbHqXyPbY/tYtzZh+iO+l8YWNz2hHl9gsV0uRPz/apt1f6eOP8VGNEn/+nsZ32Ru16aXXYfLtVfJmPITF0+399BNmf/F91dqjPj/Cvm+s/h7sVsWklHL5H5PTyKpsolrksejzYzW5fGX+Z+3X88p5Y/6rzM9//APPF9+bP4V/d/7sl0rys2o426rKf7BTLx4sTeY//WN8sB77LP67Lx3bZ6GJv1+wlnb2w2cnDOz3/npqDSdmI7Ieu2x/0Hti9fftfITx+aGF8fbOxnd9/8CU2afzaoUzq9LXfh9jxfz9x513fj76VKl2ap2J/vsZ8f2dLya/8n4czMITm1/7o1X4WRXb1cotvvH5VezTG9g9yypFZdU+5H9utZx8rF57xbLqf8S3D6NVYnxUWPxX+Nf3e6bMv8yX+DP+Hs9q4vdlzvlcbP3Xv5Xfh3B8o+719t3HN/33K/z3u9bbenv9fbn5UtDGP+xvraPbnjJ+82AGaZA2tPkN/C2rP2qVorq+bIOlglWZ12eK/P1n0N8HNbb/cC/vbP99qrP6Ed9HsoZttn9+2ac9vzfl39/7jh+c2Jsx+1ivhr20Js9s/RKfmSF5WC3rs+J9vuL/Cn92Wdpp1+LP11ftqBSH76y+GzhlY16wq0z/Yic8J4XYH5jX3/fx+m64GhX6BafB8OL7Lf5ee/7/+n4Wm9nnpb2dzIJTqPGD54l9dNMOq/8PNd/e+4fy8DZ/Tyarr6ae/ew+tPTxK/55d3ztr+F+5ZfZ+lT4q/XlZ1epztj+66kal6zSZFlj+T9m/uvUGf+6vt615/vDr4O9tIs2G/+pUhzuu0Wd33r/Zvv/ksf3V6Y3ilpd1r/zdimcVsYuqkS++D5niY3/1fU6fn971t8vlA7sV+el3xrc3i/S0vJbp9J1eq5he3Prpzx20/bQ0H4/HJhVhjerxcP1fP9hp/++n7+/0Ri+eU3rrbkrrYrpSHu/RfvxxXqynIFXutZ/hZn2fgx8v8pc1t9ty52E1aQ8+dR+n+o+v9lV6y0uri3fTMqVUnet1Udu2ze+CnGb6Y/3Z7hsG67xd0fLd3sdtn8reFE3HbL/pq0v/n4A57NRZPXPbOv7btvU8zffX1pfHRZ/jBUr9cPPpmY/rD+39uU2r78/tl3t94H4fqMxZKnbSrthqVP0qxofz8cWPsds/qr74pDVM2eWP+xu+mCNGiz+dge2bbrHJ1afvfQv9WnxWNHw1++rDJj+m8itJ6dkpX8fkX//y7X470/8z9F5lwYtxh9YdmjV9kfWf7HvvFn+icUvcf5ZjbXxX98/9snyF87P2vtH/fefH9WWb42X/HyO26/fOkRLN7asQ8yyNcsP9aZdsAcus8/WSirTc/sUBc7esF1r+bFvRK2NZ343P6sM33iI2ulgcNTePxN4pvVsBV6pK/zLTPX58Tbb5oiVqiz/vG9Tb9bpVvT3WwZru22N3tj4yp9LL2qffH1/Mhkap6bf4PWRtW9brfRJ849u69Q0Co9nbyDeL1s8P2n2x/uvrfM7s+9nddz23VJP//2u2D+GrH4R54tvEy1+u+8/TmC1Tiz+iN9feQPt95F+0Sp8FRZD1v/D/MsMT5eCvn/cl6yC6/P7/y+v3wjPD75mH9Q3bv+HxR/x/YroVXu/Er6fy0Y4YfFrYtRWp1VL2x9cv1/d4r9P/VrVV9VCQXt/Qb/sFzqmWd9e3/88rNX09/O4/GL45bBtivfj+IeN9vv36/06//220WT7u4s11d7/05mvmyVjNSyWrOdxpWGcvota/Xydvxlbn+d1w+xcvsfa/mj49dqcmP43Wx/i+66fRX3/sAi8oT0tMv/E+9u6nx3t98PX76fx+CC+T3Fua/y+8VOwCz815l+Tk1GusK2sxh9W+O/TTk22/5pG23DG9rNafY/3t9rxZ3HAyoiknhiHmja+6/nzlJ9viudvPrT+8X4Zs/nN/AfxxfRH2viv54Ot8cPt+RL9fKbVaFtVZz7g/s1//9kqeRrfntbtJ7YwmP82WsuHffvyre0v8IdjjZj85jT24w6rarXzpZ8F67/+wvzz5Wncrg4mun/h+1z2j8t//4DnT9Y7Tf9r/fnO+B+Vr3JScnT7eNVmoWTsP5h/f79Oa9OKvdHsg/fXFYwT3z/0Gpdd0+m4pnPsr3vxqcZi8fX3mUtvbT0Em/rqMt12AqeYJOPVfsb3//z7WmZ7tX25vn89LgXB9f1aLMXf9p81Zt+nl+UgbhX9wdL6ap8sa++y/dP1+YuYrd80TR9mzmwQmPazse6w9cp/v8Sfz3E3XvHBevA272H68tENnO93u2sNI7Mofh9nPuzZ+isetnsraIx7S3cVr9vxY4Ptzwff28KkOSrz368Hq1qlXGm1A3t6tlpxdcb9s7W0LevjzPRvDGZOtbOc+MH19+c2v98bJ/abbUTjl2v9te51l9f3i833LNc4BWdodeLx3Gr8TDer2uusJ99/xN+fEnuFufny4U2s/qjaSjvrVhBYP7WTzZ+Xq0b9St8q25Mqs8/i7Heq4XLhmG4QrTortvsoRfalyqrJ+GO8tkaT6WXVOL4EpvXzaY/iWd+rRd2PJ2NiPrvMPq8dy41b3+vB8np+dy6y/LTo23u3M2fr56HfL04L5tNA3l+alcgqjll8c1fM/qdGw2Tx2/WOjvf44Fvmha+PpGPX3VbI5H9/uubKPMw80/36KByMhcHqU+ehaH3YL30Wn6KfyPY7Tc8PXK/yWl3VP82SeH7RKQ35/WXtYhqpPWof7UuLhdLvIpv/a333xX8fju8jT96CoztdrkYr32P6Xd/v8MDsM54tGpXix7p1dOb9YdUI3rbl2/utTYZ/3ZnhfvDKv29zspMXthkN0tv3K9JW//p9S2sSBfL7WmeVP1o1WCqf+N3gmp99HR9ajWZSOnut4Pr72Lml8evVmT/zTrFXtFeNaGU9+3uNP2oV23tWVqSLQuWh8G3Ua3r/idMxptXHWH7/rOJpfLw/q1l/6o8dt2l8GZXRVuMjPzSch6Bov5eZfb7elxq/z6rl2fAwHHrOvG09xaUnXf/wXBzG9nfE4tfGD99XP6fAS/v9Z6Nf+Dy3Otf6fpKGppOeeaqbzkapghffl57z/Hw42sV4NqmXbt+X4fzqtvpYdapzxn/sx+P4NPbGqvzn7e64Ok+moemeykbDeF16G5V//b6kO9y6RoltlOrf+yeVj/cPXewz4yebH8PYL+MPlZ+OUnsfpIxv1cxVeXUpbpaqfuL71cFxuHX2bryOo5/9ozo+Z5z29oPZ8yC4fr98l2r22/SK47R7eeXfZ0+Gn0bpM9L44vngscfi7/ljsFmtf2ZHlX88p+M0bPb6R2e7Zsj1NNbwYv+7moW39699+Rp/PFsVpycrGprOR7par56PsaPqP9saLP6Fy+HRfSyvuqun76Or4ptLwzQqfX/Av7/F5nceHbsqv7ueppXKV3swtubvP8nqLZgaiWK/4qrzuToXj2x/VipaU2t4Wa5U/PdTeO5cpvFg7LQ/0yBuHOj7z5x/ep/1Zl6txvaL4vmQIN2r/FarU6/UKk7naK/5a0Wj56LGrxwXn6ti42lwdJ1h6K8mH7HGF+e3o3awdM+twmTV8HT8e7qrrUq7AxtfLX4cxIX29qDye9XFd8foVlh+KY1WT8Z3uarhn5fJJSk4L0PTFi/l8k0NX66agW9/VIaenfyEr4bb2LOtyXBgDx3rm62vweqruGrWbGt7fb7pONP6dwtR3++WlsHYHQ8LD8ZkaWn+LfZfB6/nsR0Zy39fW0/DO51LvVK5bDueey4PN8Z5Huh8vD++WR8ETrlibFaN1l6bv1Lf/ZimNe/SMLo/4bfxOIu1+TN+jPq0UfFbgRUnqWuxSkXjF9ebJKmcfpj+pdfkYDhv/lTlfy3di1GO98HYab2xoD8db97U9bl6Tz6NunNm60N839TZavpd6+uE1Qe1dGUarY2lyZ89uM1V0TsPPNucpbG1OQajFM9Pmc2fUuf6/O2THYztYjcNrMJx+6CuH/H85ykIWH7prGYrc9MwkjPPT3bl8t6xvnezQeq8fvSK7r4QDa23s6nJx/Mh9XF5uLTeXuMwnvVYfOlOtkbHbF2Y/FPfG8z6B/786qy08lezdNdS11fUHVu+vV+yLU+tlBxW9jDVxn/0k0ZSfbp4bCM5SsM4fjpq8hdm0Zv5Routj2QTVtgfQaTNX9XrRP1k0fPs/ik5rxYPVl/ltydLttMM7N7Y9t5Y/hi1tp5qH2+SurNBrdY5Xr8vNR5r/c8mgT8bfH6wfD/7iIP43NX5u3jV2NU6jWBp7WpGezWL6PtTWN94/5NX7y2dj/f0Iz6ZxaHKx/dbKsuXwdJ9bScPhmnFXtpLloWDef5m8/NmjoNq23hn/f/M45612Ry7qv6lt059akw+rLH9sosXltXwNP1Gfr8aprWnDvOfHxbEk0ms8Zu9lRGWyk1ffv/SfVT9d1hefCant3k/sN9L5t54Sz8q6vzuzdSu9r4OHc86L9JibJ+PA83/Fl47tmprFh/sYsIqqO44VPn2ZNvye6Nau2j3zvY2nlwalaTU9Ay3+Vpi/lUpN5qrmu8z/+j66yQOqouWqt/zcWunrbDtm44RPD7Gz+fhm6rfsucau8vptRU458P0GNftZ218XfeL2Sc2i32za7HZPM4/iyq//BD10kHzcOk35fd/U3zf1qmfJx3rPF0O/O6+YLH6xbQ7ceWlf05KYv91YfGxUwzrhtlY2oHbbRqr1fOlGmnzN9o/xcPvAYt/mwGLv6fmjPUv3o+T8PUVjS5TtsPpm9bKZvXVV+DWEjNcG/NCXGL9977G4cxpnLp8/9EsGK3DqpIU+fmQZZWY/wxeRz/TWlyyl+5i+Pq82jz2S0lxZhkvzcGJ6e/PPSduFxedozN5jXuxU0o1/UKvUutUjMfO0frahYExtDaVpM7fn9/cVpj8v38fO8/hv+TwBzn8hxz++i4/lfyuNXtl8a/bmLlHFiTTsWUtqk7aKq+MS7N3YfvbxbCSGEZvZR3v9f8L//r+x8nmdJdP8ltWVDPmiXHeKe8HUPo/5fC/749fyu/m8H+xn+Tb1uFSMTrn7qBjuiVnlRper58khdNXYWN0G9uT+L6WfZj5SzewVhfj89AoJI3AtiKrXhqXZP/tu/NTy+GfWH3O8gMbv/+Lfe7iMX+FXmti3+cPN2z/1Xz4cu77B/FPOfx1Tv8P1iPbkcXWc9raKvMv7fvL+KX+rRx+N6f/+3xL8b+/+Xn4PPvm8fP6H9zHy99Hlu7jlfn7m7++b79/5j/k6PeeI9/O4ZP/dCTfTZOGsM8ni5//5av2O9zv/47/3MeXcvi1nP5b9/EKv+eMY8v+sgobekDO4t/7tJzqKK7c57tWz47t5eG0uMtPFf5f8t9ZfLjbv/L+An/ebxiXoVUbmR9muo4nk+kkSSeuYTRfytHISr6PvtXdGKX+ff3/5k9z7NvMsZ9tfXxUzLA6b1RGhWMQfhi7ztc2MSufRqvwWjp3cuzXuK9fDj+145aVOj/jc8j294vXSrMUNb+MjrWqGP2o85M0DwfryYkGj537+VHp/258Vebvv3zm/xfC3/p3fun/52HmpJ36k317v2Kxc07Sp8Ry3NGQ6SfeT1QbhSreW9iW736VvEoO35D8YQ7+Pt+wFvbODA22517e4yc58pOc/ok/uNP/xBtZ04012lvt48C7x19JflC8z5f9m//ll7zQsmujs1EsrJh+be+lt+qNXk/Jpf9jvJuP223/+nz2MB0u7eFXYWmYs49qUnoYNefGpcb4ov/GKFxa63E8ix/T6VNSEN9ni71788f8o3jTr0P4o7NkhVf8FvcnSUHE1+64Q+Mb54x/fK9/hb+9j9/1OnXjxNam6Rye4m08TzdPN3zLm0r96feh1H+JzY+0b/CvfNX+f/MnivzhnfmbeH2y713/JPsP7+g3YfP/X77av8K/65+htO8wxz+HOfM3/GX+Nq3VT3jqnAaBPZ2uPozgY/qQnHcDu2rZx/E0Z/3c46vzM70+/1H5HCzt9dYoGmlhOk2M6sKu29096392rJx29fhtcLSHn1ZgvVeY/NNT1NwYbO+1sMp+FMb2kJ9Pkv9L/wn/nL+SOn9348Pf64fzXwvjMPI+/OHWOVStbdx7cGfJxYmb38ZlMVbseyc+lHLmh/MfCrGX9r+qbP0/VFehYcxHo8SYs4hhtt/HoXV+Ykq0IoONfzBd9Y1FLZwntUXPsAsVezuyntfFfhqOX4amu24aZePdNnrJuR/aT253Pf7bv3h8un7/8zAwXWt/cqyX8OIlKf9+irXoFKc58W10ff9GwPhue2tEq7AUPiZn8f2QDcPvypVGmA7580nPn83SavQzLCRn8X74V+Yf5jIeVodhdxjY7i7crmaLZMryU1qYm/OkqKzfO/PH/e9m3/Cu/TdW8sTPWwez/i/xW/J/WT+3+Mns2/TCyCi57lNyGh6Nl0K3x+wXhqtmp+Tw8/3nzbpuOftXI6mGK+vH6S0V/wzvxqe+5b+umqtaaoemNX9LA2sZ7EZJVTzf4I0V/70bH//O31r8uoPn/MJj+rD3K+XwaJeGlhdbtcU4qYnnE/fb/p34fM8+v8VX4gd39WPr45CkSWnI/M9JDyPLqp3K56Qqnv8ymP+I9y/8PLD13ZvZDWtz+jkn5c6D5Tgrl/mHOP//eNfyf7ee2m/W8mU8yomvoz/j14TFn7/j2z2+Or8Lq+FcCpX6ojc4uo1+mKw6z18vSUF832Kr4u/Gp0VO/hhdv7/TN4ZL9/X0czBG30k7KbzHxrzpNll82G384ay1GrD4Ep2Sn1X9q+MmZf77R6e4Zuvn+v2h2tC0e4XVynCKuzCp8N8POaMBi8+WsRxZvW2B9X+K4sB6/kp6iSHuf5kecv7C4N78hVR/qPVLzfwxmkbcU9fHXfv1qf/lf/tPWP8zOwqs/mbM/H8bDvfG+2g3TNKA/764NWL9r5/Nx337ccH9u/s6N7x2w0kK4v07bWX+76+vMCd/9K+/3xgMo8Dd1l+3q2kndJPi96mwLrSW2/D2+7JdFDg/wcvJMM0PI0mjs/VqjxO2vsXvwy7LgWnP1qu58dhqdBL+47KDGbwz+/rbSqGTNlIWH1vf1szyH78ek9Jj0w7cxdt4YaXHIotcEX+//KNRKBtR56udNOclq+xM0zH/XsgxsOzBhK2PYTEtWu+eGyRN37PfnLi/Vfzrbv6bXp/fateZ/f2veBD3v0aD2/u5Vur6uhtfpnfin84X35//LLD4OfhKH+Ph12qZVKNXtr/7XrP1L+Y/eBoe7eXoNTa+x0lH+Kc1ajD7DJedb9ae359an4UH49J1z8nZH1pH+2tdXPypHx/f9fsHMRt/9Hn8WQVm+ZScj0lhzjYlCv5+/vt7fXJ+td6pVOqlAbPf2U++VuN2wvLHA/8+3UubyS8Mvmq7ypsXmvaolExWLy+dWXKOt6w+L7+y9Yvvm5Va3L96S6O+8k3jMal1Fvab2+gy/xX7p8Ihulsf3/NfvX4+RJHH85//S/1yy4/dX/i389n+L/FdfJ/lqcnm/81cu7H3vGsntadNYdDccf+73n+sWPypr1b+qvF1uSSl7ZPzY7O96uL6febYZvjdIlkY+2j0klTjB+b/q70yP/f8q6T63y/7i/KmUuqk0YLJF/VpfbpPTuL7On0lf93fX65y8vvq+vx/6zEM7OpzOo9L78Z7Un45WJ/ue6+4sspjz9t39gGLz5Vu8sjq4908ScXzMdPi6k7+up9/7ueHVY5/rqzPQ6UQ1uzPUDtf4M8nO2+P41VO/Ftdn6+YX9j+clE0LqvmufOeFMX7Ux/Z+pXn97/4x43f+0V/eT7wi/537wcUfO/bKHSa7bN/tOj86po/VkWl/1/Gd7d+7w1iK7BL9XeXzg/+nR+lCv/u+f4/jq/k5em/ube/1+T/jd/J9d8r3sff4d8df/CLfe6ef90bn3p/Jflf9+KXpt/d+Kbw757fKvz756PEv7s+7vCHv/Dvng/esY92vq7w7/rHHfmDHP2CX/gyvv/Sf3nAKvTC2Ggu1PNTY1ozCuEsGRt/3092c+4P1zn8h/v+d+f8I7y7/05y+Lv741fON//mG3/uf/L5lRx+kiM/yYkflRy+kcNP7q8f5f707vn6/fuFK1N/v/Lf+//Rn+eXfHx/840//SefX7kf//+Zn9d/kqN/ktN/cj9+Kfr9zTfur79/5lfu+8c/8/P6zxvfL/6Zh1fer/u3/x7u8xX8u+1HllWKXXV+8vpX7k//1u89p/9f8Er8/Zv/y/1k3vMfSv93x6fw7+r/z/xf7Kfcn/+t/yCn/zz8IYf/nqNfHv+QY988/ncO/5Sj/ynHPocc/i/3/0r/f/O/c/i/2D/vfl25P75rn3/m//L8iHK//vfzAXn9/7I+Ff7f54eVHL6Rw8+7f93l3N/ucvZvefxNjvxNzv57l7N/3+XgNzn11SqHT/oF/7/4f5+vqPxeHj+n//v8vPHvcurTXc74djnydzn15+7+/kjx/7/5Rg4/yTkfq+TwjRx+knM/WMnhGzn8vPpol1Nf7e7np3/mb3Lkb+7nD6X/v+u3XQ7+7vnH3fOd+/y/7w/z+Ur/d+7vNf7d8f39/Ek+P2/8d8937vLvj2+XI3+Xsz/Z3T//ufN9C42v1N83fuv/C1/p/+7zU3n8f+7/l+8n/TP//f76/Gd+65fzJdL/7vmNgr/LvzP++89//vL87j/jJ/fXv9L/3/y8/c9DTv2dx5/k9D/JqY8fcviTHPnzHPnznP7nOf2/5PT/ktN/Hn6dI3+d0/8v54PK/u1v/vv99ffP/EMO/zvn+f5f/F/B/22/Ws74fnk++Z/5vzxffuf53Pv895zne79z9g9UH99/vu/v5080fM7+4T5f6f+X+4m/no/R+Dn93+dv/pSvPV+To9/9+z+l/xz97/G1539+ud/7W/4ux/55+7c8/9j9ef+Yf7+2ybmfy9t/7HLwmxz8Jud+LI+fV99T/dr7pT7+uz7M429ynh/Y/Pn8He//bvxQxvf3/ipv/7DJ6X+T03/e+HY5z+cvcvhfOb8fWOTwv3L67+fg+7/c75H8v38/scjB/yJf+f3IXXze70uU/v/eP3Rz9g/dnPr/l/tLhf93/dzNqY+7f/4+Qd3/3d9f5fE3f/LV+9NBzv50kLM/vc/f/Nn/JAefx1f3n/fPRxR+jn3v40n/+89/5/FJ/v37503O/rKUw3+/z7/z+8T7+8/Sff4d/P3+f/n9rcK/u37y9FN+H/g3/pf9ldL/3fpa4d+NL//Mf8jpP0+/X/afyu8z/+7/l/2Twv+7/1/uhxT+3/2f7vevPB9wt3+Ff7d/hf/38yF5/F/uV5TnS/7m592P/SJfsf/f/F/sn/d8jLK//5s/yeG/5PDz5D/k/H79l9/v//P94C/nQ4r8v/nzHP5LDn+ds7895cTHhz+ff9d+v3H3+cZ+zv4qzNm//f37mtLd30fo/L/HN7f+5//53//rf14q1efSy6Jer1YbLy+NcrlWrDVqjfrCbFYri+Lr/yk3y1Wz/z//1//6v/9n/Xxcsz/+GcO6/z4fXjlk/Lb7rpStr6/nM//PyfeW/1f2/5zX93f5n5f73ffr7puzrFSqLL4EHvN/FEsS7dJ/xOtjxJe9Cd8iloIHf5bBg/aI7/N/Ovwfx5J4h+gt4eMMTXjob6e6vk6ckQ8+ZrpHNNrjS9kO0aITjKcq8aITU45U4FNJe5GOB237Ol7Qgwx+CD7JF/1x2vYkFH/ZYE0kXszcRLZX8OhPtHdJH9jjkfDodcr/adF8P5D8pcS3IR/2fyY8QAvwafwQgkm1ixk87LnM4NFfJ87goe9R4juEXxE+lXSH5L+A5izhRK7kOxjvG+GhHyT7Gbwf6/J99IdG7xLvoD1/Y7lwIoHfgAY/zuBj2V7BH2R7FQ99yd+7HOrs+Z9bwsNUX/yfHtkP/ff5P84xg0ejI+Exnk+0p/Gj/z7ajwmP/mCvH8Kbt7+sgPAJ/opvSPFvn7dywT9n8Og0SHX8gPfnRhk85q8k8S7W0wXtafxnSbvkv0IfNKpl8BX+zzCDx5u6FP0FHvavEt6S/Q1J/1TSYlG7kiPoE+Ex9AL/JyR8k/8jRk7xJ4Q+3F62reNteHmUxXPas3S858n2wHt8/CIIEF7wH9Ce7B/FEt/O4NuyvcCjvQgiZH+hDxaVRXi0x9J+zOBBe/sMntMiiAo8d2Ubgx4RHq7fhn9R/MWbMb2qbE94ay7bK3j0Z291PPqzh4Qvyv5CS+IHkvZMiUd/IlPOM3g0HUu84ONNozaNvy3x9oPEwz9sxHPFf+BPWE/K+gkxf0BedLxYf2Pp/2J+xPqhfCqSEhqVJd7B/CJ+jUn+jv+DpKTEP8S3FvofS3wLg0TTHtkP/AmHtij+oBHw/PVmKl7QE1q/MNoE8ZPWH1KhqNRo/Qire9Qp8C1Jt7YZPKftKcnn/dnPljRQIPl402uL4u8E7VNqT3jkzynJh35PGA+tH4SuFvzllfSvSlqpH0Q9Ed3aC/wUePhjSPKBh6Qp+T/6m3G8WOkKHvLXJB/xaCWNJvDIrzPOb5P/zTi+ze1tU/5r+5J+iHW8WJRjHe/xfKfEP4G3pTyBR39ziKb1M49vtL0jPPrbZ+QLPPjkv+CDtqn+bcMfkD+fST7WgyiKSP6znA/7mMEjfy8iHT/LzB/w7Yz9BS3wpP+3pNsUf9A/aFE0KfhUyhN49A/PU+Z/Kf3ZpvjVQT5Avnyi8SO/LcGPdLwo6koZ/Fy2V/AvaE/xe8nH08F8LQjvy/76NH7o85Le2it4B/5ekXgxHsQzWn+iyEQ92Kb8i0Uh8gnZH0WrjXpImX+ARrGl5R/gsVNW8ofAY/5eqX5C/6+xLh/6IDPbdYkHX9ALWv+YNTFJZH+b1h/Vj6LURuidk3zQCJ1tij8idcP+I4lHKhb0K8l/JJr8F/sL7Cdsit+ivoT9Xkg+6msEFbX+hT9Af5PwsA/8/YXsj3iAfNim/IX6VGyKKP+jnrRRLw1IPvwPg+qQ/giaLvyF4qfYJGE+V7R+MJ/P8FfSX7w5GOutIPEtooVTA4+pg5E6pP8LrR8af4v2D4r9B5LukP/0gIe+DRo/lML6WRG+KOkW+W8oaVE+Crwp6ZjsZ0hasT/G58NfPiVeFGngx7R+ER9XnPYJj0n1aRNLW2/hz2uy30bK95X8k0o8+T/is4MBrGn+PiWtzN8Tyaf6qUP0mvQvSlrRX2wqwaf5Q/8O8sma/LcmaY/mD/7lYz0q8RP+M8zg4U8rKe+Khz8edfk4uXVQf9P8X8cDPOU/xGfQDtX/8Acb8/1G9nuUtKjUXamfv5ftgcd4xPjfyH6GpH2yP/zDP8r2Ag9/dHX7X+dTtr/Kx3j4endo/4C/HGxt4TQCb0laGX8saYfqD38m+1PwbcIr8iOpP50/YXyCfpP2F/qA9ql+xaDFTbxy/gP/w1RvqP4dS9pX4m90ox2KXyi1Bb2V+ov+QdvkPwgdXdhPOT+CKyG1bWn9Q59tLE0p8Ij/WG+0f8GTJyIJvEu8g9D7ztt3Kf9s0Z4OJRQ8UveHpePxpvnuPoPHeOcZ/LOUZyn9SXkC/w4a8031h9AH9nsn+YhPKDJ9qr/EIRHmn86/8OSEsCfZz0Go2GH8FH93kbT/KoMHvbd0PN6U363qeJHZqX4R/aHe3pH/YX5Q6vYU+ZyPXyo4FD+7psTvCQ99kJSEp4v6xbqNx6H9izjpBf1K6z+RdI/qf9Q3oB1l/2BKeinHL/YzG9rviPgPfRBvqP4Sh5LQ/ED6w5SfsBf5D5ICfmniUP2OQzcHrK9Ix4PuVTN4TjtfGfxRyhN40R/n98l+n7AH4gWdH0E/QX+lOl6cdNP6hz7iUJDO7/q+xCvyUT8fwafz5yOXj0NCp5TBg/6OdTzofqDjhf5FwqM96vEjyUf+gZJ9Wv9CH+CrGTzq9x/CYzzfsA/N/08s8XR+0Yf9Ghk86mk4Yf+YwWO9mRk8+ksIj/4SKe+KR3v4K9V/6F/0h/Wi4EH3Ff0xf1V9/CKei3hP84/6D/7fpfoHfHEoTfcXOFR1mjfyiqdDXWX9JpJW1n8f8bCUGX9MePKfL9gDJOVPrAdBf5L+GDoWSV/ZP6I/yKP9e4fb30UUOVD9gflD/Awofol4hP6p/hCH7IgHSv6ZSzog/0U+EZsIqj+6W0mfYh1/Sm/tVTznu50MHlHobOl40Er+Eof83F/cLtkvlfSZ5B8lrdjvO7rRbl/i8eShoC8kvyTpPsUPxEf80sWl+CniKeLvheyH+bnA/mYGb0p7C//F/IcZ+xel/gGtP/gHfknkkv8Ke4idFeG/JD3wdTxoxX4YnzjkLJL/NSUtdoqu1A/6u3SfCH8Ujz8o44c94I8Dsj/ycZDJf1gf1+7k/AlayFf8V+Jd2n8jHwpaBOVAjq+E9uQ/Z2kPl/bf+OWVoEtSf+EPJfCp/jynt/5cqj8xP4IuSfuJ+RTzT+unyGk8yefS/k3oA7pE4w/keAaEF5c8S2lvIR801kuZ8FhfKfqn+Iv1OID+dP8sLplQ79H8uQM5ngH5H/igFf8X6xl0mfCCzsjH+JRLKSF/JukK4Z9kf4p8ga/K8Sp41KOlDB79Daj+KJH+dH4N/dxVxn7ov8JpMVJX6iNOlqn+RKnjop5U7g9FqcP5Q/JflDqgXeX8GPOHrZK4lAMe84fz76Gy/0d/EEL7NzyZ6GK91cj/3iU9pPq9Bv23sr2Ch771SMfXwd9n8Jg/qt8EjUlqEH4v6SHNH5IS3mTm/mTwoBty/KL/RkY+9BGHUAnhMZ84/zIJD6czufyQ7C8uKcGn+lFcciLVmGkGD3mRjheXkKUMHrTy/AaENgEl/2/yoeJJH5fuf0P4L5y0SfLLpH8Wj/mrZ/Bn2V7BF9Ce5h/945f0LtVvQh/Ee5P8H/UoioSwmsFjvhoZPOo5g+SfJR0q5z9oj/N3qj87WPqYP3ENhfqlIumQ8qcVcb5va/ItT9IFsr+NY7GUt49sHQ/aEfwb3mpRe8KL/sYSX0B7Lp/tmm548WYC0LbEC31Ah5Q/RNCJOb4r8bgPE/QT7f9glJdYtge+iniA+Ef1n4gvYr3Q/GE/KtY/1Z+IR9be1tafKJXwjxNL/X8kPST9hX5b+xavBB71w1qfPxFPHD7+IflvHfpjPvty/CIeIB5VyX/gdPBfxf6wh/AHn+zvSfsVCI/1XU1v+l7th3gkUi/hEb9rQkmpf53oIs0/9Ckq/oKeOD3ktCHXr+i/hvZViXfgf3w+XXr+QqxvjIfki/5dbj/bknib4234a0jyYZ8o478CT+1F/ML5ky/1FfZH/MDWwKP5FzTk0/pBfhD0I+G3cj49ku+TPVKJFzTsEZD+RUm7Ur41kLSif4vbx8Z4HyRe6AOa9LfGUh+b/Ef052fw6H/C6RbhH4g2JR5Foc2/Pcx2gTc8LonE/X2Lxo96tA19lfsj7Hcw8zOyH9aPCCKRtP+3pO29lI98ClrcdIv9E6AL3l9H+o84nwNtk//iPA+0ev6G/TfqpTbpP5X6t+j+EM8TCHoq9RfjeYF8aT+xvwZtU/yCp4iHvF5o/jG+Facp/wv7wp422R8rX4yf8r/QJ5btRfx8kvo7tH5EUEZ/c5p/yF9DPq3fZ077XH+H/K+N8SCebDL4rWyv4rk+Dq0f6Cf0WREe9nlFe1r/0K+T6vrDH5xxRj70wfi70n+EfYV88v8O/CnN4OEf7/r8saKU9xfr+sOfBK3g0d9Cthf4WPanyO8CP+P0m8SLhzJxfvBA9odXoX5ylkr8lDTt3/Hmf1F/9Ch+NyWt1B8Gjhphrz3Ff+RTuFaP4p/oD/aj/CHwmO8vWv+YvwOn+zR/6L8f6fKhjwN7fZP/L2U9QfKZqW+0Uj/geQwH8TOReHE/DTqg+gn1QQB/ofwDvEj1uwwedBBl8Lw/5fmPZ/EX7+9MePBB0/Nv4qE+jN+l9YNJETTJF/X0RbZX8F3UT3T+Db6w34XsX5Q06W+dQKf6+KGfy+O/TedPYj6LsDfFv09OD6D/TOIxH4IuknzgK7K9grfRnvxXbBXgL1S/iq0G6p0hxe+CaM/xFP/FeSpctSbl4zyUba2i20OpmD/skoZ8POKkDnh8+dtNhXy5/tAf9AlJPuIrzo9dyh9fRBckXpwvgz5K+eI+BK7hUvzei+fveP6h+lHcrxgcH5F8YQ9uP4/8B+MD7dDzKzgft1Gvh9L+on/05/kkH+PltHL+CXva2A8Myf9x/xMh/9D+E88jejz+2S7V73h+Ap7/QOv/WeKV8QtPPnK8J/Ei9VehP40fKzXE+Cl+oqU3E/4r55//Rxv13kOs4x95f4FyfwE890eb6mePxzcb+faR8ifq6RHsR/P/yO3j8fVkhxk86r9RnMGj/T6D5/awqf4D30b9Oib79yS+RfnvkfffwvodZfCo98axjkd/rSiDD6S+An+U/U1Ifl/SLVr/sA9om+rnFuyJeu6J8FOxn+Ptqf6ZAA97LTL4pWyv4KeQn2bw0JfqpxbGj/rhieI/6o8p2lP8Q/9tbk97lcFD/ozwGM8suul7xVu3/uw1+S82FcjnFL+u8QzPW9H6w9GfeIiK6gccfQp6IPO/jXpqzuW3yf5z5CPY653yTyTt8Uz6byXdXmbwmL9DBn+Q9hb4D+BhryPhQfP1aH8SHv2hHlhYOh50m+z3jPHw+bQp/4Mv6CnhD5Ju0fqbQT7sr+R/2Bf71SXhMR+g29UMHvGoSnisx5Mef0T/oF3y3wX5/ymD/8F6If9Ffl9yuhMo9ceNVucP87mX7QUe+fyFy+9Q/FsCP9Pxor8S2mfwQj6tf/iTwNP8ean05xHNfyDXc5vyj4iHGC/tH8C3kf9fyX5rSSvxU6ynqmwv5HO+jfkYE75G46f18wp9MF6qPzrwH9Rfr7GOf0X+of0n8B2s94aOF7//mFH8x3rEQxkdij/gg1blY/2Y0Jfsh3iyiG7x5rr+0f4o/VWMH/Zowv4kH/F1gfkj+yG/CP/7ofgFGvv3Jcmfy/5atH7hD23uz3ad5g/yU06vCI948pTe2l/rt/imv2hvyfGI/pT1t5D9dZT4m0r/aZL+hH/O4uPbfN3uf+X8Uf3VsSSt6I/6NkD9QOdvKy7fR/1lE96U9byyf0A9FqP+JP8D3uHtHUfHCzrO4NGfo5yfyHpcwfvoH/MZy/kX/LV101fgYz4en8cDp63jBb3O4jHeKIPn68eh8zuMT9iDfn/joD564+P3yf5v0IfPl0Pntz73Dwfx4o3kCzzkFTP4omwv8Hz9OUPZXuDR/4b316XxC30gP8zgUT9tCN+TdJfi15ukHTq/w/gc1D+bSMdv0Z7i9zvXvwv7P0l8l9vXQb3yQfXrWNLdcQa/le0VPPr7iDP4+Nb+en4FGuNfEn5PeLI/6p8d5BUzeNif4rfQB/XTO+HB38H+tH4/Iomn+qmH9YR4vyf9cf6x5/ge2X/P9elhvJsMHvnsYGXwvL/eLIOfyfYCHxGe9Ef984n2NH/ov8fzrUPnH+A7qDf26v6J4yGf7C/GA3+n/NnDfBw5/UV41ENfwFP++AQe8SLN4FH/fKU6/sj17Xs6HrRD8b8P+6FeOar7nxut4I9cvz7GS/lL9If49036nyTdDzL4SJfvIR9jP/dN+deVtLL/+4b+sJ+yf8d8XPfvUj7qgx/IO2bwsJeZwSOf/MQ6PoH9yP8FXZXtBZ7Pj4N6ICH7o/9U7B8zeD4e19Hxgk6tDD66ybviOR0EcrwCj/WE/HUiPPQ7yfYqntvfpfgd8PXgYj98pvM/5IMz2lP8PnH7BEfZXsEjXl+yeNlexWO8FP8D3IfhvuJC54fgX7g9BxS/oQ9o9yGDf5TyFHwR7X0dL+QPMnjkj2KawXM6IP9D/wPYj/a/sI+L+qlE40f8L6I9xe8SaO5vLt1fDGA/xMsSyUc8LvP+BvsMHvIWGTzieTnK4GE/ih+CBp72vwPMJ+J3heSj/wrsV83g4b9xBg+6QuOHPlXgKf6BP8T80fk19BN0lfRH/KyhPdmvivtQjHcr8UPu3+67zPcKHvRwmcHj/vAjg8d+q076C5rrMyT719Ib7VL8R/+inqD6ReDfxP2txKP/4TEjH/og/tcJj/7r4v5Y4hvQh8+HS/vXIV//LuK1qd5/Rfw+xuObUB0f4r7/nMGDNlMdD3pI82/KfOzQ/j+k/Nck+10kHY51PGj3R8cL+ZQ/Bb8JfSl/N3Cev8yMH/Yooz3FX6zHgnXLN9f6ifKPUn+hHpvJ9gKP/FaAfJr/b+tGK3j05zZkvlbxaJ9m8KlsT3jnIuUJPPovyHrtWn/Cfpgvsr+oZ1EPG7R/wfjHaE/zh/O4PtaPIfGtsaSXGbwR39rf7m84H4/p2Pgxi7j/sW/nf3R+6BaIRnsF7zHaKdP4ZzL/GzR/gh/7ev6XeNbnTX7vmp9jrpR/w8N/QfcIj/rqVk/d8FbE+2sBH9/wbKI4nXJ6LPW/9s/pTgbf5rRSf8E/Hd6+T/lH8Ge8vU/4rXPLJ5Q/2K4l5lWsr+VPJ+Lyjxzf0/E3fXwNL+ijo+GRvxT9BR3QeDF/2D+U4A8pjR/8VNpLyC86t/2TS/YbcL7YP1H8caF/leNDHS9oz9LxW+zXqjre5v7kKM8fWBJP+YNxb7TtSf3Rv6AfpXyBf5TyxPyJ5yH4eLs0f+DbPm8/kvgA5xtjTrciaT/UQ6ADWv+orwLko6cMHnSLxj8BzeXbsdQf/bVwXhbR+Ll/CrqV6vi2pcsH3ub+aiv1E/gz3v6i3t9EV33srZSP+wDQ4r5AxA/4zzPHK/cH4Leh/17iJ9YNby3I/tyfxP6rI+1nLTm/w/2pp9y/Qx+T42Mdb72gfarjfbSvSvmiP+Rr2v8JPvrzSf6rpB1fxzt8/Tu7DP4N7aX8634SzzsUJb7L9XEQTz6k/k4k6S7pv+V0Wdz/Z/BLTu91vKjnynT/DXyPtx/Q/qVH+APh4V+faE/y95L+Dx7zd8zgQffk+hf6CDyt3z7sCXslhC9KOiD//5b2cGj+gHexXk8ZPOhepONBi/ECHwCP+bxIvOtJekDyT1If18/gx7r9BL4IPMk/SNqh+DmA/3i6/7ozSQ/I/mVJu7GOd2H/dQZf5fQw1vFDan+9P+c08oFJ+K2kFf+vcTqk9goe67lJ9vcIT/ILwHP9Pcr/YSznzyD5mN9zZv6Bj7g8z9fxgj7reNuS7UX8cSSt7H8j4AMdj/5cnDc8WDoetEfrT+ARb6l+gH8IOqD5Q32H+58O7f/xPEFoynrnen9t3+6DqP6xUU88wH40/w/xzf425W+Pz7+NfP8o7S/wj9B/q+O9zPwBL2jyHxv1xSPsT/OP/kHbAeGhz0D6i4IfQT7FP/AF3aD4jXw0RHuy31jSSv4R+Wgm2wv5psh/PN+RfNQDoxj5UuLRH2j7MYMHPSb/m0vapvGL86RY1Ls3fB/3R9B3IuWL86lEnjcp+Bb3P/spgwc9sXQ8+utT/TpJb/NpzyS+xeOb3ZfzZV3vv2N+/6bPH/At7k/2cwa/kO1VPOxHePBbPJ7ZL4TfSvpRzp8N+03jW3sVD/95JfsfJX5E628FewAfSPyU99/m8cOm+NcyJT2LdTzo1kzHC/tvMnjQM5KPfD7ndJvWP/oDrcxf25fy53EGj/YR2Z/wY8IvZT3foPW/g/9h/ij/zbn+Q5y/0P0n8GI9PJP+O6L3Oh77Z1bf3eSL/TT2W89Uv1Ykrawf6NPe6uunvZfjf6b5Rz2xgP1o/T/HN9r+yeC/ZHsVj/azDH6mz38b8T/J2B/9L3l/HdIf/YG2kwz+W7YXeNRji1SfvyX8qSrXi7i/w/xfpL8LPPLLC+SPdXxnJtsr+BLaZ/BPXH5HkQ8a810lPPdnF+f9L2T/i+xvqNzfAh/r60+MB/1NafzI/6/Ql9b/K5//TqrHj85W0q+xjl9m5l/gsd7TDB72X5F85IcV2pP/v6Y3WsWjP0O2V/BCf5PsZ0k81Y8+9pM4z1hR/Y564snS828M/F6Pv8AL+TR+gY857Xs6Hv05dH4BvuNm5EOfNW/vk//EfHw+9xfHy+CxH49p/g1Jd8j+a+Rv7j8O1Q/+TNLK/V1b6u8tdbwfZfQHHufHa8pfbdmfcv+3w31urOsPvrgPfCM8+G+Z8eN+1ef+ot7/4v4D8fON8u9AnL9y/F7H4z7W6ZP/+3L/apF83EducH6kPP+I80BfnLfd8Ljfc1D/0PmnOA/9FPfXVD/Et/sYm87P+ntJRyQf9zug+/T8RIr7iLGoH6V82A/x/4vk4/y0gPt7Wj+YDx/zT/cPop6vynpT1D/Yj2A/7dL8i/N0nJfS+YM4jxfxh/Z/H5L2af3VYA9OK+f3Yn+GeNsn/LO8/1D2v7jf6PLF5dL9t7hfQL23lfYT9yniPIjkgx5i/ij/DT1Je7T/QX84z+rS/gX7E8fU9y8iniN+b2j9LWT9pMRvUU/HmfiB+O/r9rfrVH9R/MHzTR34w1TixflgT8//4jwRdED3HzgPxPmnQ/kb55mCduj8T5xfcvnK/QHqaVF/0/mDqKcQ72akP+pj3Mcq+79ZJOu3L8q/qAeOevwX/tTAeMn/TPg3/JXWr9AP9Jb8B/choEPaf23pPon2D1jP7kmud7F+sD6w/7bJf/A8BtaPVaH4hflAvancH+A+Z5ORj/UZerr9EV9cU54XCfyb1Cek/I3nGUC7dH+N8yVBk3xxHnaI9fsHnK+FpK9Y/5QPhpR/ifbJ/n2chwa6/4v1gHprS/HjHfGf47vK+RXOn3F/T/Uv1reD88ou1Q+mrJ9aFL/hH22cF1L93SH6hfSHf7Zi3f/N6BYPlfiN8yUh/530/5F0l/YfiE/OTLYX8ScW90e38Qr/m8n73C6t31D258zJ/qakKf6L9YB6ukvjR30MWhl/eJT5aEP+j/PHD+Bp/1VD/MN9E9WvIp4vZbwT8rEf+pDr9bp+5XmOoj/usx342weNH/EZ8bhL+e8lusVDdf7Gkt6R/JKklfwh4jHmO6L1B32g/47yfyjxXcIjPncz+aeN+hH5bk/2/5K0Yn/cRwOv2A/2cdYZfCzt16P6D7SYf9q/YH04b7r/Xf1R1B8Sj/F1ub4O7V9hXzH+D8JjPvYYL/mf6C+S8gQ+kv0dKP6N5Xz2yP+xvrvLjP5YD8/6/DnYX3yI83vSX9IOxR/hz7DXgeYP9t2lunxBR5nxYz7eM/rH0p6KfMwP5sOh/CnG85aRj/728U3ebf3y+OqLfHfzH/E8F+qXA9kf9/efkEf7V/E8GeR9ZvA72f52/hldf4/To/Mv/J6lh/2H8vxlVdy/x7zelHicH32KfC/x+H2O+P0O5V8X9SvizZDyD/ZjXxg/rZ+v6EY7tP/qFSV9JPsBfwS+quP7sP8lgy/K9iqe698n+wsa+BLVz4Gkvwl/kXTfz+B9KU/gMR+of39I/4ocT5/Wzzfw8N9TBo967TuD/0H7fQaP/Qudf4Iv6ESt/290X90/cLqaGT/wOL9NaPwlSffJ/xIuP0D9rOw/TEkr/mtI/QNLxwv//dDxjinbK/gD5JP/ge5xe7rK/f1M0sr40V8a6+PHfirA/A8Ivxfrh7en8yv8niGF/uQ/TfH8m3M77xL5E88/FGV7Eb+xnk64P1DOn1A/Yb9D9984D3Ox3x1T/kJ+OkG+Wr9LmvJHC/Xwo2wv1i/iKe5PA1r/7fhGu3T/j/vVK035B89jn4En+0fi+TdO0/OL4veBddleyIc/XDB+Wr8W7Av/IfvjeQxX1NM0fsTHi7ivofsX6xY/Xaq/RX89KU/MP9bX0dLXX1va0+2S/yEf4rwppfiJ8XzB3nR+FcrxO3R/h98HuqgX6Pd/Ir4ing7I/x/E84fOrb3wH/iDJ/1F4MV8ivqT/M+6nQco6y/E80OgFf9zpP16pL+YD8w37V8D9Ad5F6r/MD9F1NsU/7A+xPqn+yvR30i2F3jMxxl4yr+wJ/pT5CO/CJr8R+QT5B9F/kXOh0v1P+ZD0CWSH0hayX+w72Am15vA83jsIp+XaPxYnyfoS/b/gj7wH6pfkc8EXab4mUi6b+l45DOX9u9iPBh/ieLXQeo/oPn7lLTzqcQvjkf9ViQ8+BW0p/Ur/BHy6P4F/iHWU5HG35b2GND6PUnapfM/EU9w/lCh/X9X0sr8w54Bzpvp/lrEU9Almn/k02p0y3fX/IX5wHipfsT6FvUD2V/4J9azgk9l/lTkCxr9VWn/gfFVcP5N/of4Ctql569EPHnLjB/zWcT4KX9gfmEPl+pP8AWt+C+ev6hxekj5o2bdaJfqzyHwO9lewdfRfqnj4c8unb8MxlJ+nfATSSv+V8b4YS/yP+FPoOs0/oWkB5R/G9AH8Ybub4appBuEP0pa8T/gQ8Sf7wwe9YRp6Xj4r2I/4IX/0v5xQPaskf/E0n7K+od/DJGvqH4bWpKuq+eHXB/Ip/xTjm60gh/AnhfZXsVHN39X8CL+UP0r/AH7jSbJ/5B0SPEH9hxi/FT/DU1Rz3D/J/mIX03UK8sMHv7/msGjXm0SfiTXw5DWf1mcZ+nrN4T+WO8F8r+ypAe0f0D/0MetZ/CgC5aOr0h9BR50uNXXn5gP3JcVyP/2klbWT5XwlP/FekD9YJD8g6SHNH8YT3g9b5P6b+X4DRo/nl8xoA+wwBuwr8f/doAFHuvjSgcaXvztZfAB+9ul8zfL5zyb/21bN7zoz46Ca/tr/RZzOuJ/t6V8gW8r7YXOkl4SHvrFGfnov8P/dkh+FzTkHSXeiSQdkPwtpwf8bzfW8S7+NjN4U7ZX8EOSB3yP0x7/2yb7CX6V/x0Rfs/pB+Cl/VnW53i0TwnP+TbG+0h4jGeM9lk819eOJB7jscf87yfCp7K/Ftkf9mnF+vhdyJ/xv6eENyXdJvuHkra3GfxWt5+N8S/43x3CP4OG/lWJb3N9bFO2V/CvV1/Q8PjbNjN4jPeF8EVOx/xvn8b/Iu3p0PqBPo5H8gi/zNhf8KOrL9/wXL5D60XgMb415JP/bDjd5X87Y4n3U0l/SLwDf9jxv3tWBg95ywyerx9rS/ixpHs0/ndJO3uJ74I+ZuQD/4n2NP4j/If8xRVOyfGw1w/hU0n3M/gA87fM4DGfaQY/AT7KyI+lv7vCGxjterr/uuCdIY/wqdTHDTL4QLYX8wf9Thn/L3J6wPtzafwDS9IVkh9JepjBD4EfZ/CYv3oGX5ftBb4K+dCf4h/6F7RJePTXBD7W8SHaFwkfS7pA+L2kFfkG+R/JD7k+nqX7j4v5vGTm35C052XwnLatDP4L80d40BGX79H8wT/hzzblP+hnuxk89IlgP1/iHzjP4/NhU/7yYH8f45d42+O0yL+xjne5v7D9vY5vyPlS8A9c/5DqF5HfgO9Q/I0lTfJFfw/Qn/IH4pGIPx7lfzx/1s7Ez0cZz2zCIx95sVxvwv99Gf8eCT/C+rP0+In5dHi8syn+OTM5n13SH+thEN/sfTs/5jTyR4nmn9M28u0j+V8NNPxlr+NdyO+T/qnMJ4r+lrS/kj+QH8X4v0k+9Ee+fCD5ZU6P0J7sh/FgPduU/zzgUT90aP7bsj+P8l8f9jAz9qtKfcak/4+kPdI/4v21MutHrCfk67HUX/jnyNLlI561+HzbIxr/WNIjGn9JzkeL1g/mt8X93Sb/QX4StJK/kM8i66avioe+Txk86AnhMZ8jbq8W+V87vc2nsLeYf6z/KDP/35JW8CNJK3jM79V+Ei/8Qcw/2R90C/P9QPiipEc0//CPcXprL/ATjIfHM5vyl+gP9BPJf5J0i+o/0Z+fwWP9oF56IvlzTk+Bp/XzBP2h72sGv5LtVTz0NTN42JvqL/Rvxxn50GfG27fJf57iGy3aK/ilbC/wmP9ZetP3iud0G/63IfxR9jcn/VH/zCGP6o859EG8PUh8G/6P+uc5zeAhb5/BQ94+gz9IeQIP/oL/3ab6+Rk07E/1k9AH+W4RZfDQn+LPM+TD/yn/on8b9c6C9D9I+R3y/yXHd3wd38F6RL58IfuhHnqR7RW8kH/J4D8y8k+yvw7Ff/A7Mx0v+oP+L2S/i6Q7NH9L4GGvIsnHekK+eSX9kT9egaf65TW60TbVTx3YrynbK/gV8MUMHvoWMnj0t6Lxo56LrYx83p/P7eVQ/O7spfw4zuBl+yue9+/zvx2X8Lx/B/XAisaP+iFGe4ofa66/P9PXvz+W64nkOy1JK+MHHrTTzuBf5HpV8CJ+EB58n8+nQ/VbG/OH/cua8I6klfE/wx60XgQe9kO+eaP18ylpn+q3N87z+Xw5PdI/lvQbyUc9uLFu613Fw950/tAmmtavg/j/Ft/kCfwG+vB87IQkH/bEecUm1vEbrk/X0vFdL6M/8Mh/W5KPfLTl/XWpfgYf/TljiRf9jWV7FQ/7U/x7k/05VH91+fw7yFfvZL+JpDsUv96jmz86TzperJ+19F/hzx/87y7ZD3wf8mc0fvSHfPVO+iP/fMB+JP8D+sNedP7Q5eNzkH92Gfy7pdtf4M2M/YDHetpbOn4f3dor+B7sv87gMX87mj/0v4P+FH+nyIdVPf4hPwtaiX8rSbdo/KB7vsy3In7EMn7uKf4sJd2m9Yf8JvLHjvC8f2eaiX9NGT99qn+2mD/Yj+oHrA/RH/m/GA/iR4/8F/kEtE37B7GetnK9CPsNZf7uUf5B/6AdOj9BfWDjPOBA8QPzuc7Ihz93+Xgcyp9dxDPo/0nzP5V0x9Txva1sr+DR3yfJx/g+Y11/5GPQNp1fIL86G9le4AtyPnoUvzAfvVSP3x3YD/H0i/zHkPor+DXhqf4S8/md8V/EtwPwFP+xHntVud7E+I/SH75o/W2kPj2KP+gf/TlUP0E/MZ+kvxjPZ0b+ZyrxNP/CHz6lvgK/l/qoePSH+UoIH0v6mMGD7tH+6yDH4xwJD3ugXjrS+H8krcQv6NO3ZHv8T5zHv6E97b89Sfcp/+N8v589v4c/Y7190/6vLek+rV87ljSdf6A+dRA/fsh/MD7Ur32q31CP9hFv6PwP8cVBvTUj/0V8/AGe4j/2B4hfDp2f4XzeQb2T0P4P+Qvn933yX5yn92FPit82eIgXCY0f8TiJM3j0B/+h+q/P/d/F3yn5vyHpgOJ3wucjwP2Ll8Gj3jll8Cf+d2Bl8NxfXar/RH9t2R7/E3z0F5D90/RGu34GD/ok7S/0w/wr8oU+iF8Uf4NIyj9L/V3UJ2fII/898/4Dbj+X9t8BXw9uKNsr+AtvP7B0PGg3zOBRf11IPvhF6E/zd0klnu5fAlPSxTSDR3vKf2dJu+Q/6N9FvXMh+6M+KvG/BxS/S9Af9qf6ZcDXk4v6pUTyUR+Vgd9n8EfZXsEjnpazeLQn+6P/QTEjH/og31XIfshfFbSvZvB8/t0V4XGfF0t5Ao/+q7y/Ic2fGA/kU/0z5OvDRbyvkf3eJD0k+1UxHlMfv8Ajf1bTDD66tVfxW9le4LGekI/rJB/7/zr0p/WD/obw90MGv5f2EviV7E+xH/azQ/gr7V/EfhjxsE7xD+ePddTPJL8Be8B+lP+GqdRHsR/ib4Pjh9sMHvqnGTzoRpTBQ1+yn+ivqsc/8AVtEh750Iwz8jk+xPqh+gV8Qdcof41lPA+p/moRTedHIcaDeNQk/ytKOiT7NTEf8Jcog8d9STGLh75xBm9JeQIP/69l8FXC0/otWDfabWTwoAtkv0dJD2j8uN/sBzLf43+4z3RNme+F/cR9JOTR+v/h+BD+o+SvraQp/4p8jPwbUv1jiPsM7q8kP+T+4KLeFw+1Q3/RfxRd2yt48ZEymz/UKfI/5gP5bkb5Gx+4v+ZD74a3Yt4/Xoqs3P/73i3+ntIMXuZLBY985E50vPgAsE36g29z/ZX8WcJ8oH5qSf0FH/SZ9G+jvxQvIZP621y+mH+6P7RmnN/l7Quxjof/WEsdL/rrSfkCD9qJbvqL/hzITyVe8IvcXlQ/WVs8tIqHbLN4yDtKvNAPePJfq4qXtPH2BtVPQ/SX4iVqEu/Gkn4g/Tle+I8XRxpe0GYG70l5wAt6xOmWnD/RP16SYo8l3uPjw0fc/oOfoH0q8Rb150l8C/KXsr3Aw/54yV2b7PdE8vcZPPSJMvg55KU6vo325D/g25ivBeGXku7Q+KegI338Ag9/eCH8WNI0flHPL8TzNxL/DX/k43GqFD/g/33yF+Qv5KdOxn/EeTbiySvNP/iv4iFvqf+K03gJmkP279D4Y9LflONX7C/wnHZ8HS/oTQYPuk32B13lf4uPBor4Czzod4l3EJ/eZHsF34X9afzo34G9lxKP/YXI55R/HbGfiW/59hq/01v+d+j8uo983NTzr6gnsB8bUv75tm75w6XzZ+wHBU37P1HfnzP7P5wHOdxflf2XOE+Cv3Tl/LtbWY+FSv0XyfqV6i9R3+64PSpUv+D8zOf9ORT/UF+KevJN2k/kpz3FC+CbMn85tH7ES5Mw3880/1u5fn3yvzfyH5KP+R1iP7CVeFEPYD/TpPyN/XEa6/lL7A+Qv+j+GPWJi3rPlv4n7In6D/a+xm8Z/5X1h/t5F/clBtnPkvVAQPsXxBMH4/2k8e8l3abxP8v4LdoDj/GI/r4o/2F/exS0tD/2sz3glfyD/mHPb1r/saT7FP99SSv+Kz4ShfMTGr+YzwQ/Yqf1H0p/cCh/WKRPSvIDSSv5H/4Z8P5cih81uf+yThI/xPo4Y/1T/Y/1F3B5Q6qfTM4T/V3IfzF/2P8E5L/wD+jjUvzB/lbQJbI/+gd9ofrNlPKV+jmR+wdFvogHaD+Q8p2LpBX/wf7EQb6m/YtYz0tpL4Gvy3igrD/4lwN/q5D/xZJW1t+j+JG9Pn8e9Vel+Yvk/A1o/rAeB5g/8l/YB7RSv4vxleE/FP87qL/QnvI31qegyX+xPoU9FP/9kP6rjL+bynzWIPxS0iGNfydpZf9uiufZePsm+Q/mF7Sy/jEfwLuUP8VHblGvrUm+Je0fkv/BPiH8h+I/4puwp0F49F/AfJH99nL8Lo0f+rm8fhT2Fvqjf/Q3JPthPYmXwhYlHusD47GpfhPrCeMPSP4B8mFvwiM+CLpO+m8l3SP5J2l/j+wH/3bSjHzog/1Mn+Yvofkn+dBH2OOH5O+l/JD0/5S0S/kH/gl7KPKdo7RnSPHvS9pPib/CHyypr9A/lf4XkP6pHI86fuAhr0j4Mc0/yS/J9Sj8DXj4h6AV/Jb8j8Zfk/6ojD/itMf9X3w0GHiPz7+N/dcD1Z+OpL0gg1/K9gpefJQ4zeAxfvLfiPM9vt7tLuHRP867HqT9bOwnHyHvqOPF89N0/ibGE4j6NdDx3J7ePiP/KNsLPOIf7gMeSb4n8jlfbxS/R+iP298OCQ//xP3HmPADzh9xeS2af+BBK89fAi8+Aj2OdTxor6rjPdQLnxKPj0pbOL8ak/0jsR55vqHzI+jXgr3GUn/xUepJRj7wE063aP8j8Jj/pwwe9d8kI1/5KLXAoz/ur/aQ8PAf1EtP0v9t5K8J7EXz9wR7prr/tTCf2H9NSX/sZ6ZoX9TxHh+PvcrgsR+aRRk8769t6fg25o/2H4IWeJK/lnSb1g/6B63gxXhwXvFA8sHHS5Q8ql/xUg+Bp/q5jfEgX87J/thf4SVObcrfc8jH/O0zeMT7UazjMR/tmY4X/j8n/TGfiLdzwoP/hPHT/M0lbVP9i/7tY0Z/jOcZ9qb4i/WE8dhUP3im9Kdnsh/W50Kut6v/YTxYb5Q/xHrEfU9E58c4/1iI+CfXz5T8p0N4yEe+mpL8lYyHbaq/wBcfNaf9O/zTRr5cUvyAPy84vkP6L2M5fpq/ji/xC7LfWY5fmX+BN3X7CTz6W5L+ezkfHfJf+BNom/KP+Kh4MYOHPuKj6rR+XqBPNSN/LO2n5I8S6W/qeOQTZf46NB9K/EY+wu8ZlOfXwQet4KGP+D1DpDx/TOtPWT/SH22q/zvwX+TfV5JflnSH8C/xjbbrGTzqh5dUx+OlfJ1jBo/1YxIeNPL9iuxfl3SH8sdrfKNtQ8eLj7THWTzXx7d0vO/fke+gHopp/YMfp7r+GA/wDtUf4iPxnmwv9j+I7+tYx6+jG+24Eu/z+Xcw/2+Wjn/j7f2ljsdH7p1eBu/K9ioe46X4J/rj/u/0Cc/n00E9sSb9Ud+8wX7FDL4o2wv8UtKkv5jPDcZP+Ffg+XpwKH/Cn64ftU91PPyvS/MH+/qRrr+w50PG/xrS/l2KP+L3gTg/e5R4/J5P0HT/L54n3mK90PMTuJ/AfYYzknjcZzqoR6p0/oPnWSp4foPqD9yvgnaofhHny6Dfaf9hS7pL84/7FNDivgT/68IfkK8+aP+OeuaD69+l/IOXKnaLsr2CR/2yy+BBd48ZPPydzo9Ff8gXe/Jf8PFSIqX+3XH9e1ZGPvIH5nNH/jeX/fVo/j6A96W+Ag//Qb2yp/ULf3zMjF98tBrnH3R/7GE8qFe2Gbyg6fwG/aEed6j+6mE9oZ450PrD+e+B43t0frPn+B7ql2kGv5ftFTzq0d42g4f/7DJ41D+ftP7Q/wH1I61/9Id61qHzP9TDgv6U+ov7WOE/FH9xnwvaofonxPM4oOn+VuBxHq34D17K2IO/UP7qwf7In0fyH9RTR65P39fxfYy3mMGjv680g0d7L4NH/PjO4FFvHAmP/vES1h7Z71vSDp2/if7eZXsF/x3dxqvghf50f9BHf8i/P4RH/vzB+Kn+/Ob+0Ue8MzN41Cs/aQafGb/AY7zNDL4p5al4tKf4I/rD/FP+7eMji5acL4HH+VzC9QmsDB7+ViC8J/Ep4U+SVuZf+APih3J+hvN07NdTOj/YStqh+IuP8uH8XrQX9VMk4zk9f+4in59w/0vzf6Lx0/llAPkd2V7Bf2P8sY4H7XYyeNRrCZ2/gT5DPs3/Kb7Riv2gn9uX7RW80J/WX0J4mr8AH6nGfv1M5/cB4Wn94yNjoN0wg0f+vkQ6Hv0F4wzelO2v59ecRv4uKuffoDl+QP6L/gf4KPoog3/M6N+X/QUUP/FSr8FYxw9gf5wHlEh/5GO81GuwzOCRf2cZ/Ei2V/B4SdiA/Af9D3D+TPlL6PP8/7J1Zn1tMz0U/0BcNJSl4dJL9tWFsPQOUnBLWlJIwdBP/z7zV6wz9u+94+A5I42k0chjZ+zjNT77GZ+run3Mx996/jufiS/9Wc8Ow/jnyj8cyj/Hf1q/5pX3d1g2+UdF3T7m47+yxS9dX+OXVg+F+ab5y0fWF+ir/ecF/vz5//hHVd1+//yvqvvLVT/w+xAOIUxOlD/4fSV4pOePJb8/WHt7k489WU+PJf+347nu305KH/+2xWf9PS2bfA4RW2ya/MXW5RmfeHppyX/yemah+uXEnieF+fuzxWf9+1I0+eizOG7xuy4v4rNefpF86o9T2mv+cT82In70/Iz63n6P9KD6ifXkN+u/3p+CD45/v9Tx/n6rft5a/VCE+sLl8z4dONfvlxa8P/Xk7c3/9G+/v4rqF55nMF+1fi9njs/kP+6P+SjpsNvis14mTb7dj55VTf6Zy9s/P+H9H/L/ifg3Lv9A8j87XpYt/qYpn/tb60/3v/Z+wQH7zZr/vB/CepirfuB9EMMH0t+eJyFP4/9UOA6/uN3rT/9pwJ/KJj/suCbLbYu/bdm/I1ysav3p/xP6jPo1n/722OWHHdz/qvKAZb9av9C+cL5dDziPnh+uwvVBaJ9WLr8Pvwy4dH6KfuuAM8mHPwo4K5p8w9sWf+vyjE9/04DzxPlDYY3f9LsJeN7iL2hftfjIO27xuwEXLT44Ez9z+WlP9g/2MP+PxEe/r7I3fPbzOf+kr/zN+0Up7XX/m3J9//6R8y8cpxr/J35/Q/2o9Xuq+/m+28/ehwEvo/OPmI/kg0vFb9dx5vx9PrD3v1w+97NpiJ9o/8Duh+9a8m89H6c3zuf+nPvXXPcfY+bHVZCv+2/LJw/2vpnz2c8C59Hzc/LLeeBH+we/vP5dav3gfbAl9eCFj9/qcfbLPlS/UB8csX7E7y96/Cr+WE+Tm4BPdP8y9P2TVPOHfLxgv1P166Ln+yeV8seV6iflL6tHWa+0f2T1IPXoofLXu/s/uv88sd9DhfZ6f4P3s3Pu/wY+f219AUf7N+ZPxn/l42c9tvV3ULr/WZ+3RXP9xp+MP7kWn/XU3r/x+N/3R/xXbr8vxAP41vmzkc2fIr7/sfubYdAn7Tgf+46Jl3vNX8YzDnio+TdJKZ1WYWvT+VnoLxu18g/8H7QvW/zQX5Y0+Sn551HjZz3kecJY84/6ahzsH9VP1FMZ+fyX+Fuvv8Yu3+wJTncun0PtzZ9Pzjd7gIfi33v9myl+j0rHG/G5n2e/ZaD8TX6cEE8bjZ98ynrxLPuVjicef7afQj6I8sdzVeMofslPOfsNE/mP9XhK/lP9w/qaYY+d4qf0+T9V/O/fv1rt55vxyQ8Z8fTqfJufb+gv/333+Zt1Xf9/ZT1/k0ryjx3PJJ/5DZ7F7/8E+81Cfx/Ot/XhXyv/kQ9noX0+0/rP+wfEz6Hy/87rn7n0Z39hXrg8ix/2w7if+yz/rx3L/zn5l3wY5e9P9j5DwNH6w/jxx1zzH38uEveX1X8c6o68Y+Vv1o8T/K34wZ+v9v6T8/FHznx9k/+Yf8TvQvOX9YHx51p/39lPoZ6Q/5b790eKhv26vv7k0v8fOOSvXPuf5t/3wF9q/ST/z4I9csV/V/l3Lfncn4C7Wj+YH33iRfVXZfVwwGeKv/37VKRqHz/r2TLwF6rf8a/pc6D8w3VwX/xr5y81f07JJ8z/37I/17vIl/3Hng9yzZ9M+EHj53kW9W60frGeDYO+PeXfX9gvxEOaKn5Zj8Fj6X8HLpt81iPDkf3XPv6F8t+lx3Mm+7/a+x9Bvur3Kc8TwQvFL/czb7QvWvyA036LDy5kv43no57ih/Wlt26uH6wnKfX4V43/3u3RU/5nfQCnY+WfY8dD1f8vbo+exk9+7rXyL/M7Zb08l/xvAV/A1/qLf7F/OhM/xFM6d3/V9V89np7WfxsP+qp+z9YeDxfib8FV037Yk3yeLsUP8znl/mUl/+8c58p/1AN9xlOKH/JrSr5eyX6PXo/0lX+wb3/WnL/MZ7P/SvYjH5+T/+W/ubDmr83nf97e+H89HvuKP/Jrf9Vc/1gP01XAl9Kf9emytf7YeoS/VP+RXw1fSj7z+yppjb+q5396I/nkg1PaS/6b457yB/m1v/X2Jp96kvx7Jft1HfcVvzP8T/xo/ueJ42vJrxznil/WB9aDVPUn63HKeG8UPx3H2Cvi94+9vY3/xudDIT759YLxq34mH/XR94fkE/8/yRey/xHyA38g+xMPvZn72/jBPulty/6vHg99yaee6RMvd+LT31Vr/v9zHOUP1uNB0oqfnc+HG/G/OO7r/p/1hHycqn7NNo6/Sf8/jqP1Z+nzL9X6lXccR/KpZ2+CPQeaP8twfbBqxi/5zfx34fL3+aio85XxC/j4ayv+zPGl+9/WE9aDgfLPeeH5+4/4G8e37n/LJ+C+5i/5dLDzfGt89CHf3fr4U/ZfviJf/seffeJV+y99+H893urntzXua/29rNz/f1v8opk/UtbfO+TLf5eez1LlL/JZSr64lv1Yf64Cfyj5xPew18z/fezHfF9Lf+rHNfK1fpCfB8Sf6nfWF+tvLfsNHEf2W6EP+qt+Jz9aPH3X+FlPvld1+5iPvKMWn/7ukyYf3Ff+Ir6Gm5b9Co+/e42ffHiHfM1f7AtOv4u/9Xxwr/HfOo7sfw6/asUv8cz+34P0Z329hq/1n3wKjuKH+iB9aa7/lg+Yv0PNv29JjdNPzmd+G1b+SFm/vwX+SPqTH8CZ6s/BzPG15GOfe+Tr/oH1BBzlz34Yf5a1/H/j+oyUv8HDrre38bOevrfij/WpZL5o/mAfm/9d6T9yez5I/k+tH7I//hiRr1S/0L+Nv5T83z5/Rorfb44z7b8P8Af3fz9kf+LzR2v+kw9GYb5n2n/mejZ0exv/zfkj5U/ie4S9Vf/afCD+v0l/9PlJ+22LH3A2bfINR/qfeH8j1W+38EP8Z8q/g43741Hxz/x4LOp8Y3zyE/Mp4pPPslnL/+/OHyn/3BH/M29v8ivH0fzbOR4ofu/dnukX8beuz6Ps/+x4qPgln43wl9aPYegvY//9UfqT3zZJM/9ZPrzx9ia/4/EYxS/5fIO+it91Us+/7Nz5o57H48blWzz/Sup4r5+/rsJ+WZ/9XufjD57f/NL9X+J4LP5D6H9805y/zGfT/5f0/+TjifIf+RT7R/oP1d8v2e+z47HyP/E5YvyqX2w+ffP5YvpzP/qb/Wftv/xIan9m2r+1+XzXGj/2eLL96yZ/TLyo/ia/ZVct/c88n4y1/qKf8Yfi37j+v2W/D4+/sebPT/rrtMaPPbh/fZL+c8WP1o8fVY3j+Fm7PRT/GfXAE/KVvx7dH5nuH2w+cD+wTZp88FjrD/E5gf/T+RaP9LdV/FK/bJF/3OSP8fePFv/R4934rJ9/iqb//rg/I/9NCrfnn6LJN/8r//3y/iL5zK/suhn/We76jJW/N0WNM+2/mz0f3d7Gv3b+RPOP+CCeY/3hs179kf3Q7xm+4n9b1Diyv/GfvX3Ep7/Jtsm38ev+w/S5cXsZ/8bjcSL7Mx/BmfZfsK/hyP53jifKH7+rGmeq/0wf8EvV5IMnmn/Yd5p4vBqf+cB6s5P+9x5/U+UfsNnv3flT5j/3i3/FZ/7+DfpP5b8d/THfD1t87rf/Vi1+Vbc3Pv1PsdeJ+IXjV8UP/e2qun3MJ/+o/p4Sj6yHf8U/8v6mWn9NH9bbsxYf/Cr92R9/g6/4e01qe2SqX2084Cpp8sFTzX8bT5j/uepX+jP8JvnWH89PZH+uz3heo/VrGvJXnrfksz/1njT1f/P+8mj/89jxe4tPf5H8V56n8P6D6j/6Nxz5j/2h96ppf67PeP6k9YPrht/i50dFeB8xtNf8/UCfMF9y1U+zYP+c9eKjavGR12nxGe+yxae/f2WT/w97y37/JF/2m1Xuj4hPf+9F037/3J6R/0wfcEfPPxaO55q/9A+O9Q/jyyet8U99/HPVf1wHx/oTj+dN/1v/naI5fotH5Kt+nDMe6rFD+e/C8Vzzv1PVOFf9xu/hctaLz6p/ef76Gb7Wn1t+P7m19/eafPL1rX6/wfPPz7Z/4s9PuD7H37r/G+x6Nf6s+OX5x5HNd+fv7H3IwFf9MLX3yQI+Spp83j+eK/4u7f2/frL/vandv/E+mL0/qPFfOZ6rfjnmeTb+i55/4w/W+xPZn/XvhOdP6xYff21bfO53jssWP/hrUbT42O93i8/zglPJ5/op8rV+mj7w9fx6QTy8uDzjs55+QZ7y55dgjwX5TvsPi/3zwNC+zef5WdLkL3vePuJzv9KV/obha/52k1qfvON8+jfcLZv8z1UtL+LTXxR/c/LJv2b87eMxacY//YFzrd9L5i/3G6fx+0c1Xkj/szC+5drbR3zWq7OqyT+gfdnkW/xo/eb3JDn5/kDrF8+vP1Ev6fklv29hPuWnLT7r9yfpz3r8yd4Xc/mf8E8yCBMk9e/fMR9tPU5uGvykuAnPx51/5b/nzlU/WT4Bf9b+dWb9h/6KQc1PyoBX4FTfvwt4EHBa3DT4KfqsW/y1t7f827P34fjeqo+f329l9Fc6n3xiv4cYS/42XJ8GnPv4kwkY/s75WZBv82nR4i/UPuKH/paa//DBuepXuz5Ly0b8X7s9F/Kf2WMW5C0lv3CcVi6/CLgX9ElHrn8vcXzh/DTEQ37g/o75VdP/8JNe4H8VH/mXrfGvAu6H8abyXx9+J+CrFv+a9uLfBDxA/63zB4FPPs31/lAa/Gt40OYjf9fkg3M9f7H5+NPnq9n/1fNncuz8P/Y+X2iv56c2H7kfO9DzK+JxGORF61fG+Dehv+/yX+l4qPnH+jwk3uR/W8/B9+Jjzwe3t8mf4w/G33X98U+68ni350/kgx8p3+90/UvHS9Uvo6BfRvw8tvjgkexvfJ53RfEXrmf4+1z+J55+BTzW/CO+RiH+slWTb/En+YuNr59jH7+tx2PiV/qzvoJz3f/CT34j3+eP5dcJ81frL/6dU4//Uf6kvn4OeJK0+IxX8TsJ+mW75vjt+nmTv++v8Pb7588BVwH/lf26jiP/P7j/rb3VH4n740n2Y30HD2U/4ntc3DT8B5/4N39FfOLxSOvfm/sjkk99kTKffotPPO8C/qL5d+L+i+RTn1k9JX428/Usij+Lx7IZP9jT1p8X8cN8zPf7Kc7/o/Urir/S43cr+4+8v574+GMQcHrj/GlR56/kTvKZv4z/ROs3+hxZPnE+63tGvtgo/vAHeOzjz7teT2Ra/+gvrZrrx5z8vtR44Vs9Xnh7yx/ko477y/Sv3J/S3+LB/Kfxn9r7a4Ok8fsj7h/svCbJf3GcKf9Wdn5SwFq/Wc/t93QzzZ/3cH0W9J3xU8D98///cI49P5yfh3ySc9TbvMUHR/LhZ8y3f01+8hqw9Lfrc+QpfmdVzbfxGn/meF62+AHnij/GMw0/nTB9jU//h6H9G6+KYz97nx75ifPtfpL40/oz5/2Oo4APVX/Ax575uslPO03758TXScAL6X/sOFf+WiSOuy0+eF41+eBIf+MnLs/49HcW8FLyv0i+1r9F5fisxT8IuEiafHCu+F8G3AvyU9XPXM/Z/4/0ZzxFsH90//5h798NeD/C45ffI/J7hkL5l/MfitBf9PvTz/b+XZAX/X5x//5dGc6/iuqHYETOn1H8fA3999ZN+T3m5yl81z+lvj5Pmvb7KnueNvnp2NtHfPTvbZzP9V5Y71LVH73g/5T6dyn51E8XRd0+5u+8fcQfe3uz/ycw+necf8H4g/5pIX6Y3yn10rnzU+r5FfLbfPy3bPGRL//t+UF+v+d8+usTP1r/uW54pfF/ddwvWvyV6xvxqbcvpf/ccWS/y6Bff92Sj/+oly8ln/r8Cnlt/qhpP+Pf0j5p8m388j/99/GX1j/TB3wt/rXjfqfFP27pD598di37nzvua/3k97lzzru5Vf7j/KZvAUe/f+b30FdlU//rIH+A/35Iftfxlez34PYYjFp87Ndr8e9a9nvw+TxQ/rsJ/hjMmvYb4H/q7W/i/3A8WLX4+Ouxxaee+yb70f8N9lb++4b+hcszPvbftuRTT94wX1ctfrBn+tzig29b/K9F3X6//8h4yB+q3wal4zvx0eeuqPWN+WE86WuL/+rtjb8RX/rfqR7piI//KtZ/2e8t4CqUJoNdkw+Ox9/1/mgf8W9Df0P5n+uz8NOQaPwzfopq/ML5XK9CPTBU/rkN8sGp6jfWJ1vPDpOofk/Cfl+ot1S/8Xtyxm/j3e9f9mp8rPNT7DzRVv1h51Hsfy/h4098PnyV/S0eiub4bT0nfobKv+C8lX/JTxdVc/4yv8hn6U+Nf+Tz/0L1J+sxuKf5+5nzz0ae74xPPkH/G63f/P5snTTj99jOXxvU67X5b9ur9df6m3O+FDgXf008MP8Vf0P0of5bK/9Q334P8oc3LT7z/6jFB//ke9vig8eztMEHmzzjh/mbTZImn/7ug/zR1r+//b1y+cfyP7/fJh7u5T9+/35j550pf3EeGP6Lzi/Ef9RrD5r/2B8c8/08Rmtv9Rvr6VmzfrZ6+gF7af2xeh79DxT//P6U+5kH+W/nOJo/nEc6CvEcnV/U259/VobfZ7r++J/zR0eavyX1xyrj/YJa/ij4LyP+Zm7/LHNM+4g/Wnn7iE9/P9z+xv/h7ev7l1G4ySZfJW6/Wfj+eZ4wf93/fXAS2mv9/RHsMQr5NtP9w4j8f9L0X8b8/lkQPy3+1ttH/K7Fa4vv8oxv8RDyb6b6cVg5jvjUp49Fk2/9hfyXqf4aqb9HxS/xSTxH5/89wg/2y1Q/jbqON57/MurLabBfXmQN/ph8tEsafPPHj6TJp7+x8hf9GX52flaF/g8DniceP+wP/2L/8tjn/4b1L8znTPXXmPtXjoqblE3+hnyh+IEPzq6afMO/dP9Cfya/6/KP+KnkLmvoPyb/UL/+lv2oH3+zXzFy/q+q7i9bpQ1+ztF5R1Wvycd+ij/448Ll2fwP/edlk2/9IX/cc/9xntqYeNH+h53Htkae4o/zV57s/DSX/+T6ZNr/HZOfzhP87fanHn4K/U2SFj/ok902+dbfk+TD39rzAte/F/xr/V24/e3616Z8y6fbIG9WuP0fHGcHvn9BfrV8utX+FZ+KAPcU/+/BVOC87/zJyPXZKv5/uv4T5Z9tWeNU+zfwM46m6yl/wv9e3DTWv63W38MofsN4zpt8W5/XrfzDemz5T/ljWDj+rvw793wyUf1KPgKnn8UP60u28fXW5I89/0TrB/tJw25z/WJ9zCbN9dfmxy/iV/rbfA79ZZcaP/FI/fRURvHr8Sf7l2Dmv57fsT5k3K/80fy1eijko4n0J7/Z+hXlz9L9+VP8Bzs/5qYxfzgPYML6/Un+79n5EUG+9EefB9e35gf7HTf51CNmvz+qv04dR/Zfuz2i9W+M/7hf+a34tXyIvyP7E4/UD3r+YP549vbGZ//gGb7y15b81W3KH8kf0fipT5+rWt7e/vSHvrr/YD3Ods3xmz3wx0T2Z3yTjseL6V/6+F+kP/H1XLbGD3/XGn/X5Tf8X8djJJ96xuJPzw+YD4aj+KMee2H+aPwl42G90f3jmHqA/f4X+e/e14+J6senpPZHrH/lOMr/a68HI/8ZPnZ/G1/2eBb/zvFE9afZ89jtbfG/dvtF9n9yPNH+97Pk6/nTYH9+JPnO3x/a+ftDE+0f3nB+H/d7qr8HOs96p/zF/cEuyJ+qfiG/kf+yd/mP+LH7FdUf5IO/of1U83dX1ThT/pwyH7lf0fP/PZ/99nWTnxBP0ybf8F/xWR9ekS/7/2U85Fvd/5g+rBevsj/54xV9Fb+vZY0z7V9PiSfy+VvV5L8h77jF5/lD0uQbfhWf/qsW3/pjvzsTv+O4avPZv1b+e+N5DPvXuv+l/3zQ0p/xvFMv3LT4PK/R/Qvng+fU+9H5/ZWdpxPay3+cjz7k/LGR85cjf//ir+7fPuz9ycDX/OP9DOIhHzf5Ofmuq/f/iW/ieST/ffb3oXLFz3zr+EXy0ecN/ZU//oGxl/afZ5XjTtLkV2UzfuDPk6b/jE+98U/7F6yv/6iX5T/6B+eq/62/C5cX8TsBz7X+V45z1d+zkeMoftg/P/R6Z1//wA/xkKv+sPsxxnso+dTvn9FX9/+HjId4V/0+X7v9Prf5rfEfOo7sb/xv3t745N8je/9D/q9qnOv9mfnO+Udli8945b8Oz5O6LfujD/X6keRTfx3zvDl+fh8w9tf+9QL/bVry4X8u6vYxf+TtI/69tzc+10/QV/njRPzo+X/h+KRq8QNeKH+jHzjX+kX/ho8U/6yHp7TX/utpUeNY/sbxcdnkf0HfTouP/55b/J/evn5+HTDy4+ffARN/b+LvHHdbfPAisl9Z41zrH/0bPonzF/mouX51y3o9itafJfc/R77eRXzWr0W3yQdH44dvuKv5e+zr2VLz9zWpcTx++mP9O1P8vDleqv7aoT/xHq3fI8dnkv/hONp/BC9t/8nvX5drx6ofcuzxXtbtYz721v0L+cny0U7715w/ecD9gs6voT6iHsq1f9U/9vVL9Y+9z/rBeqf4faSeYL5p/8TWc8Z/oPr9k+NZvP9er6eR/QyzHh+oful6PRCvP5WvP9H+98bz6bHi76fyj/KXzUfmj+6/bT3GHh8a/2e351LrL+vTcteUb/qwfh1I/l+fj8vo/SP6a8k3fRjvJ9VfPM/45OvNPv68nsh1/2f++OTtjW/x/V/FkSy1/tj63huGv9Oqjh/8Z/VAsa75777+ReO39Wk0bK5f5BOrp8uab+Ojfonnf1XXM3H9wnpAvfah+T+M/DGs+e9VjaPxW39nTf2tHgJH8ct6jP5Jz8c/Z36Bo/jh+WQa7LfQ+mv5GNx3vsUX+JPih3hIgz2Wkv8Pe4AHzp8hf2jY9ac+ZP4max9/RTxRb+j+hfmVn7bqj8TxUvn7sPD6Re9PoE9+4Poa/8TjJ5LPfEqKYWP8xJPFr7Xn+UWKPYpm/H/CvjfDWp753/J7aC/5/90AB4w9CpefyJ5DyScevjT13/dXNe2PP0PF3tCf/q0/19/Gkxbefp//ivp7KCPnjyrHmebPzN7/Xof832vyed4y0vl929D/NPBz2W8i3HH5GeM79vYRf077qsUPOE2afMML5xteBtxz/ZMCLHm2/xr0Sckf55J/7Lgn+QvHqfyXl46lf7oK+Ap9Jf8y4D780vn9wvFVi8/4By3+AHnrFn8T8F2Lf+ftjX8T8JDx3jh/kHh/38UvHQ/bfORXks/1rutrfPp/aPnvSvK78p/kl7K/5PfFJx4fOe+t0+Rn+Hus+CWefyBP8cv5+z/te6XO57rhe+mPPy8CHmn8K+Gd/F/5eL5Kf67/bMX/tfsjU/5nfIaj8TO+Wcv/M5efRfGXOP4m/YmHX/BlP66Pab9yvtkDf/2Q/fgeR8/OG3X+U7g+gb9x/hj9ma8vzs/w55+Ap0mTPy28fcTHXtsWf+ftjf8MLr09/AkY+7+KT/9/bf6vGnxwpvibBPl50pK/8/5mkv/iOFf+Ib+Y/z9k/57jXpy/w6sayIvyP+8T4+9/Uf4P+ycd8r3e/4Vv+iv+OR+d89OTQ/mvZ+d3VvH3v+x7YHP01/yfla7/kfPzkeOF/PfhON80+YaVPw2f0l7xdyK+8seicHza4n9p2e/c+0s1f5bwyRcH4mOfTwEX0v8MTPtuk9/Dn90W/8DbR/xl4vLg038v2CvNnU9/ac/b2/0L9emyqtvH/Jm3N/nBHinr+ULjR7+vtNf8HTGfgj9T1V/kM8PK3yn1QFE2x/8VfcJ40kz6h/mXkk/PW3xwr2zy6S+dtvjgc7dfSv6+SJrjPwcHe6dav00f1vuLNh/5ip/CcWx/9ClafOqBVcB9zd+LyuVPWnzibVU1+Yy/P2ry+/hP+Z/+U9aLS8lHn8uylmf8VRh/P/gzvWrx6e+yavGRp/zB+Pply34d7+9K9R8vHVzRXvmXh8bg+PsNvLTDeS1Xiv81/SFf9mc9z9e+3lv+wx+0n1dNPvHYV/6+Rp9Qb6Xi9zuObzR/vjvur5v8AfF+3+Jjv5uiyTf7af2nvwHz99H5A+y/ga/4Z32+DvzBqsVfefuI/9jyH+v/Tct/30L/A+aL1p8B8/mXyzP+74BvGe+2xQ84fWrxH7x9zE+a+htGvtbvQen4TvbfOh50Wnzs/drig79JPuO5Q1+N/y6Mb4i93sXvOl7L/m+OB7sWn/lXtfjYY101+bdVPd79/lHobxj0SbV+DkeOv0s+6986jGfY5mO/Tov/2eUZ/8X7G2j+TOiv5/WO5e+w/qVHLs/mzx+vvyL5YOqR9Fj80vF3yae/+6Qeb12/hPqC3zu9qX4Yef2g+i/LvB4caf+N+dwj3nT/YfH03LK/+ZP6UeO3fIz/VH/2uz6fFb/JseeTXPdvtp72WuvP1tevVXz/n4T3zwNf8U99RT2Wqn62+gp/zJS/mD/3RT3eff1a1vVUeqL1m3xwS3ut38TTfdWsv6jHhuj7ReOfORY/vXA8UP5ifWI9ivnHbs8Hzd97xwPVb+Tzoeod4+8cX4uPfx9Kby+++T/i03+n5f9vjqP8deX5LP3U5Bu+0vipj+dJnS/2639Rx0N6Jv8H+2TUW+eSz/7NA/sX4s+1nkn/nvz5IP99dv8NZT/ia9Rr2X/k8Vcqfnce/7nq1xv5X/Wn2YP5/iD9/7j/hqrfrD/ms+4fesF/Wdqqv5gfZVLru7d/WfcXye9Lnyj+Dpwf+d/iYeP2tvy3cfml4ufE7RfJ53s8o2CvTPUb+cjwVPOP82v4ns+oaPEDzlS/ZiEeMurn6P6N9ahEvub/1O8fI/k58UP9PNP9A/nrB/Gj+Wt47e0tf668vx+uv+GyrNvv77/xB/ZS/TkqHf8U3/Y/aN9p8QPOxi0+/n4sW3zkK//S/4jxF+ITP9RPj5JPfz8Df9xr8sf4b9Hi099G8rm+ob38hz5j7KX6d4T/qL9/VU3+L9qXLT7+/9bik39/FS0+8nctPvpetPj097ul/++kab+ngMfYX/XnOFzPqL+eJJ/69yn0N0ma/EnP20d86s3o/ZW144nsbzj0l/10vr0PAz7T8yf2v/v/jz/VeRP2/AR9qF+fZH/WE/jR+RNb9j943qf6eYI/qPf+yH7Ux4d2/orL/8P4gz+j85eMT757Tpp8+ptsWvy1y7PnH5zfRv3xR88f6P854InWn0P7HkHQ/6XFJ18P9fzU+MiT/+l/0mnKN33INy/yP/XoM/qrfnkJ/Cn+U/076TreyX7UZzvaFy0+8+9fi8/6+7do8sFTxZ/hkM8y7f9MmY/HFm/Op375i7yyxQ/2zKoW3+SXTf6rt6+f/wXM/NP6Y/ZgPX9V/NH/G+17LT7yD1p88Jv0/2T2HAXo/LfQPzhPxe96/t3p/Tf4G3v+0eL3PF/un59nSXgfKPhf/A97Hh7aa//A9OF5T9LkZ59D+0rxy3XwTP6vkhpH+s9Wbs9Kzw/7jmdav97B62b8wc9ZL96rJn+H/6oWf+PtIz7r4Yfs33V/ziL7JTXOVb/Tfz5r6m/8D/iSb+OpmvbHHzn7ae+KP+bHv6I5f5hPszAf86Xk44/C20d85uPsuMXvenuT33Hckf3njufyP/3PZz5fIj7rX0fx33E8lf9YT1h/8pXWj2PHh9L/3vG8xQdH6wd8w1vtH7F/8Tnguex3GPSZ4/9b5U/iif2Wz0WTf+jrZcwP8z+/afKtv8+KP64fIV/8z45zrb9z1pM7bx/zy5b+8LHXpfIn9Rj3e0eyP+tRqvOy4D9jT/xfNvmGU72/YHzeH1b+tPWN9VP3/wviF/sfa/ysvyfoq/g/DvIXxOumxWc9Oi6bfOy5WDX59Jfr/n1BPmH8J5JP/6e8P6D4QR+Tv23xn1r2X3t/kf9OkU/+fRYf+zGfO+Jjv9MwnsWuyQfnuxYf/KVo8sFzrR/gBf7X/seiI77sx/OkbvL/+Phf6x/XDXfEf3f9l5r/3aLGudbvZc/tGfn/3eq50H7V4rfsb/xHbx/z0Vf5t8v7BLy/oPXf+mO/60D8f46XNy3+uuX/0vs7ifdfAt/ed3D+QVHjXOv/Ev89ePuI/wn5nRa/05x/S80/zd/8THzl70/wuZ/+7w625nccHyctfuntbf7Y+xdhkY/Ozzt2+/2T/IXW096o5v+jv9Lbi5+kQX5k/4XWH9XPSRGEjujP9af/nOc1H9H7K+G64dGoyZ+F9to/XFp+Cu3PZP+xr6dR/cH6brjn8qkHkr7kiZ/ykuDK5dt1cCb9b0Z1PKRVWes/CNcNl85Py3Lvzyh+4Cf8iC4rmvzM20f8ZBPaTyR/G/A0o5HzuZ4XZeP8vkz8eZNv5/9lVYufNOUTT+nM3ndz+3M9/Ag4Pv9qAb/iJS4ff146/ir5xwGPvX3E7wX901GTn3S8fcQ/9/Hun7+KP3N+Dz7vQ2r81v+Fxc+qwT8r6/M+I75h/X4Cfez8zE/iW/+8L6bz+/hR9IL18FLyw48mc+6/vij++dF2H/1vRg2+4esmP7kJWPl/z8f+ir8BfPx/K37peCD73zheyP/GX4f235xv1++QHz0/C3iI/scuf5g4fpD8yuNhKP8ZH/k6vxq+4YsW/8L9bfOX83GNr/P7Tv383JhPPuE838j/JeMvfLz2/Frj/+H8jHj+6e0j/ijgbNbkG960+OBR6Xz6GxfuL+OH61nwd/bX519G/P729hH/xZ63y//os2r6P2M8vCQ9Ef/JcbZ1/ph46nr7iP/M+HX+FvxTzvvrtvi8L/qi8zt5vxX+VvHD+70De1/f/Tew3+8Sb9H78+H6N3v/3c/Ptf1I8r3qF/aHsmDPTO+PjVkfn5vjt/2trb0v5Pr/Cf2xfxL5b7JyPPH5Y/sr4InqD/xh+ym/tf6wHvGj9tTzt90Pcv+cVS5/p/vf6P0d7HuPfOfb/laf8wf1/iX7e4w/1/6j3c9w/3Ki/WfmY49477h8W5/IF0vVHyOvh6P64dHr+aXWX/Kb1cPKf1ZPL73eNP6D22+p+o/6yOz5IvncD3xprb82nwLOdsqfledPzV/2h+3+fSr/f3U8Uv1E/xn5603rT4h/kz/V/B2G69PW+n9a1fVsrue3dj8Ansn/L45T1R/D0H9OPfah/HXsWP63eCCf5qrf8GdO/umInziO8m/h63Gu/EV85EGfXPffdn/2ObSfK/8S/5/teaPyl9azI+WPnuOF9P/hOMqfGZh4/yf7l46j+uE7+iTN8WOfnHx5Ivml4yj/EZ8L7B3FD/bEXqeyH/75wnrr/rd4WCYeL1b/c/9BPHcV/+Az9BWf+bhAnuYf9mT/ItJ/QX7jEI/o/gn/4I9c+Yv5aLjS+LHvccBL2f/RcTT/RpqPmn/mT8Y/l/3/YL8gf679b+7nLB9Ifk79coA88TuOI//NFb8H4pceP4X0P/b5F9l/IX90m/w00Xy159/uj1zrl9kz4DQVf+V4ofmPf2Zl038z55u/98/vHM/Et/EE3FP9jH2Jx1j+2nEhPvNxWTT1nwV+b9Sy38zzWcR/c3v2VH8zvl7P/W38Y5cf+e9A+st/PJ/qBXmp7r/GPL/l/uury7fnYV/Rd9Xkj3nePmzx6S96fmZ85Ct//Lb3B4N83T/wPM3wRvtn7C/x/K23bfEDtkNP9vVj4E+tfvP1k+dzvP/ZU/4A5zZez5858rl/Opf9yB9feX+j0+SDrb3xeZ+G+6V73T+wn8Pz3J7in+fDPA/O9PsNno+krOcr1Q/cX69C/Ew1f195fsH7Mucu3/jgVdXi4z/FH/x+iOdU93/9MP9T8u2l+z/l/uUy8PtaPy+Dfv2Nt4/43K9cFS1+6K+/bfGZP9ctPvXwletv/V27PONfgZlv38UvHV+XLT76Vy0+80X3Pz3e5+F+4avef6D+uwnjGWj+fdX7tz9afOr9G+kP/1uQN0ia/AHzT/XrIMzP9Bd86U//BfGj/VvT58bbR3zq/W8t/oW9r+fyb9EH/z2Lj/1YT+48/lLuL25Df4Ndix/smf5t8V9pXzT5d+ir+Of6oNuc/6YPeC35rF9r2m+b/CHx+97iI/9O9rf3p3j/RP77zvsz+Ev7V0Pev6J++Z40+esw/uGszQ/yDl2+8cHR+3/0fwF/FMXfun5/93MUvwHzPkP0/i/PH/Bn5L8r92f0/q7xP7f8z/OJ78EeQ9V/9N+38Uv+yvF32Y/723vsLfvfMX7mb/T+ZsfH/5A0+bz/OVy1+ORPrV/Gp557KJp8+htuIvsHzPztRvYPmHrlQeM/tHgO8nT/d2PvL40a47f3edGnlP4/bf7W4435xHv0/i/P06lfyqLJBw+Vf+/xRxh/pv1jsyfPS+6i9yfpL7QfaP0pyachHjOt36MQXxnr9w+t3/B/VHX7iM/8tfYRv+fyYn5oP1q3+PhvF/kv8Nn/vZP96f8KvtaPr9zPbTzfW/7Ef9QTP4sm/2fwx2jb4gecTZt8w6pfrH/Wn1GU/0uXf6f4p7+Zy9vLJ/9Tf8n+58hnvHr/p0d/1GuP0p98xqFwQ+X/b6zHvO8ezV/8Sf3wQ/LZH1uhr/In6zn+yHT/b3zwheYv8f0Q8Fjy75MaZ1r/LZ55/nuj9wfhb4hf+Z/v2Y2JF+3f8X21nO/pbnT/xPeRN0F+/P07vp/J/pnqB65nV9SPuv/me3C/uH8ZtfiM98r5fE8uo56I5KPPb8ar/MH34MDZbYsP/lU1+R37/qjzK74nuWp+P86+J0k8/dX3M/k+1RPyFT9/7XuqQb7qD+NTvzxp/hof/+2a/Kl9P1X8lcvX9/cMb5Ev/X9XNY70p3/TZ6v680Z82Y/vG870vUrzH5h6Q9+ftO8hvnP+lNY/vqc4wX+qn4xPPbSV/eFvgz0mhepX+37tqDF++57jucsz/rnHz0zn/4Mn5Iufzh+DqVf/aP+J+ER+xDd9aK/6bRyO2spPw09j/sh/d44n68j+vT3O1n5+4jgclcShnsmTnx9t1/+wfyn7P4WjlsCZ9n/HvA/ybPPH1w/yE/loEq3f6IO/o/x97Pn7WfmDeuolqeu1ff5HH/Kf9h9GWo9etP+EPQ7CeCaqP6jPJsjT8x/6N31eZD/yKYesTnX/+lK5/qo/J/A/vH3ER//JrsU/bo7f+PS3a8sv6vb1/nHQZ+byjN/x8e+0fnL9mfbKv/RvfO3/TUeOnxV/z26PaPzPpa8/r5LP+vVu+afJ/xvaR+/Pwp8Sv6o/p8E/Gfsdr7LfZ+9vqvilvynxp/eHjM968Sr5XAePo/cvJV/7d8SH4T+yH/vzf6u6fcRfhqN9M+1fGv4X4u1V+ePEcaw/eOf6mnzmY9WyP/dTr2XTf+bPojn/uG7678Q/dDzV/GN+c0hvpvp13Elr/KTzbz8F/S+DqKnWj7dwHfzfdPX3X+19RosXn/88D1ja92qi+FmH+RD8ofMnwCnPU/X9Fnu/le+n9OLzJ0ehnsuCfpr/K8eV4odHpeARpRX8deAPg+lz7Z8Ne44r1W/v8Kk3u85/C/bsB3m53l/AHum7nX/m9mM/r6Lejs7/5Dy5md2/lC5/UGN9v8CeD6HETPE3Lh3r/pvne/b+7rv2P6knxrb+OH9Q1jjX/lm6daznvzn7Wx/wFT+8FArOVf/OSh9P1eZTf1UtftUcP3yz54fy98z5A52/84/1oDNo8umP71fo+w3G53sW0fcbeD49I34Xrr+9DwXuav+c96uwx0zxz/tRS3tepfpt5Lij+tHeh+RQbf1+pmP1ZJCv+nXO+y+s/52ofgz4kPaqP4zP/kt0fmDP8WHR5Hequv3+/oHz5/C/9r/4no7hC52/SX/nnH+k+Du0+B8k++/NmPzVqMaHGj/1C/x+9P2PkKrm+FvvDww4zxn8TedHb0JXd1Xdvn7+EcYT8meu+mtOPFK/HkXPT9z/s12Lz/27zn+bK54/V03+Ef6T/+kfnEbfz6I/zmu9ib6fFvjgKH7h8z0ba79fv4Z1/vqr/Wd+v9Wx972j9a/GUf7rE0/Uz4/KX+zHHqO/6ifu59i/zUvFP/FHPXqs8VMfn/C+hfx/XNT6599bfPLRtebfD+9vUTT52C9X/Uv/OfXspc5vsv6IH50/doJ8zt/W+ecLxZ++n2T10KPXO8Z/CKpwyH00f4eh9DH84O+/p2dh6GVVt9/b3+0ZrZ+2HrN/d6T6gXrqjfov3r8ehXwU5On5f79wfKL6l614cF/fbzhN6vmc/5H9Sp/Ph4p/6gPW07nqD/i2Hkffryi9P60fxn9Xe/j0x/e0ovxh/XP+l/JH9hDqA+KP9Xpff1A/BKNG8TfV/oPsl775+hvNf/wzC/aP1m+zJ/njRONnPn94vtjfPxOPPK/X/q+tx5dub+N/9/m/0P2jzQfeF9L+NfFtOMp/G8fR97vwz3zW9N9cfOV/+33LG/oq/mw9Qn/dv9h6hP3+6fkR8+e9tf5Tn+HPXPt3c/v9QKt+yr1+iuL/Z/hz0co/c94n4X7si8b/zfFC8j8XtT9z3b9x3fwR2f+382e6/zwt3H66/1ogv9+KX+z7pWjWT8TDgvjT/pvVM+OW/mbPwF8o/v+VNY7ibyYs+9v69IXn5bKfrSesX3p/ZI4+1P/Hil/G0235D38uyJ96/jAj/34061fT5wv3K4pfqwdGTfvZfHzw9cL45OduVcf7Pn+X9XhyvX9h49n5eI3P/m2X9sr/leP8Rvp3XP8v0p/4fsd+8h/+AOe6/7V6FnuciT9wPFP+40dKJj+KP/z/6OM1/rPjZZQ/yxrnev5p9jzyeNvvH7n8SH+bDy3/L7quz4Hs/+Y4ih/6N/nyv/njpKV/JX40fyofv+4/l7LfgfTn/vugpb+Nh/mm+2fiKz/09sb/EF/+N3tu3F7G7zmO5HfEV/638Wx9vPvxh/Xo0M/bNf6hnQca2uv+w86TJd51/7DkPOGOtzc+1z8hT/Uf/S9t/onPefQ8b4n41HenrfOf7TxszvvU99cXnCf67uclGz+3ejrUr7p/tPPQOW9W5/eOwlKTc//96N+Ps/NsD+y8SuUPex854CTz/VP643sHn6S/na+ebBrn39r5sMm4lrdfv8L1lP7KTc2nHuvYeafjmn9o53+Oa3n7/BX4WeBH8h/seuivcP5RJXu6/tgz6QXcUf19YeeHbhry8UeyCvK/R/VP4A8CPy1c/638cSP5Rc2P5C/Rfxhw5L93O082CFk7366DB863Rz+jjO/11vL/c2W5xxPVTzxKAmdPSZPPo6Mscf35/f7fMHWmx87nfVLDE/mf+1PwVOv/LOF9duI/+v7Nev/7u1zPT5NdsGfm+pr+04xPNQfc8fFn+PN4HPZH/Pxl+MlY7SN+UbeP+FPq9cz54GQR2r/p/GauP9ur1bK/nf8Y9NX5Qwv9nqgn+/0W7jo/CfqkxNO528/ii/jrafzMhx7zYeR84judBbxS/DAfif9e5fKpr/rIT8Tn/Uni70p88hM4FZ/9p0+Jt9/H7zrceobxR78/7Pjv3wYa/3fHqeKX95PtfeRvGn/heODz335fYzjeP1jvf7+Y3Gn+rhz3Nf/s/NGAo99/npZ8ajLov/P4X2xDfH4P/KH0fw7XT8N+Z6r4+85WUYin9NjjZxhKNetv6PZLKdXAqeLvmtI3+CP97vw+S+2PjE/7OZ9XSe5pr/xzAQ7xkM6d3wt8628k+TPHmeInsff/A/4p+1PfUS+ONX+ov0bmD62fth/E7498/lK6mT5jxe8Xx5nyH6Wz4a7rn7HV123mn4ylOkf+1vn8Pgv7xb/fu/Hfb2n8OfsfNn7Ffxr6y4jHrcZ/41j5e5/PK29v9gOTD57FnzlOZb/c+8uUP8iHGfnuzOPP1lfW04n0v7f370P87OT/ovb/f/dn/v124uc3+V/yF8p/st+XpI7/5MH5Cz41+EL8a/78IX8Xvb2++/xX1fkvuXH+kPXlnvgVH/8Qz6nsf13U8Z88RvYb1fEo/9l62C+b9v+U1PGXXIq/cv9N5D/y6aT0fLuP/4Cx34X4iedT2d/mA/knU/1g6xv2jPIX/h211h/Gw3zKlD+z0tcz8c2/17Z+Ov/OcZR/yScZ/Hvx8ccr7TX+B89nmfIP/rB8Ukh/+G8BzyR/6TgtnZ9X7s/3Fh88lf2uPB9nlfPNn+An1S/Y86O1/j27P/OZ8/Gn4Q/x0a/T8j/xMA765LLfJHHcER/8mfZaf365/3LlL+aX5a+Z+Bvvb6bxfwWjr+KX8RnW+m/xvQt4Lv2JB9bPXPYnHxjeyf/Y8wT7S/+1z+dc+Yf5aeuR/GfxAFb9YvN71pI/LD3+Iv6N228h+b+F5X/smW69vemPfvMW/5vjyP6DwvGt4q/j/oj4Kx9/lL+oh6x++i755IOjZv1k+WFOvGv9n8oeh+J3nL+Q/5iPC/yl8eMfw39lv2P330Ly6X/JeJV/iA+Tf6b8P/P4W0r+PzD6av0nPnP07YrP9S8+XuN/iC/7kV9M/zfp31H+kPzK80Eu+1k8gY8lf+3yI/u9Sb74nM+V8f6Azh+x83T4vfqHnh+f2vN77le8/vsNZj/jwOXb833w1+j9h7D+LblfWPn9y47ns6x3n5xv18GF6pfDpMZTff9zF/aveyF/Zrr/6fM+J897rvX+3ND23zf79/2Mz/vlvTBf08zl2/vo4Evtf7M/yfuIPa1/1zz/WI+afJ5HUa9E75+zf10E+b2iyQenun/thfhLWW+/uv/s+lf4yn9FVWMbb8Tve3vjc/1raB+9/34e7NnbeHvjly6/kHzW43PkK36Nv/L2ET/19jG/quXt+aH/XkX9LT76cL95If7Yca9q8Tst/VfeXzT+pcdTrvvHi6oeT6r1u9d1rPgzPvHbO27xj11fm3/0z0+LV5p/xDO4r/xBf+B0Ifn0x3p2ofhnk2AVcF/rN+/nEP+R/lOe/5Nvo/dv7H2cqm6/59vzu3Fj/o40ny8ln/14cBT/5s9ty36Fz6cofgqPh0h/iyfmn+6/rT/wSvnzwHFf8+cSe4b1K73W/MP/rLdXkn9p8zm0L1t84u22xQdfKn6ov65s/ojPeDot+TfOv6qa/Oukbr/nV85X/dlfO75S/N36ePqK36sgf4D/df/ex37UqzfiPzh/EOWvqsap7l/p33DEL8HIk/+4PsDfun8yfbgf+dbif8NeuxYfe/+WfPLHU8t/+POW9sof2Gew9fYR/w/tqxa/qttH/D7zTfevFg/0dyP52Pcuafof/w7wt+rHgfx5Lf5f9/9A+eOucP+vW3zW63XS5K9d34hPf6nqhwH+e2/xuX4X7D9U/rmrapz+a/HBa+lfuf0j+fQ/JH5U/w8Tx7fR/ovbLx5/4vZT/TdgPfhwfY2Pfb8XTf3XjOemqb+Nh/6+i489vjNe5Q/GNyRejsRnPNSP90mTv4av+OP6cNvi0x/1173kU5/dI69q8Stvv9//Cvg04AfZ/8jtGelv4+k043fI+v/Z5Rn/s+wn+2Mfk38iPvYk3z5o/NS3D8jT/OU6/aWq38wejKcU/9TxUPmP8Y2CvTPVT1w3XGr+njl/1GvyyQfx+OFTL91q/F9c/5HWP8PBnpnqh2HX89kP+Y/xPZR1vor5wV5Zr8m3/jT+jP2oH0VT/xIc+suGWn97jkuXb/b4gTytX1wHZ2PxR45lP9PnB/ZT/WgY/fX8wewB/il+z3HMB4d4yEbiow/3jz/d/nbd+Ip/ro/wl+qf0cbxo+Qznk3Qd9xr8UN/WdHis1/wWDT59DfS+mX6bF1f44PZr9zI/thjE9qPNf9+hutj/HfV4lO//CpafNrPWvyblvzK+9sofhjfL9rL/maPtY/X7r+IH9a735LP9d/wFT+bcH2M/+Yt/rW3j/ne3vi/NH7VP4YZ/5P0v3Q81vzHPuPj/8dnP+FJ8rn+hP21fv+qnK/9V64b/i354G3SHP+T+D/E7zrein/jeKL157fjTPuP1h/6b2X/0vFE/rf+As42zp8kjrcaP/XYH9or/3AdHMmf4D/qqa3mD+N5Qr7ix/QpvX3Ep/551vip555pL/vT/4T4/SM+43l2fY3PeJ6rpv42Hvz1Ij79bV2e8envhfaKv2fGT/5Q/WX9oc+L+PT/QnvVz6YP860Sf+f4pWzxW/qj3xR7af90snEcyf/j9pwqf9l40F/1i+lD/bST/Rjfjv0T5R+ug7NX8Tsu/6/k/3U8VfxZf9hb9QvXDf+V/H/ia/+Q69OyKd/0gf8q+R3HU80/6w9/qf6Zrlz/V9mfeu4tacmHj7+0/2bjoV54E/+z46ni/y+48vbGJ59S/7xp/hw5nqr+M312LX6Y/3nS4lt/Qd+Z/I8+4Fzvf0x5Hp617Ef9UYX+Zso/9D/j+Z32j6Ydt+e7/Id+78iX/d4c52mTn/e8vT1/4vq7yzN+Jb7WfxvPyNsbPxFf8ffO+DctPv1Rr3xI/sjxTPnnI6lxrv2XWek4kk899S9pyUcfnh9q/ZvxPH7h7WM+8lU/mz74K3p/g/GwXv+T/LHbcy77fVSuv9Zv0wfc0fs7U8czrZ/oM5+5vsbHf+wfdSR/4vrMFX/0B861/zIfOT6U/c8dz2U/+p/fNOWbPqzXh9L/QnzNv47sp+efpg/4s+R/dTxX/jsM/pljb+3fcN3wZ41/5Xiu/G36YG/df3Pd8KH4rK9HtFf8mT7Em55/cN1wJN8w+ip+rD/GX4qP/1ivj8sm/zjwF70Wn3zz0OL/bMln/+KY8av+5voCf+v5MdfzTWv82OMkyFtE718lNc43Lf6jtzc++hzDV/wYTpryuZ5Tf5xq/j1q/IofxrPA/tp/WuA/6ocT2Y/19zTgheqHU+Sjr54fLTaOv7T44MW2xd+5vhEf/EX6sz5+ob3qD+sP/+v9B/rPqT9OZX+ufwl4Gb0/V9Y4V/2CffKXlv2eZD/5n+umv+o/88dDS3/qjy76Kv9w3eJX9Q/X83+ur/H/On8p/zO+ZdKS33X+meS/OY7G3w32XDLftX9k9gCfyX/vjpfKv2fwsZeeny6JH/ZrzqT/oeSrfjFMvGr/xPQBH0h/+jsoa3nG5/oS+5+KTzxTzxxULT76yn9d7Mf8Vf1h+px5e+Ojz6cW/xPyyR+qv7hu/E+y35H0V/xiH3Bsv636++8OZ88/dRzxPzG+3iQJGxz+/i7X99j51D8p/dE+4s8mTfnwk6ys28P/ovEk4tv7cJO6vfHJzwP4kk/9ltHfqsVfBzxq8s1+aVnz9/oUARfOT9Xf2Pl23XDh/DTjVbOAt85PhGU/62+k9vANM57K+TYe9J+KXwY8a/HRJ0+a8jPG12nJ3zo/F5/rOe270l/8QvyR47xs8nvWX4tPf1/Fr3w8kXxwL7RPxccehlfi7xz3W3ziIR21+Nh7Lj7juUSex5+Np4++x87nuvGvxOf6Nfp7/CUL56dr56NfWjT5hm8kDz7jGdC+FD/x8X8T/0Z8yUefAe3lf64bXkp//HEX8FDjXzpOO85nfIbvW/xb5FUtPuPX/Dd9Nt7e9Ac/BDySfMY3CuPP5D+zx8zbR/zS28f8sjn+Qen93YlP/PykvfS/c5xq/mGPDH/9Er9yPJT8tfMz5Q/0ybDHo/MN/w54LPk/HGeKf7NH4u2Nz/Un2st+G/EVP1w3LP0z4vlPwBPFH9cn8DfiF85/afGfA54mTf60FT+mD/G6FR/8l/aS/9txpvwzFm7z8f8safLBmeRPEudH+uP/d8Yr/3F9GvTNFb9cz0c+XuNvnD+T//44zhW/9Jcde3vjgzu0l/zXgOfIU/yYPRjPofNNv05L/j/4Ybz5jfNNH/CH+Oh3FPBC9uP6AvnKX7PS+act/nErfoxPe8WP6UO8fBZ/5f5fSH/Gt6S9/Gf2AB+0+F+8fcwvm+Ofg49b+pMfPvl4jX8qvuKP670w/9JU/I3jufQ/gV/V7Y1v/XVcnvHB3YAL2e/McU/zf1k4jvhBvzSnvY8/pX4pkK/44To40r8X4iftBfzVx2/XvyJf/i+QH+ydDlr8UXP8ez7ylX9Mn5HLMz6YeuXcx59mjns78cGVtxff7HeRtPit8X9N6v7SvviMZ+7jNX5ffMWf2SPET6r1s3fj/Avxsc9F1bSf9bf19sYHU2+sZP8J8gPuK36wR7/X4gf90q8t+dQfK/RV/F6Ify4+8XPh/jI+47sM9uqrfmY8ffy1avGpny7LFh95it+VjyeSb5h65Ur+wx5XtJf9VviP+Xbb4t96+5if1Pru+ehTNvXvMx9Y7y/FX4mv+ON6n/hT/YZ90u8BX0t/7HGFvRQ/1t/a5RkfTL1yLftdO+7Lf5dVjWM+8Uw9dC39TZ/QfqD44To4XYvPeFg/b8RfOx7IfoxvEPyZblp86qebqsn/xniVf9Gnf+zyjA+mXvim8d+7PweKP+wxYL49tfjUAzdJk/+N8Sv/cB2c/nD+oOf8W43/h+No/DfIJ/60/nPd8K3G/9PxoGrxma+PLf4u4DvJR5872sv/t+hPvLyKz3jeWvpjn3VoP1T9gj3AqdZ/6+/D5UV8/DFU/Jg9uq3xg6k3bsV/8/6Gyr93VY2tvfG3jr9L/2fHA80/6w//d8Q/dv2/S771x/iVP9ZVjVPVT4apR+4VP0fiK36/w8feJy0++L5s8sFDxS/jGTJfu+KTP85a8YN+D8jvtPjY66DFB9+Lz3geXN89P+gzYv6rfjB7Yr+yaPLBI/nfxrNpyd94f6XGf+L2HCp+7+lv1OIH/2VZU3/D6D/S+kH/4PSL+MGeGfXPD/nvi+Oh5p/1F8aTaf1HP8Ol5IN/lE35P9we2dD5o5XjHz7+vT7wFf/oMwr2zrT/xHXDD65/Rv3wE3nyn/UX/J+p/rH+kP9T8kfia/78TGqczcQvHUfy6e+xqOXt5ct+C/HXjh89fjLqk0f0lf+tP+w9EZ/xTF1f43N9k7T09/4y7T/ZeMCP0t9w0Hes/Ed/4Hj8IT4y6pEHyef6Br7yP/2P8ddFi0/99Stp8ukvij/TZ+Xtjd91+/2SfHDJ+KU/9hzj70vxmT/UC7/KFj/0Ny5b/I23j/jsH/2W/Evvbyz/ox840t/sedsaP/XJlvM34+9HbOvzY1V/jPEf+Klo8sFj7b/BB0fnz45Dfsyof7aS/93kh/aKP/qbEL/avzL+2tsbn+vbMP6Jzu98Aod8kP0UH32oZ7ZVJD/Znx88KSL5Nc5+RfJHNY7ODwb/QZ7Wrz9FjTP9fmRCPFGPPWv8vxxPtH7R/2Rj9nL7cZ4q6/2z8v99+P3ONefdyv/XZY3TI//97ozzL9kv+efnN+bzcP0F+Zq///g9Oecv7DR+fhTLedAvsj+Hdr0wfv3+nfOlJ8yX1xaf/YMX2Z/zo/7Y+a2yX1LjTPsvnE9s+Clp8sFR/Jo/R25vk8+PuonHrebfT4+HqfIH16ctvsXDR8t//MhqR7zr9092njPnp6n+mSSOdxo/9UMn+G927L+/+hvsC860/zJdWT4I11t8zuMeR+evBv6U/HPc4h97+4hPf3P9/gtMf9H53dP1pMav8j/1E3iq+IMPzi88/ug/Y7/mn85f5XyhV/K1/MdPqYZlaK/6IQ3nFxi2T33A5/ytN/jR92vs/OCgr+o3rhuO9D+z9SO0V/56YzzkC9Vf047jKmnyf2F/6Q9/Qnudnw4/Z79H88fwW7DXTOsH/YNzPf+ZhfmQ5/+PX4V4nan+4To4exOf+GX+v+j5Xc/lR/P/3eVH44efU29VRZP/jvxVkz8J62mu/SeuG37X8z/6+0Ce9h/f0T/EWz5q8cct+exffdBe8/cZfVr5j3xo8j80/7l/IX/O1i3+uql/v5uGpBj6+1D9/uA44jO+2a6p/7jyfKb1Kz0O/O+cFyj7/7HzsEP7SnzyCfvVfxV/+OetrOf7Pv4qn//aP5+Bd83x54sg/7lq8plf6JOr/mM9MKz4se8TMH+j+cN4sH80f20+kX/+av/0NcifhfYj5Z9pOP9hRvxo/ywL57cnnPfwT/vHnGfyj/1m8TsF+TTwtf8374Xz4wvaa/xfA+6E/uajFj+sX7nq13kS+EvaK/7or0O8aPydoP+c+av9s3n4/W1OPZp7/sovjR/aq/44LGqcq361T91yXsqh9r85//mQ8dz4+Ud8KnfOfNH+V8b5+dSTn2W/lyB/jr6K30nwx5x69I/Pn/2nYpu/v0x5v37F+26av/y+cr7fP635/L40Z//ss+xP/XiE/XX//Jn1iPV3oPVj5/iHn99vfPw5H7X45Fvd/xi/H/hHyn/454j7lRv5n/7wn+pPrhv+4etXyu8ZLux9M5fP72PBufbPejfjGn/V7284P/GY/UrVT9d2Hmfga/+LRTEd2vtr2wb/kt+bqv5gPs1Yf3L5L8RHzn5W9PvZgcfPQuuHjYd8qee3/B7a9Jd8iw/iaab7J+Ipx16qn/LC8aHyJ+8/ok8UP+bPTmv+jtJ6Ph4q/+DP0sdb3//XONf9C59itPmk+ZNfWv0Vxq/1i+vg/Hc0fx0fyv5f7f2/bVP/orZHJJ/5ZeM/0frHfDwN41mIj33A+XOL/+TtYz720v2jjYf8rfuXOe/zsF9+Kvn484j28t9xUuP8r/MXiWP53+LzC/Gj+CeeF9hf9f+C+UQ90k2afPpbdJr8Jftf0fdzC8/HXflv5XgR3b8ktT1i+zMfuf/tSv8Hx9H4bT6E9TDX/udc+Fj2Q58z3r9S/cZ6YuuH6n+bT99a8r+7/2ay31Hh+kf+Vzwrf1t/6LNU/H4uapxr/5j5bfqfyX5Ll7/U+nPi9sx1/2HzAXym8f9yvFD9cEJ/xKvuP8ye7Dd2xWc+HWA/xT/xucReqh9MH/CZ7Pfi/l/q/oPx0V80frMH4z/Q+InnT8hX/H0pPP51/2DxfObxbvyd+3Op9f9LUuNc9bP198nlGb/j9g9lT61/4jjNqlp//AOO4v/DxxPJt+u9//i5np8vsZ/hclfzv0TY5R+YfwLuST7zC5wWTT54Kf8zHstnifPRx3Dq8m08abVr+C+h/5vQfuj8xbHbP0tc/qvjKP8cYM914I+lP/2DM40fexgeyf6MfxXwVPy1x380fu5/M/RX/j3F/pWP1/QnHrdW/zn/xOM/6cj+RY1z7b9bPCxCf3nl9kuEb5yf0H/l7U1/4mMe8Ce9/9APuEf7nfNtfEXAX+W/leOe9McfvWC/VPHziXgkn55LPvPrIuB+i2+4FN/eZ23xse8l45X9j93+6cr5hrHHpfRnfNfIV/xNfTxp2eKX3t74He9P9rP53A/6pIofswf6fHO+XQcPJP/ccWQ/62/X4tPfFe3d/9mQepb35yrnU5+mQd+s5/XfaB3q23XgD91+yT049Jcp/wyDPhnz9UHyjwP+GfCoxR/BH7X49Pfo/IzxbWiv8XN9HPrLCudbf/jvV4tf0l589BlXrq/xkY//nsQfufyJx5/tp06C/InWnz+8/7UN7f843/ZzWa8mLt8w+4GZ5g/7wYZ34pMfweLb/eSrvS/mfPbHwLn27zPs/xb4M9c/eQUH/XPZf1o6/qfxw+94+5gf+suLFn/m8qx+Bx8GPJf96X9G+7XzZ5Xj4xYfPC+afPrLupIPfxPwqfTn+ueAF+Kj3wL5it8FfObDmeTjj4OAdf+efHEc2R++4U8tPngp+8NfYv9j53O9F/RJtX6bPvAL2a/ruJe0+L2W/ujD/F2Kz/WCfKX5jz7w09z5Pfz7w+eL3b/03H895c+vQX6G/46a/JT14mvZ5M+rZvzB7924PPNf6C8denvT/8nnY0/5F/3Aqdb/XPyF5i/r93mxa/iP+TTlebfW/16Yz2mG/TT+ScDnyJP+58RTiLd01uKDL4om/wL77Zr8XtAn1frL9XQZ8Mr1T6fO7yt/oQ/Y2kf8ohk/Np5V0oyfoefDdKD83fV8NFL8Prg/Ld9F/G0zf2XE1wvyFH87x9H6Qf997Pnb+f2Z2+NS46ceWBGvmj8rxh/iMb1q8cGXVZN/WTXtZ3ziVet/n/i5CfhK/rt2HPGtv5tm/oFv+Er6Uw9d4W/lL8bTD/krvVX+Z31hPYn2b7kfuQryprr/5PlQP9g7vXO+Pc/gfuFa9RP7UeSDaP4f+f6V5Tvz39bjYaLxLzye+8r/l8Qj86nS+G/cntfiX2n9UPxYPt64vW3+Eg/vxJvyN/lwiv+lP/bJ4K81fuYz9ca58zPqZ57/9BU/hpkv94r/yvNhVP9UPp5o/Zs5TlX/5D3Hkf7485p4kf7Yl/wX8cmvqeab8f/6eKLxz4M9B0lz/KbP94BvNH9Zz4mHvuLP+uu08tfG7RHlL+4HrsuW/wuX/13+R/8V8sW/dDzQ/CeeB72m/c0fZYt/5/pHfPID/kyj9QN7Ui/fyH7klxvyldYv6sNBiLdU9ecA+1FPflP+pB78hr7if0Mf5G1bfPBt0eSDB9sWn/mm+nNA/iF/3il/cP0OvtYP06dyfSP+s7c3PtfvGK/8/62ocar8y/jSnbevn1+X4f3D3f59iWT//Hq7fx8jfVf+Shyvtf4++POsodbPp6rGqerP8f79w8DX/OV+eGfvHzqfetrwi/OH6E/99135n3r0LuCh6ofvRY2tfcT/7e0j/q37O+Zvmv43PvXQvexP/XlfNuWbPsS71g/zB/X2veQfi6/5f48+s5b+jKfr8W72e3T/Re8vTJBf+Hwx+fRHvTiW/syPh8Afqn6if5s/ks/82vMVv3/cn0Pdv97KfoqfgewZ2c/4VXP+gC1+tH7Rv+FbzV/mwwPxL/0tnshfHeWfkeMofs4dDxS/a+mv9W9IPvjZ4nd8PEPd/3zHnsg/0fjD88uU520P4u8cD/T9kdtw/zcI33vItH80CM/vMu4nIj79lUHeSPUL+WE08nxj/I7br5T9XhyPIv9VNc56kXzHyl8Z+/c73hdU/tw6Tj/ED89P07/N5+f2PP8H8mU/e57P+46qX3k/IKP+r/T8nv2/n4x/43zeRwJHz8/tefqbtzc+9ftPxqv59xN92D/R/t8oxGdGvf1YNPmPyD9u8QPO8hY/b9o/o/56DPLHWv8ey1qfTPtv1h/1f1k1+Rv8rfxfen+R/3gfISPeP7T/zPucxNNY8Y9/iMdU979j4oH1/5fGT/39K+g7Vvxt3J7WPuJfe/uYH/obr5t8+stUv4zD/MuoJ39L/pXjSL7ps/X2ER/5vyX/q/Mj+/1GPvqr/hnvnP8k/p3jcdXiEz8PLf5DS/6d42j8T4E/wX+qf8Zdx1vxHxyPt02+yS/Fxx7kr9+6f+B9osrel3R+xftAYf2I3x/i/oP14o/mD/XHnyB/Iv3/sJ8W1qtM9cdk5fo8FS0+4920+Jum/sbHH8+S/0d8jf8ZPvaO9t82jrct/nNZt6/rn4Crpv1Zj7J+c/5bfgMPNf9fkH9s9nP5+IP89SL/Uf+/tPSHP028fcSnXtwlTf5zy/7WH/Kj+q3reCf5b46nsyYfnD2LT/xQvz0r/7D+/UVf1U9/yYfMN9Uf08LlR+OHv0H+qsk3/QctPvXITvED/ou+qr/+lvV6mGn/Cv0y6r2yxX+lflL+oH/6y7R+DbFf6uM1/39yHOVP+h8lLfm8T8d69Cr5746j9ZP1gXjK5pq/+H/div8nn39TrR+/mP/MF91/WT5mPfslPvXoj6r21z7/U/+Pmvbn/TqLx20VxU+5zwcj2X+X+Pqr+ofrGfXfk+SPPJ9MxGd9HjP+cYu/buVf5qPZT/P3h+PIfpbPHt1ext8of0k+9rD5p/tH8mNWtfhTlz/W/YutB6um/oZZD3/K/2P3x1T57xV/on9X8cP8o/5+k3zuL97Qt9PiB/vlSYvf9fYRv0pqeXt+uD7rteSH6zn1TyX9vzh/NmvxZ97e+CH+cubPu/xP/+fwFf9vjvNBiz9o6d/1/qL943fkB5zL/rOQH3PqtQ/n50PHszZ/4+2NT3/UI//0/HHkeKb8/4H+XW8f8anXOkmT3ynq9hF/nrT0hz/19nX9HOyPvlo/PsL1eZi/uepPGw/1Y0fPnybuv7n89xGuzwuXZ/yt91clTf5hUbeP+fhf+68z4od67VD2p//PyFf84w+Tf9XiX3v7mI985W/iY675YvGDP6i3jhR/5O939N21+MSb9m9n5AN7fiT9c7fnTPn/CH2Yf6r/5tx/cV7YbXz+XBXet9qF96NafPQtm/yceuRb1eTT31zxd8R+PPf/Gr9dJ//q/j2/d/5i1OTbfNw2+Tn143vR5D+4vns+9++MV/mD64aPtX9g30Ow8+ucz/cQFvg/2v8ajWt8o/cn7fy7IG+h+MM+2DPV+cP2PYMXe3/S9X90fYaaP8e2fzmu7Q0f/QxLf+Pb/s2uyQfnG/HxB+ut7p/tOngk/U8c58sm3/BJ0eSznzSQ/2087B9q/8nmE/PxUOO/9Pidq36w+Zw059+cfHzRyh9Xnv8Wqh/oH5xr/3N+4/nnX4t/wnxbN/nk01zrN+tbTjzq+bHNb/L/LJr/RT3/822Tb8+vo+eHZ76eTY+b/Jx8q/tnW09ZvyqtvweOo/xJfiAf5Kp/F+Rf6ulT5Q/uP74w/7V+nxY1zl9bfPBp2eTT36Lb5C/x367Fp/7uJi35vL8k+32Bj/7avzV96O9MfO4/usg/bvGJt8MWH9yV/q/OXyp+vpQ1jp4f0X9+1Bo/fJ7HLRU/B2DGq/hflo4PZH/2Xz95+5jP/FX+Mky8fIrfnwsY/XX/f2DvswW8v6F2/oG3j/hJUYX3o5r8fYITn/XI9mPKquZ3HS9VP9l4DDf5hg+UP/b1OUrMXL69/xVwX3zsA04lHz54qfx5gH3WocFIfK4P4FfOxx9ZGP/+H+JvAx63+PSXSX7H9Y/GT3wuqub4wTn1eyb5uwi7fLPHLuCe5NN/FrDiN5kF/Mt+f+b773kgjNkvic6/q/4j2O9v86Jq8HPG0501+Ekn4IXLh58sA95E59cF3Eta/NBf2gu4EP844DntJX/p/L7yfx7Gn45CgwvxQ//2PkKvbPGrerwRn/6i9xdS4ukyNOiLv8J+dt6f69/Hfvx+KD5/z/X/HZ2/p/46LT6/d9Lvp63/65Z89GE/I12LXxDUs8b+kfG/hQaDpMl/4f5V6z/8Mb+n+eb2S28C4RZ/y/5X6IO9ty7/l/2etMk3++KPjcaPPQbyt81/ziPlPPM7xW/Hsc7PtO/R8P2agc4ftu+x8L0anf9r35dYhwZ/dP66fU+C71VWLn/H+e+cJ/vd5U9HjnX+vJ1Hznnq6bHzOc8bnEfff8WeA3vf1Pf/OX90GOw30/nVr5wnz3nCDy7fzsOmv5H7L+f7cz37/YTO/7bvMYcG+v3WSPbQ97fseybgsc6Pf7bv187Y3/HfH3KeP/X/SP7n/fJhwD29/2HnqfG+texn5ymWAQ81/y/cHpny55TzF8kHen/ezqNj/2no+c/O46O/yP6c72hYz084zyn5ERpcKX54fsN5Xpni78rOg5wl+/OC7PmbzoMa+fyz80xG5A+9P73mPAOe/+j8s+HInj/X7W24nI98ZN+fdvncX2YhX+SqH6y+/BUajOX/a68/M+Uf6usszNc0Oj975fV3dP/9yzHt6/jx+l33/0Z4ooH8D4H1Lyu1/iSOn5R/se+fgD/p/RPqg3GwR6b8Qf+G/yh+NgG/IE/5i/zCeRKZ7DdAP+TfiF/6eq71266DM81/8iM4yp/W30tz/U6Gqidkf/pbUk/uNP611yOqn4xv9ZfqzzHjZz3YON/8+xrwVPYnHsz/in/DXW9v/mf/iOcZU42f67Okaf9pGI/xK8mn/+emfDsP/Khsxi/n2dt5uO/Ot/wEPlL+/Or7H1H8WTxg7w/Jx35/A57I/sTXrHR70ZzredKMH7v+0Zw/9j0ivt+Uq376lTjuaP0iP4P1/SLL54Ogb3R+P+uTYY0/uXF7KP/v80mwZ/T9nSt7Hz40+On8PvUE+Xeo+c/3OGZJM//ZetRt5j/Lxw/N9cvyKziV/S7sPNVm/u/tf//dzP/783SrxvcryMeG711/+z7kb1v/ff+D/AQeaP17su+HN/PvuBrXWPk34/sD4Gj9Nj711qHkY3/wXPmb99/B0fljnEdm58GJTz62+Jlr/mwcR/FDfIGj/E09ZPl/4vzsm68H0flpv3WezqPLt+vHxL/zrT/OX8uVf7En8ym7UP1B/jyBr/w59nyWbzR/2T8gH/zW/OV+lPEsNP/IhwsaKH/YfAL/i+o/97/4KfG5CPEU6W/juXF9TX/6Y/wL5R/0mWF/yWd8xv8i/5WOZ9J/6/3lyj9cz8lnR863eALPFf/kA5Ov+pt4In4j+YbhLxQ/dn/K/af2P1L6R16m+jfx/Yzo/o/7wa79fsflsz8Cjt7fhW/4TPf/leOl9n/on/2T6P6R+0mTH90/ct2w5J/Z99dnSfz9iaXV57zvq/zF9x3AC83/E32Poav44ftKZ6z3qt/5/sqK84aVv/geHd/jSnX+wITvr/G9hKXyx6vj6Ptf9j0lvofwSfX3zHGl9Wvh37OZ6fsJfB+F8eTR9//4fhb1ur4/u/8eJd+L1fej/gT9e6FBrD/fv+J7F4Xm75G9P8388fwx13m4B4p/7u/5vVmh+H12nEXnj3MeBeuHzg+w87X5vehS+Yfz21Z2/rDb/6vjVOeHcD6nnee5dPl2vik4Or+V8wk5jzDV+U1z+/1DaHCq/TviuQj69BR/n8v6+Uca7Z+wHzho7f/zPOBraDDT/h376wO+/634X2x9/+6r8g/7oV+D/Re6fz6136OE8Q80f/X+vn7/s+8P/VU/nvnvh9Kh6tcZ9rT1U/dPVk9Ujf1P9jPAqfavLB9Q/19p/r/7/mlP+ZfnST3uP/T+Ps9TUp736fdn5g+zv9aPIujTC/kw2r/GPynrjexnfHBvHcVPtR9/ovc37To48r/tp/O+vvbP+D4I3wOI5p99D2Tj+cbsRz46LDeN/MP3JFJ+r6vvb1p/s+b3qzK+n1LZ98pdf77PBrZ8Y/qvNH6tfzzP4fujPe1f3tj7ayH+J1H9FPA04G86f5L3Z8+xt+pvvm/aC/k3nTuf76kafpT+nG9CPu2pfmI85INU+7f2fTnyn87ft/nN9w9z1Z/nST3/M31/mvxk9ojyz7Hnr+j7f4zPvid6pvEXPv4o//P9qnPiT/rf+XmmmfY/OB/X5kN0/i35hfkUxT/Xwan2L80f4HPt3xIPw9LzpcVvIPS6zfmDfy3/y/6WX8A98ZmP5JNIPs9H9vK1fvI+yYXtVzqf58PgKP/Z8+A7b7/f//D521f8nhc1Ts+dz/w2rPi17/FeFE35jMfkL6U/4yFfXch+L54/+6qfCx9P+lXyb1z+SvpPHPeV//EP2OLF+Fv3Z8Tn+qpsxo+NZ9SSH+qLdObtjc98WrXGfxvOQxqG82PSleJn67hU/hyZvkm4afL3p9mPtf2H6PcjIT4yfk89U/56C4QT3heLf39a7XGm319nwX/2Pmm0/8L9sb1/qvdHJtTDyazBz/V7xuj9l5/+PCl6/rN1HL2/OuF9rB/N50+2HlJ/9vX86qrw52eqX3kfLWW/+q/en+H9oEv2/7V+8nvClPjR+0P2e9Iri3eXz/PQS+JH87/g90fIu5b/4bNfdBnP/yqc9xqel0a/f/bn3/a+s9Wvie+/6P0bu87709Hz56H9/i7YX79/5/fwKfvvV8qf363+Ce11/1OG84v6YT3IUv1+Pry/bv1da/8jcdzX+mHvE1KvRPvfpeNrzX+eP4L73SYfHL9/uOL8Oezn8tPDIB881PlV38P5R8wHa2/yeX+N/m58/PY+5w31u+qvnb3/EPyv/RPmkz2/3Cr+8S/8gfIPzzMM36p+CvVH9uLyjE9+IH5SzX+eT/E8JNX9O883DF9G+Tdc/sZ6wZkp+/wb/BXOe0u1/zcrfP6d6/dzhfcX/X72Ifif/iL79WYe/1fyH/FAPPWV/8qijp9I/pTfY7B/FNmf+vUSvu6/yGeDsN6lv6L8m9T4Rv5fezwPdP9NPA6CvVM9/0G/lP2Db7If+/m3SdN/6AeO/G/x8ODt9/tvPp/7ql+wD+NJ9fyK+ZWyn3Wt+hX7XBEvyj/E84D8o/3HfuH4Uvw7H0/Ev3J7ptp/YT6Z/yL9H3w+9mU/Gw/1yzaqHx1fif/ouK/6+9L9Ec1/8qvp/03rH/H1jfaq/7kOTrX/z/gM3yp/8ajzb1B1oPzFo1LDttUJP2y1ZCx9t/L/X8fpca/md0KoDIiXv6p/wtJtuEOpjbiLcO2gqNvv79/DtQHx0E+dH6Zaynp7p/y/Ctfob6D898G1VTjERPvns2CqlP3f99Lls3W6Jv+p/voI/Q2pP7R/NguhlvNoYi35bDWuw/inLE00fwpDGRJv2r8ch60Uw981/x/CNfB41ORPQmmaav+bR6cp+/9fq1r/DPttwniGip8N8nn+PHX/jbE/+1/3ql+64c976o2Oy1+Ga0Pmm/b/8mDKlHi4V/49ALN/Kv8t0Qf/S37O1uGZtzf+ffCvxVPl8ZMXoagP8y//4vykw6GJof2D5M8dD5X/iOch8+3Z9R8F/c0eD9r/nTkeaP09wH7svyfOX4ZHSYYPPH6zc/dfZP8l8cP80/7jvOfxfxftP6Z1PA+1fhGfxGOq5y89+T+yP/Yog/+Gyp8c2jiw+kPjD/qnOEHjz0/CtZJ8Kf/ZeEK+yLT/ObxxXGr+f3Ycjd/iweon8XeOfyj/fnEcxQ/xMPwfY1+ypLzOLPgqN/4tHYEZDKYj7kKeZ1uADWbTARgMmMGAwUBHv3tLqUKq+qIXvTnny7IyJaVSOSkllL/jB33E9qOYP5Nn6N8R+jfnMJsv6x/WYwD9ifHLHHZE/L+i43FAfz9F/yAPEK/thf5m60lhR+jfLeBfYP+J/sGeQD5wL8YP8fUe+hfrD/rEafh4GX7A5eEg+ofzzQP+2z8bD8QPIv8A68n0SSH6h/GA/DhCfmA/AayJ/AfoAy34h3+QHz6A/3Pn+gOUmgPyI+JP0M8a/qu/GX+Bn+6v+UP9yz/yz/YD6PNS4L847Ar9veYwGy/DB30I+cCDwO9z2Bb2A+yBS/mtifgb9qcK57Wl0B9IrJ/QP7C/GP9+yW+fz/8Xvsf7/yW/IB8u/is/TJ5g/EcRP4DROOK//NtzedRmAr/g8FH4jwZfT1fs3x3MH9qL+j3YHxr46yfRP8sH4b/zB36w8Qv/jY3np/6K47scdsX82XgM3h/DX/P1LMX4YXwnFm8LfOAHxO/Cf2LyCEb6jP7in6G90P9A36X2XxPnp2w8AB/F+oE+zIFfon/YXx7sP5H/cYAe+IsX0f+Ey4Mn5Bfk2TP+6R/oQfx9EfzDHHaF/w36kPUv4h8n4PBO4E85/q/+QZ+4sF4i/gL5ZPi/5A/Wp+LywvCBPy7Iu4hfmDwd/+F/xvE94X8fYTzQn/BfXQH/kt8Zlx9PyA/II5M/4X+z+QB8FfgLDrvC/4X18WC/3Tg+4yfgX8T6g/99BX4Xf/FBHjThf7gJH/9NzD/lsCfyZ2w+MF4Rf7D5AP+vAn8n+C/09wXqGaS//GfyBPHYTcx/L/oX+/fM1+PX/vGgf9B/lcAvOT1P9A/j82D+Iv4C/jB+3gT/QJ/fKb4v5n+nCD7Iq6jf8BHv//4vfvFXfu5i/KL+hskTjKcW/AP+1qz+g+NXkA+H+Qr/Hb5r3X/W78zxfSF/IE9s/sJ/94H/4L/UYv/B/GqIH4T8MH4Av97/4Mu8/W98GK+w/7A+/uWf9Us4vYfo/y7whf64Cf6L+I3JE4z/JvBhPR/Nd74/82/4/hH+L+MHwE/BvyeHfeF/PWD80J84/4f5Mf7XQv6AH08Yv/IPPsy39Q8+nJ88BX6Hy4Mv5JfByj/4IA/g7zyF/wznqQ1tEIn372VWP0HfGxf2P4L3pwFu+PzZe64N8FPU/7P3vOG92F/npwWHG+H/d+H9fXivXPAvLL7wr/4R3H8Ae/cS+Ow9WHZfkuPrcH8G5FnUXyO4T8bq70X9ATvPhfpZIb8qx9fF+Sm8L6v/1P/x80Og96LrEQj5hfEB/Bt/zfE1kT+EUOcN7YX9hlCSwSJ/y0IlzNszfLhf+mHrIc4v2f0BuD8k+nc4/BHxs87xg/6v/u9f+Nf7GXAeBfZaEufXMYdDof8+zRfWRf08w2fnzcj4gw9wKPw/E35/ic5XF+cfasJhU/x+Exb0FPH7BRRBBfkV5y+MPrw3KvDRjMId2iAU/oMB96dAnkT+XYXzcYPdH+P8g/rDDsw3+Qcf5Ef4fyrk78FedgX/gT7Av97fHdGfOojp713owv+M1xxuFd/fz0Dw+0JdOp5Q7B8DUhHwexci/8n4CXBX5H8a+vsHPdj/Ev/9DIX+PkeMaX9r0T/8/gno457A7wM+zF/Y3xbgX2j77T/44A+2MR8/1B/32XqJ+wP8/WF9J8a/5nBf6J8R7b8P9QsNHz/QD6F+XuRvGT+esBP472eQNcE/cCj2H7yPHIE9EeevMD4d/KW+0J/wU1+QhAB+/ehP2n9E5UEX/ksE6wn2Wsb/4NP1joT9BTi+0/bCf4zWHJaF/K1YPQPlnzj/gveRYfy68B8ZvTftbyD6H3I4Ev5jC8ZD4V/9hwjkAdqL+WMOBwqf/xj0N4VVm+svg/6elQ72uqF/Y/GrQ7+PqbxGIn/ypv+JwH4u0bf/gB4K6BYFh2L8G4ChfkbYzx5tGkoUFP5T2Kfwk8nPt39GT2Hy/0t/U35RfaD/yr9m9LMJ7UX+uaaTViB+IRH2D75Pf48kBv7/qj+mv5/HkpRK8xf/QyJ2lnT76Z/yJwb5Ef5jkNDPwI9ew8dvcjhO/uIHmLdn8U9j03hFbeh5KfcfAg47Eh8/jCe429/x/ugfPp+W2H/g3xybNY03Of4I6oeoPdXlf/Bl3v4Xflms//AP8AH+xb9QoZ8hn9QS8rdFX/jX/IEfEeLtWfyxtr/9T/jvv6kW5f+e/v6ZIX6/rA37GfK3nvrd/zE7/2P6i/cP/lSb1Rv8xfcpP3VR/wf4sGNQu/iL/6bz9wX/AZ/Rg/bMf+tzek/85Z/WouN7UNgUv//4LL7wr/7pDqbv5yJav/GdP6PPYCP84lMLymBd+I/Wnf7+lknxV4jz7wa/T1JIND/B+19Sehb8Hp3Gx8++A7wTv79nU/wfmPe/a76wFvPfP3Ho738hg+KrWPriw3eADYX3f+D4rD2bf0JhVcwX5m8CPT7fr/+R0U1MdYOv8vrFO4XnFDYLqgtAiVmA30g0/tNpPAOqGHiYUXoO/a7BeNcwHvpFpfzyIXXlwXeK/4segxuO/2O/af8BnW+7SL7jn6pQD57R+l8hP3R/aTBeJH5/k+5/ZNP2Om3/Ez9R+bFRRlOr1hf/Rvc/Uii85vNHII8mhdXii8/oQ/8o4fj0hBZpBoXVX/gW3e8q2Nsvvtqi+DnIk8T5v6XyYNPfc1IVPn6b/v4nCik/NpjLDyt6ofxECseHRwUB1ob8/A1+VE17ivbQ/4jS39D+VCT6x19YE/yzM9r/mPa/EPqjC+On8qQ6HD8vODzm62dQo4qmFDYR7x/WE2A14fhTyg+AVZ/3D/jwI3Tkn3/xp3S8ltA/Tzp/FeRvLvQHPKoP/LB4/xo4zSbIr2T8xS8o/kzsX6o/0QL2z6/9S+WnoPpGLfn4LSrv6oWOP+LjZ99XFN/i/Gf0bJj//S++A/YkF/IP+Dlvz+Z/An5Af32OD+sDsHrk/VvUKVMPFLYF/0oO/+LfjZ7f+fT8VXtw+dHoeNh6uIjrX43Of0dhVchvSdfDBXoFH79rcNgR+mtM6QGsOX/xQX7Unvj9W8Df63Bfk+PTojBi2iWaH+Lrd0WgdCi9A+/fg6DnSGEX/cW/0vlqQv5cSl9bc36z+VN50gw6X4/joxP97mHe/hc+yM/1Lz6jt+P8+8GH9kJ+YD01kIe7WH+Dw7aQnzHnhybkB/aHCvqg/qU/OewL/CmHVfwXn8nDVuwf2B+wn8aI698nha8Fppgc36f4Ooy3FPOH8TQUDvj6/+BT/nsX4w8+W7/jP/hH3p7hv4Ee9CfGHxRcnjocXxdwwOWf4XvNX/kDfEbvJvBh/XoUjsT6dwGm89EvHD8EfFh/+R/8AYVD0X8F+M1f+QF5YvhDMf+Sy9Ov/ktIlSJw1YX8cVid8v1rONRXHulwX4Pvf43aozFOqKvL8TG1rzroj7PKx69w+QtF/20d7lNQ/0P4D3HDYSG/DF/i7X/6Bxjm3//VP4XpeFThvxigD0ze/hf+mLY3kn/w+3/ln+EbvP1P/gzmD+MtOL5O529Qfqu28J/6lH8hbT/Bf/EnMB/F/OLD+ujrv+unC30wEf33OayL/Q/yadw5vxg+3b9qAO2F/HzAHoH/1/zF18F+hkJ+mD1i/h/Hh/GAPjME/0EfGQr4y//gj/8ZP+AnFN90/uIDrAr7D/tDnf4j/wO+f0yxf6PiC/8aP8MHOBHrnwh8sf4pjCfj/AJ8Ri+lcFr8xZ/C/IX8M3pr3p71D/IA/moq+kd8PxhC/2IOq5mQP4g/wN7Pir/4MxjvP/gmzFf9Bx/8hxmXP3VN4TmMV6zfHPBL3p7NH/TB9v+FD/vBVP7Bh/1f/IO/+7t/GH5G21vGP/gwf2E/jUzgi/4tZk/+9g/yZYH8CPttCPnLRP+wHlnzXa8f/Oa7H1Rhf9h6lJzfTP5gPzt8v//Ij1h/YX9AvtTTP/ID8rGg7a2M4wN/YT7qkuMz/hTUf3B4/M/4AfzTRPyfgf0P7K++Y/sP6t+gNDIW+hPkawH8F/OfcfjX+gN9tp4aj5/VGfPnaXuh/1IOq5WYf8b5NxX9A/4S5n/5B//yl/9WwtdzKfYP8HcF4xX7byH4f/gHv+bj/YUP9Kz+X3yAVWF/mDyBv7EW4wd/MoH2Qv5Avmz0T/+gP17Q/y//GfqH9r/kH3P5Pwv+gT0Df2Muxp9zerbQnyAPNuh7of8tGM8Gxi/6h/XMYT4llx9YX5uOV/O4/WfyAOPPxf47c/hX/3u6H2zwd3Nu/50LsW+aS+Gc90/of2FbyL9D/UMb5GmnCvkz6f6l8EbwH/yjDfBP6L8N/sJazMdvgz5TePtf+Iz/zT/41N9Xhf8N+Br9EWLSP/6Df6AJWRdx/3NdcP5vBD7ID/iPW8E/WM8c8I1/8GG9e2L8FF8bw4/wCf5ZKvAb/6zXT/4H4IC3Z/zPjK88/Fr/Fpd/W8jvtvjCmsif2XQ/aGBPNv/gb/7ZP4DvIN5e4KuPf/bvna/Hr/3L9jO0F/6P1XD41/qB/d/+s/8L6B/433B8x+HwTsRvGoed5B980Bftf/DBny+av/hbmP/9F/8pPt0vWvSL/xwGeflZPy4/jvEPvvGX/wwf4J3gH8gHyJMj9C/IE8BqX8gPhv1H8feCfxLdTyXdb46wXznAoH87Yv/S+m7Np/gKl382HxiPI+bP6NH1Yv2x+JvuXw38r4PgP6b0L9BerN+EpnqhnktlTyUAPtRfQ77qIOJ3uLoBsCvqrw+sHiz8g+/81B8Cvzk+ew+N8s8V8SfgQz2YJvxPGJ82oXAp8GE+5yah+XuBD/Rg/wX/4Bfqtz3DP1H4RmFvzf3/I039O7DfEsE/Oj8GV7x+XYPzyCP0J+QH6uFcOP8R/qcn8I+Cf1DKB7BXcv6dRf2IyH8xegCfxPrBeSbArpAfVk8H+lL07xt0/cGfufP4X3vR+V9p/OgK+19Bqp/C2pOvn0ePUjXwRzQxfihVutKjHzf7iw+wJvwXNh/wN49i/eB8A+qHXKH/GQzrtRb4P/WAdP1E/onV09AGrtB/D3Z+Qdv/yn8UHD6L8UP9Kav/EednFzofj/77V/0/3CfQoFT7zNeffb9Q/nvGr/3b/MDa9h98KP2/iPWD+uML7B+h/6E+htW/CP+FzQfgixg/O0+B/oT9gfoYgH/hs3o48Fev4vwM6uMulJ+e0L9XVs9H8X/VD8H6HZn88/7h/IfVHwn/lY0H9K/wH33Yz+B/VyJ+BPmE/LGWcP/HxBwu+fkVyy8DPOHnH1pK4SvIf8bxj9R/Mmi+VLv88h+dbz41E+cnYE8MkW9i8a/IRwn/06TrqYL+WQn9f+D+qCPOfyCeYfZP5J+8xITzCqpvMN9/W/W7H3/pL1YPBPIu/HeoT2LwS5zfeuz9Tfp+odi/Gvs9DAL/rp+B97TBn7qK8cN5Gjv/E+dv7HwG8v0ifw/nIez8oyX0B+TjdchXCvtnwfkNXT9V5+NX7xy2Cp5/vlJ8KGL5lX9cgD4G++Vw+2eBfgZ/5yb8T/CH9+BvC/ldc/9RE+dP4N8zf/KX/wj3l2b0356wfymHtYdYf1qqw+BU3D8B/zoH/X3n9gP8MeY/gP8LPoAH/hz4P3c6Ph/WG87Tbs0X1iAfVMP8aMcaxDs1tM84/i964E/WgC/mz+qR4Pxe3B+A3wPX4f63qP/RJXpU86D9haJ+YURTxxHoqz6fPztPh/PkEfris/MROA+xHS4/sJ5QBIWE/2dC/AtXG29Cf0Op/53qU7fP7d+J5tdhP2si/+oWHH4I/QP1AADHov4kwRC/0HhFjB+VvH7tKvBBVWniPFNn6xH8wFrD7R+c57Hzu4fYPzKdP8D2RZwfgz8t4h02fnr/U4d6Tqv51u+w+hCAXXqm+LN/4D19qD8Q9UMhrW/Sb6ze6Vt/pIWi/kHEj2DPvYLbe+b/gD86EvEjyBeM7wnyBf5Om8uXT/efDv5uA98lLq9PKi8+lT8d/O+m+UsP4ABzfKAXUPnUwd9+wfeC03tR+gHllw75oFfxpadD/uRN+wtAnwX/0AP4w/ER1JN8uDwwefnQ/kLE+4PvIexPV9STQH+QX5VgP9D9qE9Ff30Od9AXH8EZdYf2H9L9qc/Z/Bq6fhRecPwQxgvr0W2+7dl4GD7MH/ydHl8fPeVw2Of4jB7wH/IHffo9cvh4es0X1sE+yXS8EfR/+gcf8gcD+I7+wYf5gL0ZUH5Fd94e8COQD8jnDOG7wvk/pPRidogB8QqMT8gPfIf2OsTfCpcf/c5hqGdi9UtMHiGePXP/wzc4vTvi+rEU/gXQA/04An6CfDh8/DH4R2+uj+OE0xuB/gX5BPkaFf/Qg/4Djg82Kgb/x+f+cQzrL4v+1hxuwfc759eIjjcGfsL+1KH/uxhP822vg/1rc/ugDzk9iP80W/Qn4ALWo8/7awN/oMJI1akrVNCKsiD69se+U5jpzw3Ye6jf+tEPtH1C21uADzDm36G9Tf0dZNDvwB+0jr726g70C4rvwnf0/c5ghPvf8cF41YbClwj4W3ztHeb8Yd8RH49WfMejAT9PEJ/R9dBaQr9RedQhP1KK+Ano6TAfiY63y+0vq28JKH2mj2C9QzH+hrbvcHuM+tFfehTWfa7PGL2Y4hv0e0D9N93l40NK9NXHTzjfRYIenS/Tl2CPDNz/S4/CgfNXn6sOxZ/S76DPA6EPDcovE+63wn1ao+H0JtAeffU5Svh8GT2Abyzfq3/Xy4T+QZ5hvialr675+OE7gzOKb8H4qXyReIDC0P4efef3EfxKeXuV8hstxXhKTu9K/VcPzvugP2gPsFZTWbQR7y+n7W3oj/IbFTq8R8rnn3PYAHmeCX5S+WAw1KNoDpdXm7Zn8EGHUgpKv8+/u8CfgNtPl/avCf7AdwZv+fjYeI8U9ig9jc5XN/7aX/Yd2muY4l84fzTYPzcK+4Av8f48aA/jewJ9sf5XaE/Ho4P8vYBewekBHFB8HfSHBO35/kMPCoe0Pz3h9GE8OoyvC98b/h34w9pTevqE22M94+ON4DusN/welwH3GaC/Ph+vBvIhi/5A38Dvn1jwXtrlH3oANxyf0YPxQf8B2LeeoAfyCfUzexpvhsIeRXQ+IS110h4I7pesv/SGQA/sOewn5S89Bis09ApZqRQMAvwVqAeHfE9X2DfwB3pgf+G+wobbS52urw7nEz3gn9BHMawnwG3aH+b6G40Apt+Zv5FzeQd6KoLvdH0Ng9MDfJ3uHxLfFfQ88EuPtQfYoOurany+BhbtgZ6Qf9aewqoD3/l6qGAfxpS/BpUH1RP0Sg4zf0jotwns37ug1/yl1wd/BPxjn9Nj/hicz03peMKG0+vD+STwI6Ltp5we87f6sB4Qbwr7EEE+APRzQulFwn4BvgHrAe8BJWK+rD2FTapPVMzpmbA/wJ+T2fk7519C6QGsQ7w6BPtF9YcK+j8FepR/zL+Ti7/foX0M45/z9mx+T+7vwX0NIn9feWP+3JLJJz3kFPHtAM536f7TIR8jC/mF/Ag8MmGs6Xs/meAX+DsQr89o/6y+/sfe03gb/MENjx+Z/IK/A/WqLP9WCH+I+ncsf3UR/iDzr/DXn/zJT3F7r4J9gXw7+Ff6gNMzqb7QwT+C/K0r1nNG5RlgDeIJlq8X9Jj/B/LV5/6jCfK5pt/nsD5UHtQt95/Yd7BPGf1uObw9G8+dt89AnkR8NeMwq4fJxP4s2H6QvvUyO96fRfe3Wgr/EOA97499B38Fzt8tzPX3HPwJ2B9gj3bsfJ3LJ3wHWD3T70sxng2HrUDMnyIhh48H+tMMbt9hfAB/431O78T7d+D898znF8P5XgX9Ufw44/4+kxfwDyGebUM8fxf+Mf7CbH5LsV/Bvrb5+Zsq/C/WHmDGj4TTW2DOr+s/9MD/mAM/Gv6drQ+VP/UO/i79DvGI3hX+Y8G/M3yH96cJGPx/Tdg70FcX2F8gv7/ogT0B+YH8sxeI+B3ieYi/tvw7298Q779hf/T5d+Y/UX9CA/sC+Xjwf3/8UZgPtAf9exb+N+gnOD+C8yLmvzN6IC/gv05w8HP+9BM/wH4Bfx7i9xXIs5BHlc2f4sN5256PH5m0P4DhfE6thfwDPZB/OE+D8ybWn0blzwJ7CP6ETvvzRf28JuIZiFdWwl/yOWzD/hL+ktXn4y9ZvQIf/5qOH/LHWkPHv+b0VPDPALbRX3o2XX/W/sTOywU9aA/8BH9uzf1lNp8c/NmMxzO6GP+Mf2f4HeGfZxy20N94IMff9ixfdYW+YPzQHmCP1i8w/x7k3wZ64I9toL+SwV95gO8sfwz5YvtXfzC/Ncv/0PUW/QG9G/OX6HoPRH/gjwDsoG+8oPaFf434d6jP1EW+A9oDrJrs/gD351cwfioPNvirYwp/hLyvRDwE+38k+Hnn8BbmI/TTlsdHLN65ifmN2PySn3y12hLyAPJ14/lsWxH0gD7MV+HjZfTAf2TtoT5F+NusPcAF4vOD/bGlsAPxBOjnBuJbIc8QD8F3hr8R/umJwyxeO/P+HIqvgX/J7uMI/6Og/HBAviAfUYj8wE/+Q/q576OZ/9AzGb0vPsuPFXT+DuQzHKbvoUAt/NJn+NAf7O89/rZn49nBfFi8APkZMR6L2SvYr3Q8wr91QJ4B3kP/JafH6N+ZP4KoPuL0wL8F2KH2QLO5PDsNbw/3/+C+H5sP6w/8NXhvAO6LxX3ufx2gP+AX3N84iPGD/QCYxV83QQ/0ZczGX/zg/6Kn3Xl8eODyxdqXEA/Q+20anEcxegpvH4L+E/kRaO/C+oG/ieG8D+hh3l6H9Rvz8bngX8wo/RTuP8LvYTB64B8AnLD3y/n4Jny+DtxvmfHxAT0Wf0K87Yj4C+JdiCdZfroU9GA8D8hXwfnHhfuHWsD0f0Hff6HzA/+hFPoH5HPP9CvVH4rQP8BPgMEfLQV/p8w+QX+UfsLlw6X2UAP//wT9UXnTUsEv+A76/gT+rpDvI6XvUvumrTg+03fgb52BHuQfoL+XyO/Ad5bfwH/700T/J1hvoU8YDPIN/iPcT3CF/mLfFeZvfPtn89/y9nD+qBViftAe4Avm44X+zpBPAvmC+AryX6qIvy6UHx7II+S/U+7/a7A+N/CfjOhPfx7IC/ibcL7o9cM/9NijAnAfIBbng5BfqiCehPOiA4/HPIgPAYb75p7wNy90fTzwf94c/zc9mB/sj5MYH2bzKWhX3/4YPcDXYfwsHyToHVl8TTcNvJ8i8lEwHgZfeX+MvxWMD/yjD9Ar+Hh/fQd5uDF7xtuz/AvYS/i9yQW/X87kC+wXnN94Eot/v/zSGw4r9H2COOD5lxulF4J/Dfmom9g/kN8C2Ad/9iXmB/a05v2Fwl8Gej6sP/D/JvY/4N+ZPx9BvvxLj7UHuKbtfeHP32E94L47jP8XvTdvz+7zX8V5Cuwv4G/N/FNOr0ZfWOtzfEYP/LEHy19QekdBD9p3mf6i+GI96uYLa0OOz+gB/Qd8h/MSKIKC/CJrD/rzCeOR2Hpjmg//6hMN/C2A4f0Hdl79EPkYOI97gr6F/cF+r4x+CtfsfLL4ef8B3qvQ2pzf7PuMn9cFwr6w8zs4n4L6nkacf6hCHsEezzl/AoPzG9bXazi9BvJtcL8c3tNqir/0APYzjs/o0fVn7T/w/s4vetC+4fyrhX0G+Yf2AbzPJvxJ4K8O77t94P0kcf4U8P2ogb2VeHykXfl8mfyL+MLv8/WC8/ZAxBewXgDrkB8dwnsaQA/437D+KP8dIV9UH+sdaE/35y96Lzg/ofpEP/P3gBj/wB/DkF8GfOHfBZAfgwPzBt6/yf6hB/GFxfG/8WzxbY+ZPHF6EA8BPIF85i96IH/wHi3LF4p8ms1hli/8lc8EfQTv2zXsfR9Oj+Uj4TwL8ncNP79Wf86n+j/5XXaezMYH/hy8XyTT39cIhD14c/6xfHAs5A/8xxDqFeA9Gl/IM5w/AAzv+UC9yQ89ka8cC3xBT+Lv66gTPl9or08YPYov9lvCzsci0Df45zybnUd6TB6bn/dvVPAnZJG/A5i97wPr9RD8uDN5L37y3YbQp+/mC6smi8c4PyA+H4B9oO+1MPxf9MD/HbD3R7j9APyArQf6fmf0oD3ktw1Yn0isv8HHB+/DhMIf+BTf9ixf/RHyGXEY3i9h/bHxKbw9nPebQp6gPcDsvZOPGB/kXwdwXgHx2EKsF6w/+NM9CtPRffONoM8Q6C/636HYjyCvKehr9vuwgh7sN/DvhlQ+IhFvsHw1tS/sPYxhw+Ud/FOoL4jh97kGXD4hf83qD0YQv9w5PUXUJ8D7JCPMx/dm+UxaOgby/hH5QKingHpfeG9Hc1ROD+4/wvv9K0pmyOkx/0bCX3ugVcI/gPWG+h54PymE+Penfo/6r3eeH2b1Q3CeD/aoJe4/HdTmp57u1/3JMbu//rf+zgD/40jb/7o/DPvBpedXv+4PL/h9AFXUT7L8KfBzAfIG9U8AQz2ktebjX7D8F8MvfvAZDP4Ty/cCPnxPoL+A4wNs/tzf4fiQT4L68Ymo/wMY7kOqiNffJfw+pyrq/4Aegnp3ndd/qzGcF1D4Fz7QY/cpfV5/yOALb8/4BzC7Dy7q/9h9iJ984RefwdB+Je6fQD50zO8L/qwfnCdLzN/8zt/AHP51/xDyZRI7j+P4EjvPpu2nHD8E/QbjEe8HMHpS8xefvSdA4+1f+PCdwT7nP4OhnvbX+wVAj8G/7m8FvP5W3H9n90FDOL8S9bMhf09AT3j/cB+Wwb/uj/7UY1F9kwj5Af8M4B7vP4T4BeqfDTF+oOdA/a+YP9CD9zP0VPAP6GHmX3L8lPmvtL+M998B/Zf97Z+9z7Fj9TjFV36AHrzf4Yv7G6GgJ+7fAKwB3OH7T4f4G+Bf9887BYcFPqMf/sX/GQ/Ndzji/Qj2ngO7PyTqfwGGeuFCvF8C8BbyOaJ+2IXxgz4Q90cZDP2L9y900N/s/QxRfwuwDe9dfMT7Gw0ffy74B/7NGuTv1/sbUI8J7yGJ+keA1TevV/2pP+XnC67g31nUC/26fwHnhwuWr+H4C1E/JOTnwM7TaD2NuP8C90u0J9y34O/faFdx/6TP9Qe8z6Cueb6Y7T+oP5mzehrOvyf1dzVaLxqL329V4PfJ4D2+RPz+jMHzm0vx/suL8gOcBEfsHwT1yxl/r+jn/pPzza+qQv/Co3UTwL9w/D3zTyBfx/dPQO2RDvcdRP0we5+L5RfF+6fwPpdB84O/399iv6fA/Gsufw7kH1n/XP4g3+fBeach3p+h41E99l7WV/5Z/g3qP32hfyEf5inGN7/1c/8H4htqu2/0fh/Dn7F8Dv7Jd/3UL0O+Au5rdfj9L5YPA/gk+of8WEXxNaH/4DvALJ/1Y/95fuuE/uLX8P6GeD/lXHzx0YuvH4OhPlK836HDpa0O+McFHz/zR8A/Gf/Sf8E3nu3y/vWM6Z/mx7/54vP4V+AHEN+6DJ/3DzDcZ/DE/aU3h3Vx/z5a8/yFeD/wB4b3/0T9N9SzQz7g9/uPCX/PsSveP4P3KFn8f+Hv/8EjWDr8XlP0y/7QpeuJ+gzQPxo8NYS+8RHDB5i9f2rx9wNZfQ74821ev838c/C3I/F+owT5CZBEKApn/EesPfAPffHBf4b3A0Mocgd88MeZf51zfHhfkPnHffjjf//3f/7P//iv/6y6vWEu591BT9l2FGkkd/LBqrcdDeTBoK9sN/+rp0id/D//87/+9392y/uO/OP/F4UQr9/VhmKYx8uyHvTR7bZ8078/65L+mfxPX9ZL/uf15VxvzjX9dI5Oct/K63Wp950ByieDxQbr7m09kOzVdIFSOTrfvKUykzRpMIsWrfkywIb1epwvA1q63NhZk10UtyhRvcwXh6H+WmJv7GieusfJERUpuqSz5jM3VLMIo6Hl7l44NvPhIN5u7R2yunJ3dpLeB0kbvcz9Se+1YqwWXqDsLn1HRtepbPn9MiHf57Kj5r3pI8bOdBs7TwP3R/Tni2QJy4+DhM52mBra4R1jL+8p877iXkbInbzNU3fdJ/j7XFFOKyuKMbL8dIiNhOCHt2iGaq+XlSjczXHuj8YvHBk3c9nKJ06KynieDPbPzjLRr1Utlwuc2ziYKd0gaZkzE1WrbTnPq1aWaPX7PNks2p09dld62fc/5bxCj31dVJ3ufSMh/bxVSPS8GOJ41p47j+6UjM/PV/7k2t+S8Q3xe+SsuvsYR5/WfazW2BkRGbr3FWt0Pkj6rWPU2sag39fFua6vb4K/WQXW8H0fkfmfJoNe7y0tY6w9t8HL2U2yEWo/Dscm3z4OJdr1xqdedjxF2Br64X6x1NwFelsd80Yiq12JLF3fmPsbMZX+y1dGO3SSQzSbt5txFdnnRD+WpSJ91NYKG88mJjx2ZBeVyaJQW6frLtHf8m4uZf38g4P53ZJk+70wkebZ4WNUT8tSPWmD3mfsk60aO6u1tz4ZlYnStvJ67s7F2lDTWaX2TvZ1iWPpHnWP0VWW0WbhSp/11D0aWhcHr2f/+F7jIGhNBkSGLmM02sTHc6+lElMvjVqPqhVoM2x+LOUYqdEiR61p05kuh/kpQS+z2krZuFKw3rkZu/UUV0cSKSjH7ITiXakn+TvK2p/NGFvnjt0KfD1LkX3oLTwSSWwS7TgdPC8rZdTH6mpVec44OLtoaZqG93mVO0ktu49OVeMNxkHX7Lbuj1b/he63tRzV4ftgoHyrbo7FbZDhYHO49R7dA5G/87IXGvYuP0iq3bsEu7M5IPKZmETNDhZkfbfTcDi4+s+NpPvpxm8cy8M4XKrPPG6lWYXufv9k6I9DXhL+HWatziyysJpebEd5aA7hT4nf8cBPD6V68U1VVY1WhMOzNZjO51JfRuG47jzvZ+2QoHftzt/qehDgeHoOD82l5biodRpU0Uwh8qnPu8Gtkc1ZiM1afm/bhpON0aqYZAPHvWxL7ZKjRx+V2gLHo6Ydz85D94XMdyl/tNfskGi3aZTL272GsVXesDa7WE6FNGuOn52nVhqaGQzkhydFLg6q1SK2dz3iKjyHl2viPpqdpNnSfvd4HR8+tvJH7oz35aWD5FW/GWnxdS8hZXWM5umrNcFGO34MDXx0TSSjbX/7UTSyvwJ0iNKXP/Gw0fPb+9bolnVQWrzmxPtd7Ax1mLQ++iLZhNhOP8pqXYd9F9nD3XN2TZLSQNVyhf2eM8HY8FZ5O1/dshyN+v2lobgl+T7Szp/ravpOcbzfdOV53JJT4nMOV+usPybya0bDd7AYTCZY1ar7AKd3Mj5pZemT60suSy0eyq+eisn4TUlZH6/RpgrRvj4T5fW0SkNvBbiw7fMyIfJZr+zBslOlaGMsu9NirR4N1Fdf5SSZvBMcjEdyuLrrC6K/ptGlnBsXIl+xVg6z2WoTYXWRWpf3PST6JWmG6idwZLK+qjXyLo07qnCYPF8tS/N7C+IkzyInTMj6o/5Ek+TLi+hn5/XZl+OelMloOtFXg8h5EfzYMdrrzceKsb/bxseTGhD6ZuSv1O10TvTPPhtMw9HrSr7bES6bT0y++x11kgXGh6xP3OqsbpVad3Cs5KPHeu71VTRo5eF4c7ssJTTYOHZt9XIJq+ZpK6WHev5C0WK7vz7c8d5A++l+u9Aeexu7yqb7cdCjp6K3sRs3981tV6of1a9Q0SUbyP8sT+9jpDsd5H16Zd6dILK/5f6g6G0PnR6R38VJu470uYnm02wgK+s70S+BhnZqcdsjrOmpJpdWf64i9SDjh1Fgot8P7WixGIdvE1vzuspbydZZoJbUeUurm7kukTk76531YdzFYYFmr3EQ90y09z/HwWUjk/2TnNtH1dnVbRyutWA1chs7Rc/zY2xdpkS/oCRbx1NLGtjY9/TJ8XM+EXz/1YtSCbfXxL4s+niSZaMGu+Nlr7jviV5Bz8dlYkulvS1RfLrtm+6E8MdT2vs1UcpOjnLtskDWzd9K6rRu5Oo8mJg4Xszes6aTZi6Su4dBudpeiH64K51FLvdnEY70qvdRevOLjPLpfjA5bcsD8TAmz+MyW07I/pmiBdkSDrE/6vG9m42jK9lf3iiNJ95G03D8rqbOB+3I/g5HD7XXrXXyvRtXayNQlh72Wt3n9LA+ZC+0qXt2fgvWhH42qg0j3w5M7Mf3yYxY+ktKwtn7LffGwc7QjftzqnSMroFRO5qG88mWzO84nnwes7lH9Pu1fVzMrb3mYLRQh7F5fpHvmxgvzfOQMEsbvlrRx30sfWJ/cmzPJhKVj/FAsd4o3Jdaf3ucuf7UcrB1QnZIbEp2RLOpoS7izproHze45s0jI/N33ZmT3aID0U/tvRMastMl+8efTwZ2Vp5ibGjRWa+b6jRC9cDI9O68vyjV4aB7UBOTfA/v1eJz9lzCv1Qd5ppRj8n+spPxWG+nxP7HxukppeeA2I9pvp7O0xyT/X1po7ecdcj3sJ9VyqpJif3QvW6164Qrsr/G41d6XR+1GOuX42Y0ms7I/muyanpbpBNCv09M8TDvH7vY+2yVhWu4cxd9+mi7OeSnDfH/miBcjI5qC6vv8li9XPWUo8/mkq/u6+smQWV9UqPOOOzhqDs/bSKrd+4gjJ3OstXakvXpLSdZ1Tq2TKxbdtm6va72Aj3tS2rhbr8o1WZeffrvs9zC7mm879WdrFog4yEtNtHkRuxnIj+cpH8dRMT+X26z8V3qvVDnMtzbetKn6zO5m+VIjWysvV9bL5+ifo2ijjExLuWK6IehQgL41nRC7EfnYoYfOSP6ffTxVsZ6VJH176jXZPOgoYaV9nrG06T+mRMMdW39WhP+NFtT3Y3vAw/b426nN+iZWU0izb1yOc4bYt+SXQtN66oVYg0pbrBUdIIfDK2n92n6ZP+MhoUuJR6xv3F/N+5jdCD8R3lxnLbk26HUNoN23WTxJCLrE+DZaapVKlqeOp0jicRI/8Xj5FotcxLj4Lq5zl/lkqz/fV51b+8j9Q9jbXPH+4TIj9u/17kcz4j8dJ+3Ku5S+dESazLbGEfy3bp8pmUgLUj/ruEcuvbuTuTzkKyDyeNM/Ef1Ufa1o7Qn9Fc3XyH0nwT/HkydSbdL/RMlPc1GhxX1T8avdzdwFfJdP33Ml6O1iP94PkznQ/9S5ch/FNmgVRmXRJ8Wt49u3fcZVrHiXSPv5amo66Hnc358ku9vs3vKsqC7xOFker70L6PBAhVePL3OkvdV0lxv8xm5+anC7t14F1a0dGW0voRWOkbts6SF2LI7e7Q54NifW4WWRQMTre7KiEi/dZTUje5c/UjzloQ/D7x9XRV5gfTRLFmgeV2W+sDwRlZ//QixWh0vV2nbJf5BsJ4OHxLalhKy28rmIa2IfbeKqkYbs030Q7bdatrEVsn6eV6y6YX+foyDt+nOT+6L6Eepmd0u7qFN5GOxxseuciX0XafaHO75ezFGxfzsHN02iXDQvspLRT9pEdac+Tmw4hvRf85T7a4/ubaX9GuUDQ3DtVysT5pz0yoGZP91/G51kfrU/3nJ3cjxZ8S/0Y8t1JIT3XTRo2r3O49PtjS0vZxd1yvF/GB9F2nPaNN0yP4bdZzDa0biA3V1POJJb0f8C7KIfrq7joh8t71qffVfR7L/1pZzNWfKNcTGnfhMn/RN5pfoE6k69rODoZt+Phv6dYfYX6d77k8PFyNH+4XtPVblI5H0jidL8eeddbHRCmM/2ebmDsVnfVtrVUDU6OfznPS89DXH/ixVbnPtnaRobo7aq3R3nJTqrNeZtjd908Na9d77hTxJdshe9JOzCk/hHXGLBDeXWsbWy5c6q5WR5mgXo9CrFuM00dZNeTHNWTnAaHs6THdu/2Si1rN7x72WkRl6HnSah+/UAfGfT4P3jfBERkXl5q/QQ+MEVc67jw5bOcThHF3crLl3xmjeqeRVmUXEPx+S5YpcPSIqL0iIHFXPWY3mTX92XYXtMtG7p1XQcnP1inUvfHc6zZt8H3fr2Wv0eOeJFmWjW31N0wr79e3ZfVi3k0riV913R3qRGGpHLReb9FnvcbCr4qq3U60aXSeryfh9W89L/VYrZC91OwfsaZu+tLu75xStyyhHchKQ7y0ljreF4s6wdVTWzv69W6poZhqXu52oxL+us8Gq1XoT+xe0HH+x88+LDlLaTTSo4/al1PcD7ZY/16Mhdtoj380GgWeisuUfjI9nk/2hbeTsRYIVHQeSdO0fyorET6fe43CfmU/iv8RvS1ntGlrqPkRqiS89El/srr3F+1qjfYLk3W0x2d7cDg677gTF1tMl8ttRkzJJJPq9UcLrpbxOsGsUKCm0E4k4xkaAg+VI2RD7re3L9mAzuuJ4GX96yWqT7dD5Wu4eTaOXJD6zqs3wEhD/zTCni/VwkRP/ujXvlv7yuT5K+mJdB37zeevYOhBnYTHApx0Kr/rzQXRkUepheU2H+N4ZkfV9HyarXofoh3zU3znqpaD6W8mL68LapzhqWvXuvkqp/71+up307B1LhL39BhO1tcLOXHGOeTMi8dP0429aQ31dGPp+qEjHVjeaE/v3WCfraivn6ITmrpId8alEC2mwadr5TMPhdi1tR5MW2X9mts3UySHYJ5o20xefZXhsYaQ72jhopW6OFu3bKtUDa1/qk94D+U5nNsNx0W3nZazMUpQ7j6fvbJy4RJu7ZSiPTT3Ebquxh5LS7+ToZpmd05lsBUNvavzJN1Mvw147Cib6cGi/0CtLw9s+wsS/fzXG6LRMrgpWJdx5a6fzaoGy3CK6yJw/DOIrP2x0CCddHC1a8XgmjdcmGqel63Y6wzsZf46ag3x+vHFAXJPjbhgsQnTZDC6d+zN4GtqgGtyH41srw/FmdGxe6lFWUevTsslfLrWhyz107ubppsHm7hKs/TqRiX/9OR6UXpNWhq7tXyXx5d47bFavTDt08aJGqzQhA1oPTpLauxiy3Au6JL6Kus9mGE+uxH4MC8np7cZnQ/NlZTPQmgnhX3YYz8ZZQfz/6WdXtNXTY2GguXpeWPLE/eDQGVyrWxMQ+7s9tafn/kw6l9raHXuz4BkV2JjZlnT/4M4IvbvuXlHsFqG/D0LZPN4HW2xVuq5k48l1jF4XX7uYhUT2X9e6vxo9X5bYe/WMUY5SYt/ktO17n3BaSbohpbPBYDTLsbbKo6b9Ud0aeeb8vsG7/UXSeq9Xkz4mM+IfRiPlo8lNZqLFSO3sToPrPlGnsTa4pvMHmd9e2bW1xCH+9cFZBuPeKSP+Rc977O+7KZFf91YODb8piXzZz3rhm+mpJPGFZuOTv34jrB/c8ezpF4R+VfvS9lzsiP36WM6tCP1TiJ1FcD6ud1IWolHcb093e4PsHy1Ws+5u151jvatZ79LX3DHyz6e5fD8ejol2bMetaXCdZNjXn5vVxG7JRG8Ex+Mw369OiaYje/o56ZsEh49tEEiv0g3RBqMGd/f3o0E+LHuxfbKmOB5IyUJ6PCsXaUs5fO7fJqE/Wi874+Cx3GLHtc5S0umT+Pr89C/jK8ouBlJbY+ca2FGGbefsFL1Mv7xI/HP2FudosJfU1epc7XpOF2NVcS++9CTqEMnWO30oV4vYz+2men/mPWL/SXTitQ7bFbH//dOMcLwi8Yc6JCr/aS2vCbb3p93joy0Ify5pfJu5hX8stVbUOjiNpp5w2K6D8EXU4xEZ4d5PXwpNAjXXk2eqF7I/o+I2nB8/C8Kfut/rNIOse5TQtBrvhtLVW+AI2Qe3Kt/yC+0+s3Q8LZVS0mfvy3i7P7YcHLinAtXvea+D+rto93oN5mvi/y9a2nhfewmOtLOaXQ4k7Ebyu/9oPbcTQt9G4cGrl68+VvVlht36dqrRZfHYv9X2iMiP1i6Xs7zdJes/7M/bO03JaP+Dz7ZlP4h+26Dp9nR3WjOsL2ojzq+KW6FQvS/VZLMn81sXLw3Xn8kch8rO8atDh+iHUX3qTZL6eCr1arbXT4q0PGDfjFEwyypvh/xlHiWTtlaVqqSce8FrbxH7Ks+zYTtPlzW61dLdDEfdi6ROxs4iXcWbI0avR70oqpOTonq3vgf2dkfkI7RIQN+9RS7W6sPA7jaLgYzGu2PRSe7Xq6S3eoUtzxfLB1YDNV6HjXxT0Xly2waDlUX2pxrOtyRk2TxwnCpmg5IPWf/lc3NDYWtL9Kc5PT6dd0D8S+fz6UXbUctdoPG83nXagUL002Z8zA6e/15je1uZOCnChYvWvvJ218XlZKgqaj/luzfIsVmHhyzznsRLNZPuq0Zdidhn00o/UXPyPhgti2RVTRoyvuW4bl8O7uNO1nc+cj+bciZh4gGdEi/JvArd1eiiD/rqSdKj+anBvrbJMLpPylRzExLfPq3DotKmg1OCehn+dPvaY4vN9qMchH31qqIMv1d1oy9OEpovpivH94n8aLPDA09PAbHvXrcXjG+X6znR9TleZweZ6D/zWrU6j5Dq/+IuyRtv1SHyc3AVPBmvIhJfnRO/MFdTot+z9cMqI5nm3zS1cxrOTU/CLlEyPrq2h2OUycW09jbRw9Ce49rcIOLYY+f42YwLwq0anVF+ioad4JKop8PgeT+WgzF2plqrSbTH0kXnju8ZHib6X+0oUrjahUT/6z15KpPwnMjnHeduOj4/SXxHTK4VZMrkhZ2rHlWPcn0doda6tJVuR7pJetB04sVlGL1w+DblQ+W2h8T/JKHyI7Yvd0O73R67YVMP3jicmnN0yDbLEfJHUqnuj32iv9ztzL74Q+IfoHu7t5kT/WGi94ioFF93ifzlXjucDfHgjrXFbZPdwprIf0P+3dHat0rSRmctULTX7IbdUf58zo6qJ6PhrWU0qi5VpZ4X09vxsRmQ+MqI9K6RuIsjKt/b9iTxhkQ/dbzzRPaix57Ez8/6PRnOliZq+oNOvl16ZH/sZx3cHAcnjHU062e2Mib+lX4mxmUTnCsDLd+Da6vZDgrseub5EqhXYl/fq2J09sj3Ut98op29baIdDj9EnRrUGUZeZW0Hzrwm/pl8e5Joc3BaYd155jerHfdfqLFewSlN41Oi5kWwVoezwQyjJCNW//kh8cusCdDKSvcHScXTTX9dtYn8usZgMqqs2O2gYuoqrdPCIvGfdUifQSxrJrFPzZpEfIUVotPo3J8vnWxG9KPqvYnXsdngoCkHxexcEvlLbMVOzNn7XOrlZ/K8hN3uFqPnMh5UxmsxQudh/Zi95gnx79Rb65NLu+4C2+3kLU/m80EHJZ2BNSPqoyL2q+M6n91kecHRJ3Lj+3gwSNG0acpiNGqupbpQ+ruuXUUHEj/khwjJp5WKzGjff0qb89XQDqrnB4Pue4ujzXWTDZxM7iAXx8dZUziXhOy/5vXp1B7xH8aToUUs58Al/Je8qIxaVwkls3o1GvbeNdY+gdw3ndzL0fz1Pr1IbHMp1a0s3RP0iEpsdwfrcLmMrzmKu3pS+RebyMf+vtj0OnHLxd422w0eqkP460Va+BitlYOhnof37DzD+wC7HX+dpu7JqVE6y5fq612S+NXf6INLGW4CbNSPx6Kd1WT89XNtyNqwJP7FLVenszrUptiuQ2LtBr3+CHnn+HNI8LAy1FlY5IfPsKXi0JgfzPusdTGRf7i17vFtQ/yb87SU+p3z5EjkU5GzHF36FSp3Qe8RDZ+UfjXLB7OE+H9uv0j305vWX6BFOcpT4siR+H1fh00rs0j87YzSKitW2dUl/jHyXosPkW91rB4PHamzjHConcdBsW2R/anradIpDiS+1z9dZ56659MOx/HVRsEbEf/iMlNvs46VHA31JtfV7rAg+idwx8rjljjEv10ST6JW1pdDqY8v7eD2GhL+qD3/0brscpqffPrL2Vun5yvn3vsmdQ4TEhDpi7N+9CLinzSJ8VqS0IT4H+qkE1Wr59sn8XU2WO6kFrG/09VmnMqf+8HQlofyNryY7wD7j2VsJWbWr1GBKpuwxjok+vNw+aT5hdC3Wzm2O1gl+2/vvg4yCYVpfnF/mz1qicRnXq2hoXVfuDv6G9J+pd8m1L+wsvGmNk4pNrea62Xm9lIjo9OarPp1eUiI9Dq4QTfSfxhs5HEmW5D/0Me+c5OI/BAVRlyqHomvrJcRoOGpclN0f7pNRbyfvaS52uzWV29XIj+nweLp5a++TPRTphmTbkTW171rYRXcZgG2JvQse/ypTPTUJ7GOByoZn+wG5nErLQOi/2+j5+A2JPHdCj3jiTQryPhGdt6tA9z1sXbZmKOEeFIm6sWxspzURxIfvXvOp9zqGx/HbTV/rCS130Gz+jDV76PrMdGP6dHph3GUkv1lbK8X0yXx3bkzKR7NuVUaWtHoTzkNI4yjq/36TKs14a/RjRZbopxI/+Fxejrj9j7Gzv7ZeMZOJ+PbHI+Pl71MSf994z5qPaZeiv31db95HypnhHTFm2STsCDfHX1cpXhL4ntUXuyTMYkJfpFmpj7aEf9UjbcdOycRJJEf0/gsrdmNxKeX+eeUzFfSrkSXZHhPJ/6J+D9q9X5NH0Z/jHZK1dFwp1Uk6Jwda+xNNANHLdT2F7vxha5PbaTu9j2X1GmFXqf5dE2ciHQ3r4xqYeUkjN+7s3TqbKn+irtme58PsDoO76tJrp/GKNjOKmuzf60lVVek66GUUuI/NIfTYzaXTya6urHtH5sRGd81aLW0pPAQdoOZ1LZGs3NO/J+qCXUrJfbZiPyu31EiFVvj1Nu48sh20XB30PFyKxckvjFXqanIXoBN/RCtFjLVT+vbXcFPVyb+xWrobhb99tXF7stq93TlSfRD01H6Wzf39qV2OGenbb58RDiqr8fRU3s67vd877KTtP1kJWmx5rnYvl+nDn6feyT+0w7xU3s7O2L/7bh1bXkthO2eOl++WvZljKpNeznZjee7UrPV3S4oT5GFjY6Zq8dsQ/ifnYy6Lz37hL6pdNqz1nHUxupMOcz9TuLs0HH+ufuXvUT0j9wZN8XM8sbYmL4+Q9sJqQ48BwdpiuSNQXw03fet5O0Q/7SHwplMr/aOrOeterUPG0mT99t2MTCuOtZuQec4D2aXEB28/no5UKd7Q5+eLSN29g8LR8swQqVXzWXkR3FT9qbalvhvR2t01/V6SPC7/VnVmmQqCneLTSkr8SZBKzOQSJA77mLfImGcu7HmLpLt/n0w7cxpfUE6bdr1yfOwFxXvnfKuyf7OykspZQ+izVRpP8XDD/2pC0/Ot8PNsciOSGt3iFJfjvYl0oat6ZTopQB7hnodlfKa8H+jqfODvLuT9b0tDyhUeieEvXu8HexirVcjfF5tXtfVNCfyUd4Xl0OmRdjc7HqqLUuE/rm+xZbXVAS//woj61PPMDbwxja27TbxD5yq3L7TlU306zvberfVY6Nhd/v8tO+d7sVFuL4Xk83oRezn6dHKj9FYI/az7e3W13aaLcj+DrrJUnvtDPTuZH54li2N7J/PaCUH7/cOyRetr+5sxSm13vEztgav4opDqbKXn/Z0OibyOTaOfavvSPr6s90d2j0VYWN3HV+f7UB7oUDWtSTyIt8gXfXd9mwoPXBUXtRhQPSlSq+fLNpobuESnfq9SCuzkYZtpRdZ726H7M+Tp5yuOzebJepq3XqZs3x8wfYBeZ/Du2dWyDX9cnbuD9NErdrVYbY4psT/9PR3eGi71hh1kbG7KJKUSGhlF29rp7s59ou440yd0CT7dzubbpRnjEvN8tRU91zXxubJ6o1fU7+U0fYlEwf3sM8MvU4OuDjE9yH2T/PB7YDzZIwWmXMb1J0u0T+bWf/kFUcTYb3fXdVLc2GoCDX54iF747jU9ln2Pnxm+ZXsn6JWHLM5hcgLk5adtd9LSU8bslhxX37jWH52B9Jq26mRfmyex9FAW0qolVbJ/nwfdbA9jpdebBwIr6fDrHd7JtKCiHZxvdwXq06KPbV8xlsV2WO0z7YnJW4P1mR9w2W/tE+1if3N7D3XFNXsIMNb9++Nu50n2uhYLrXzJ7xhf/48NU02s000JBHTNZw91oZ2Qpa7fgw6FUa2Pl3a0WSWokFUTl6R8s4TvZxd4yT3Ow2x3SMNzdDGTlHrXSXlUwvJ/v+EAwOjrfnG7mP5eFj1pDtC903qz3exvkrUfSL3jON598G25HUHt+35vEDFJ+63WsT5TtTLxg+sYXcsY9uWcPm85GcX1e3d8zGfG6T/Cx42S3l1VLBTXesqXyjnEZqQEDrxTH1bqmmWF9Z60CH6QWqeb3mjzY9o6XUu694LrRO0WdR417PGI+wNO+PEXyU2sX8bRR/IwS4q9dXElqt8X+VYv5dLJZ5XZ5MYfec2vI6Py1JfT2+r9Sh0h1jP7cXg8mp6HYQ6y89abp23iY6H7Xtv+jq2Sfwx2s3La27tkI57ae9g+7mhkW2wvVqj8RUbwzReOYv1+Yiej/7Cv23lbakTUe/mn33axhpeL1Pl6RH99mwfLx+79dxK2taM80ouKwWbgaWfDq6Rpajd6ZPNcDN3CcqjwcHIJ2OFxFfvljf5lHaNnOA9qbbPIkn0Sfcs68p+ZGOi6lZl/zh5L9DD8zfndTYPiX8VOJ2mMuQ7JnN83s2J28vRZLc6KY3mLUtNNY/v0dFRT9h4kmh5GF7PNaqs+6k3fM2LRJXK7HPCpwHC6DPeauc5rc/boZ40SqxoLWnnQWt8Pt/NHvbzZnkzjtI8RI/X0mltOsZa0qNpQjzmV/rAdnMmmzKrLKI/F+vUHz6nOYk/RsvJ+dJfZNh4rbeTp2N1ZCTZYTogljsr0SwviMSUnTk2cffmlXfiDKEm7DgHeT4i+kG/t7bzzaczxuFgdVwG3U4nRBNrcFkPNH9SkrigGN369tjFBjEr6Ogcyf5JFf2D8fywSLSlWSy6u3P9wdb0naXG3SDrpxCnvNUyV5tEU4Lbca+44w8Oy3Gct45DKj/uPPK1oboq9W1bWbtGW73geGHi4/3hzzuoempFd54W20Sz9sv66a7cHg7jsPaDTdfO0eLwWiWLsbdNVE17nodOMJKwejvN35kpE/9k5uSOUph6XurL9DUoXxLRH/EikJfhcG2HSGlLG/U6PhP5G46Uh7bw5D5215Oyb9cSsY+1nyxQfV9gSb/dn9F42MgqRlWA9q1oSfZ3joZys1PSjYGs53RjZfGiwWivb9VKbXVlZKWja1SbLWJ/d067Hr4Q2WVWconQ6mGS+Y/0cVHGExq/6tJpPht1Fj7Rn9NrR38cE7J57Xl03V+Hk0RLegNvWuUji8Xv1rMlhajEFye590c40Yze5+0fw1rHTtqd3kJ0TVS06yn7zBomxP8qPrOx+z5KhD+zsF61PvOPiz6bjRqi3ZDgu5u7dY6w7GBXHlSBWU/MEK2vuXS3+x+if0fx6ekssUn023RcxsalnIVIuyROhKbqwtDzsNkbcvdo4LC93C88XEsL9ESn1nJbWYR/dVVWXqCrDva74SeTk1m5QyTQn2/dK0oMdPH73UGQjEIct7abzWiTGil63NP5sQxbEwM9umtn1DeIfYrfu/5w/IrSBaqu7/T5saeppElK630hTjjC8XlQp3o4PKUovHUG7+Yhz0t9QYTyuXuM91gLR+1+HaxPKor05UzroceyVJV4eUQ53T9mb9V9S67VJVL+MeOWn3UTQy/1EsWt0+KFo/wWvVypbRP7Nlkfp+fDZkXi8/lklZznJvGf0z5+3VJ1RuJDXY3PK+lN7KcUN7fLoWMW2HZ6+3DhveYqPfe8LkmATfT73Xsshv3pYoDj2xs93vpqvkC74LP93Ec6NrTt6Dp3BkpeYhKrXU3T6UomCg9pp+ncJ2NJ7d4vt7qyRz42ZnJoD9QN0b/JVbue82aYG+pmp529aiKb2Jt17u2zuzbGaPtJbC1anMaJGnvnpFRqor+c29lIdpFK/Pd70Xr74W62kXTpPl4NrL7awnb/vVTk05n4Hxd3s3qk5jMp1d5y3+8NDE3D1i07EtHolS8S9CO9Cfx8bKDOtRXlg/gY4di++Wr7oSQkPjugeSWr6qxEz6qZGq6aHrG26ubZ7GA7JjLV++gdv+WppB1bs3B5ao4uNhdlbqBJq1ehRdPbpK10v0rQ9NQf3VBv4pP4N668/eZedZByuNqdj385lajq3/rbd6CesfU4KGQzjnshurRnp6633uaS1snux1PgexNiH49uER5e1Q5l02vdfY2NqtROdjHoucbjgHVnPs+C29tV0dLYNdtrVh4NHS8O2s7enkh8FqrLVE7Sy5Eo1bTvafPnkfjf9ad3atmDCY63bpJpqFupaPO+vd6X9n4v6U9D1fPhqjvGTn//uq/iWFaRqqXFp309nSR9IKF5x5pqBUbtY7ohMZ+7QManLs1wtiL+82r9wL1ue2Di0EqzpvN+HXfoput2bDezrNSP63hDgmizxFpZDOdtNCLy+xqtsvcTNUtJjS7vcVuTOoQ/zcZHhbfvpOg8lQPdDLIFkY/F8j1uOWmB3dvn/xL2HY2O8libP4gFwcSlyBlkwNjswORggsGEXz+63fO904uemapNVakEQuecJ4CkC3/S1lAriBbvOxo0i+rn5L95gud9hPBhzlhaKx8o+Koy17WsoP7t8RDM1Hwg/ZjOFDJ6HtL/a/pb5j2J38gybJ3zO53HF2rZ/nEtrX2ZAC9S4nkvV6T/y3Uafo/TJaBvGir+8oPnHRhEbSG5FaeoJiSdKl9GTkK5haztjdcN4be+NL0Lo7wDdqVc2kduED4gXYL/EmUywfCrE43vkb+TbdIZMMzZYuRfpHfc2CnTA3esOQKuU9/JIG/FBt8DBWrvQHiZP/tv/RhtVAON/x313ue1hRCfwaHdxKY04zfkX5FiNvpTxkZFfj1viZ8vJ9JP2JtIxWYycnCvnheuMFGO8EV7YWhCWBG6tVk+Pik1/K1/waHJk++iE8k4OpDdJ2OIBM1GtRiN9Htw35okq35xJHVJ34t6Wu9QCVqPbvPfpwZ8plY1k7V/+uQRYkBdxR9UnnwBe/6eqCBxyiUZPPDp5KnQNR3/zBWUqyc13eML1d/54yKCMkXE393j1TQIEwOoU2CSOf+L2o/MLYnaYSuEjfFtJMjCRPkVkfjInKEmAnq9ZX5NCF0nqrjIwOFtjVCcpjk71P5f388F18vEAMWHDno2r/7eD7ivJe+egzI/wN0QaTCkaoH8efjFuD3XkD6w306wxrF1gCn6ePZQFV+EO3/6q3SxL/S23oLm9zW7YLiI5RDtbIoATgRrxDy2DuHfdjSe1rIuULTMJAbiM0ay3bKsMehajfAP4Wiou6YAqPWlvre3+4lEVv5kEexW5D+eb6/r6dJC/jDmDyHq7pMCui6wn1rDIvyaj6MNmwaNv+R7Xmg4cowkMnJznNu0FgI0rZ9evqwE2JNUYVK/TJ2Mc5gvg2PoofZF1Ud1jXUHQfF830zujuqf5J8xluneG5pB0Q67/GYTcOgLJnMr20eii0pgyJ8x4i8OMsitJ8wEbLUlBs/ie0W6vp+bsR1aCD1jwEfnxqH+T27ujmfozoRUm3lH5G66QHBG2aG3PBr/F6MI9226FdI3T7j/ui+JQWXnOhUg+kX8xtbp/rx5CF8tc2fUYbI+0E/V+5BGU1KDigMmShdiUGRObF63X52uEGizcn5n9EdQaI/zCGE3K8DfLPbFZ0ECReNJ4fwlpxN41xm1en41KOKDK2BewBPp21+U/N5P1eyBiBxN/a66ryKGs91wmUStUOR/+G2fWxb1/zRvPNhr1H+KErw7BukL9UGKTU3xUH1Xh5z+1HUZFGn8OcYnXqgY+mP7jTqbtVXwcaaXQcf2V5F/qUTElyStCF/IqgjcjsnBRGykmE5B34kiCiZzE4cH1C1+OsrkNj3QP5VjTYjiQsi51lg0zpwkVNnHI7CjIEP8Iw1qU39LdP0ps9/hwPUrNLznxbY/5HMBktYY3idnRyC86KrE8gqU3/4zDrlvmiB/8GqQK0C2J5IKgym6mk1thF+LklbgZeegB2qMp3u/RlKcC5F8NcULym6ZsVfvvybgMazK3571l5C8YBZvxTuQoIoXRCNyN+RPwlyhRnr1yw7w6lP2vSuG0BnFjZnev9EE5lFNHEtHXScB4vecnuGA9NUFbMitC/JnMEixkgDMFImw6bNNLosG6p/fc75TBKq/4Pd7ELXpI/96Enpx4yuXhRacV5zT2cQEL8lgBEkBjSI6rkfoFMRC6N84hocTMydAfqFqMOWzjsTuUPi102eEP6bfzay4pDkoHVQlXWJNBHAdmVrKJY7+Pp3TDaNoCH8EVoxrgcUQPlyrsvbF2SB8s3VhiY4K3f/mkoWdj3tHyI+sehTzpc0Q1O8Hf0GSJUG1/XpiWFsUH/8FAZ8/0hy6BVtEwoz/fV/Cwk3THGrqxDTs7GkQsBHhG4mTgbgi/xa+7De7MsU7kl/nFNuvTaWgQb3KhsHjcQIv5nErtvmJ/LvLDJ0V/hgKgsd30To5HhIwU+VtmMIS+cvILyHd304ArQCzPZLIx7/3P/4tTNZfherDIPBVZFkJ2lr7TquSMVwA15zg6TXqItG4C1zh9BSElnXPddt+vg5wausPBBbVdtLTqWP9K29Iv9gdY/CtOrnA7KL0JMYOtbtRUWkMGAwI3mPq0TxD38GOPFq5rFpHgII8f/esL1woKwXHCLT56kE7UNjaOHWJ+P+QSvqVUQD5T5FXy/KZPAAUMElJpSfCN4TfQkYa2wNah4rN3oD/tXPBkcXB1XdS7Mox/lVzpA9c5JkssXiqgG2OqeCXvVRku8l1rwZ35O9iLD2/92U4wBOw835JWq3ImWyo6zW6FJR1Z2mkOZuQvlj49iKNCNV3G9wD8kYUAEp15R2VaJkPcPNfArvietVJ3bCzfz7iRP70ypqDJpE+uLYlpJ2LQO3H4OQwlxsVqp6VHDN1M1VA77s/E32D6mfxE9257ewdytTXbDmyQu2z1bJ9+JK7SB4WRmK+fQqhzOVNxZ050g/mM/7QflzWnbS3BJN7JXlBk1uJ+9dr9R4wDBndYyOsO9m1v5xHORry7yZ1+yZD96rB/EaltqPhd5L2kwQajDkO9b07R5f5W/88xO9+edZcSwBTGUHnBLMGxef8YVLyY5og2VTNfFd9h/ijOGVZcOobVNq+Cjy+1VdgWqSkArJtO2Di0Sng0xxCBZpsjjkcyp9fJzzGuMN7FP+vKgzt1iB+smmWFOQ0uYMloWkzf+pVJKunaTD9R0P+Iq5KY6M9WgTfr/jMnfVE+V84oldF+ab87c/xGfChUH7rGs+zGSs1ilxxR3Gt5Yz8kcLWte586AdIWlEzDRvpS/ExO5/Pbp0+dH4huOSypSewbZiQKK3WRHLnqwYK5+lAQLwQqVk8mp+qdIRyXND9pVbTpmI5izt0YmpUTXhjVGCTmuCGdY/q686hedAJ1K4SmfVNEvXPH/i/RsC+LLp/rYLA/12NAxW7NMlqnYwJzMLYCfD+aAhJcOkXeGmDC0UHV7SpaukVvP33qHxMpSXEFn9E1Fij+hSDz2S2rojik0nQ3KtngvpfSuEh6k9l6P6ksDo7Z3yApcKXNh8bpH89wug9oGMoPydDYy0yRfjh1aJRWNoXscxCYbM8bawCpSf5kG/4Muag3QTxV482qn8Q7m83digPWsUkLSZrIv8yxd/hxuwJin8G2iwW1c2BHomC0UsnGv+vBEwy8XKL/Onrun4SrqHnW67b2WLDiwEZhIKNyxC182G8yE97s6DNupZSfyDiL/7bKtHac00k9nC0Xt6oIX7qlSne+XJM/p1/Iumi+iAXNRXJLED5y1kzz5LaKweEHf1G8S0ifslRjMlwZy0oYUagUMvf+oeHVz0rQ1cbAsxuIH9gE+vQpj+GnK8Dip86fSzOI9Smk/hrzPjotAzoqaVokMyKrt81PetxxN4oEsa485KOmwZlgKnbXm10Dh6wU+P9F9aEpOxUlqn+oEOHwugyJOq/+pb0DB7nUEeS+Lf+NNAaBeq9Xro3I0P4GlY2Mim/DLVzoP7W5Qv5E0taPfSHN7o/n1/xuyg/qP5HQnZ0ok9V6NE/dVPvB+qfCcFPK58kwj80qGbvjlOF4t9P0pObCc2f4qHcyOx9DLGTM/21jbebf3zy5tZ/UALgnLmqXmGnR4hzvc0sFqknPv/uTuu24dkL97ViD9uR2i48W6fgJWuX6u/m4mg1v30V/NKemO3r2a3F81v2Ge66Rvq00nHuat4dBye/6mA+DHyTsQqW/cEuw83nPtlQD83CdThC5tRjtnJrBYmK5mKMOc+/Ulryiq2yeVxMNkW3Hu89xG7lC2fZ46n5ByF/14L7CQoeN79U9wrqFgqEerOos789fFJiComRkGEFlxU8X311UwiR18V3+ZWvwGcephwjQfHlcZsmy0J6mFSLl6DsV5pdHj4VJy33hE/MwNvAgA/Z7OkQS7AVOqILMyhGj40vW0fg8cYM9kpzq0qR7CQKLlwuBgja/bKX1UD6hPsaFfYT1laReS+WzsVE/OPQfnZXJPxv/2Dol3shmHUnNqvsH18huaH6+v0uS4XPFSwml6eUjfwNqBQ4PNY+7aGHyX5YeuWsgu/D+2of+Pd9P3KOO6KkOIRSCO5iju+jCuDlE4KaZCg/w+UHyeSL8NeHgeSJi4Lw4+2+OBdruDqSNzv5/dZh5SCI7nPc3xhdAEln0NKBNJYiYnvMvaa2MaBRz8Fibj3ix3VPqeAnKU0n7kPu9q8kRfxaxcuPkn3kL/cyy3+/KiwjSWWRnYQtyk/JpMBrcZYb83fKAvvGy6OMgHavnJyuWNRfrDUbKMlHQP7wmFPDH5F/3Xpi9T+PQoYm+Ft/xZuvO6DltvQ7ZWmUvx/3cKMvJ/ChfX2S7CPyCP/L4v008/M5KhIvLOvwNqUSuhSeKo/Tnw4gHpOgzk/lb/6bL9EczBxBg3kebwnpqxps/mfZlj35+/6Y1R/bZ2YI/bBe5e23If9t3dMNv/t/65P7gA0TPtxCKA/pqevOjvznZ6fTr7ncPoqsdYyD1xNWQF1hz0eiI9kPyhKQz13kxkhkWqEJmZeJ+HcdZlp5YzfkT6ckhqx5FYp4Vw0yvY8TDwFT37+2odMqMBnmFbodNxIimgA+FyjLRvrp0+T8FiF/weoPtlelA+mvwmI1znWkBOrrL+HmU/ggbdcfFC3UO7q+EFjMfUqRfzDP+8d69/QL5ddZ609zy1F85p0kmxH+7Q+omvbakFLMwUqqYVUODeLPPRcmsm28Fiqp9tXj78dSQerA+FJ65W/9vUS1r8+WitAqkzAcs/G1gsMsTGPahU6RU1lKiYEJ7tBoAOsx5TUhfeBA+fywX+Tv7r9daIiv9kD+u/zpryRB/KWvnVg6Z9Aq4HaVOsiGNIWWeClzDGjkb7Ow+spBUA6R+GiUsuHe2xsCLr/zg7b+rQ9Q5f35w6uqk3/u0k3Pm/aDZjLM6W+V5gkoi3pzA3ebIonR72Oc0lsBzaWeeXOpkDbGIMRf/qF9IvDOVScqYuTPfD4zZCpgkH/nFWNS3DBZOpFzZdEtFeoJla7TyE+4TTUoVG12WJJD178Clh9j8YwgmMvl5bUW8i93NReku/R3fsBl+dL0obYXFFdFMY4XazGgNRP3RP6jjQC526tNOUUMLbPgtc/AMA9wmlnPHomDrm8rjnfBcuuhrasnmg01rUGSMp/XvveLIokLTeQdLBKoHZ8Zpr/CuoP+ziNhnt5QfNjM9bzvPX1DQyPTtXD2CT3fjzUpzM6WSJQDKX/TQZNB0/J+NkkyxgGI1r65Zd73hGznXwS3ddFCdJ28LVnCXMGWhbA2Dhz5i/hGyjRunYif0/2ZSJmM5q+NGOd6nify3/oyu9XDiFPouIQiTWVlkkBpo++YvrauA3cD9vHLHVJoVIywk9tqJeB6PTOWmdIJ8fMjXXvlLrnQIJGnE+eCEQBX8HeyxrmFEIeBB0nxQv7ffJQz2x2+2YOjXSlxO85PJBdP/1ifzN/+VLDfaWQgkX9tfHcHi68NhLi2Hy/T9L/17fIXk4SRT1Xw6TlPedf8NxLrQxhZC7NypC+yGPFEZ95B2pv9+6qWuQO66xQjl1IV1N8NMYJLShLAvYnoRvXRhOJT2wezlmkBjcBGqGmTHALCJyE8aV9H/rcWjoHn1PMHpf4bKfHzhtoFwnz3fti9kL6U1het4dMJTWSFvO5dI/9qGPxMegGbETITE4fAVkINrff3sz5yLxJArz512nxTyBf9nuweTVfyhLKYdgUqfqTP38S2GLlyvDv5lMmVFXQX1U8Josr8GCby9zkubR3ZTYTIXYxx/2TeCmW2CE1TRLgG7jolyiwch0geV3yAbLpF0HKL4PSPPCHBC8e0obWpIZJYRnRcEG0Nun7tC6TyQ/PLOcnRVy2XKBL5pNtBQnGA0sqtB2vZnxU0T+tqQsovCDFbfNPjjvWCDn7SJWtgqH6HDwTpCw5vRXpSr4N+kIh/ASaW7Zw0Uw6cTb6nRCMh/hV7/bmJGsJvS/mWOrEmqL761WcCkts6QpTDA57O0/Khzufc+plchD/ebT6j8sgGReTuQhGz3GBDC3wWgX/87Q/QFnMPvEFF/i2Jk9gzDsxB/mIo4sAT0hxEVOWntfKaItGEQunr6t/769be7uFTG1F8Tg+nUmWoCfHGrIEy8huAZnTLW+wxzS5YFYK7d+4nVwDBCZTtolpD+jr9DOYu3ERwZ4m9hGU4dWJXrWA32eIDJVq24Clkifjv9cF+1A6dHMD+hk93rIXSNFxdsMWI0KNaeuanbE+KfHDQtlJcs6D3PFZ/H7vpb/2bLU3u7ztEoHdP/Kq+AgaBkcYco3gfBhj08fAivy8UmeCwoaJfx4H0q+Nih9F8RDBHtP5d2SQjxJ33JOkuJA3S3yRmKy/s5gKgC1KNjVJJiL/PE+Nsy9yhfCuGZsQi5A+NkSHf6ZepEX9N8BKTKjWhejPZKJXvxh2YYUtWCDFyQhaZTB3u9p2F7nshSvZf+mRKqPTkbibqT7PvfHe/zR163O7UTDX97d8eRNDUcYT09zNF9uKLI/8imqRj7UifiMCm76I/kz26PhNmRyGESN8gKuAUNgAvF0iFOPBPw/jb391Yb/cWWDJUFebmU7A1UH9Jxma2opE/eJOnda1aakPP7HtuSG/Ifz3FhyurrFUr4MPc5rtPJwLUCQX/iZeN9B/fa5CFi4f0m+LtRhjwUgAVwX79eFtA/l1PsWx55r8yEhdzFb407wEof8VZJsD+SkAF3XQbrQv5N0UZ7DDEKAW6EpqCrGTHA3z0H5YOoV0S0iI4yMqYMcrPa/alBTNNF1DC+fogOq8QP2fxtpOlhfQR/2XeSSEjf2PjcNVs1W8IRB+m+omaTYUG8RXE882PK6jvXIx47YH09b7IcBIL7Q6102Fu5Jp/DhCp16Q4vl0Rkig5Z9Fjc4D4SxWmHQ+Q/z1YYeJwwqwi0T934V2XIgddnCDOUEhfPcAF0unHQEf+SiDs9fMlZx96+2eBQyghfSQ+s4U9caRvwPhTheoFkT5RDvkz0FaC4q/3Y7p876AixO2mmRiO7AiUknO/d87f/icif70LQVvyTgodJNO8JTmhnCw9fBiUgfgPC82SMwOkP6aO1sbK9ERo3gOLzV/16wBSMCdRe8NqAqgjY7Df+6lBVwAuNur86wG4se/KEXGoIt/yGYnqE/lbs3vbGfkNUH7fSlosWPVvf/3srMLg1p4O9RiStMsYaHzP9A7Vhr0j/1uqsYH3UYzqF085ZjyIsQYr0F+VUV9o/BujB60Hcwpq0fHoRA2nanA+JHZ4JmzagbF5SUUFD6RfP19TO0xTTwBW2UrWdNErksCZFz8xr5E/8n4ebYM96v/2HtDjOjdJJ8rJpxUiem2gp3g25tQU0r9lzwd6WKVZJ7+fSsZJZc6h/ITjpXbjJwF0ZBR7RP4KQno7IOEof2WhSTE1Hfg68g8/xe+3Af5KRXxlFcN3956B0kB/9zlmUH87mrqip1ikf//1flb+MSz0ichoV4v9qIBd5anIyw/CpykUVD0USB4qF1gYvTOeLugWhVx7SykiUbc3jmRsBIMyfRHTpfHPCbDv+RDHbqki+WdJnW2tKH/BELum+BKRPgoj7Br4sG86mVd2/fJDKoB/VYkP2fHpAeVa7ZyzGeKfLcvJE25nA9VHTYE01M2//eMY2QVPZuwAzx/v8kkNGwQNrvc3raITYDxmraOxIYvAM3zblZBQSJ/rTy2cTCY1QVE6FvZFU6TId1gaE0V5FjQyNxZEKtfvgHTZuPzVMCOACFq1Iyyhh3pvRmNNmZoAMCND2f7TUP03iNDsb31H/FEX0nIHPzQ/8egGMnaxeSeb30FuLqE/oc2Wv9tjvg8PkKr69C56UHSi9KIVi+4fDQSW/R3Ij4jub8jKTj9eQfV3fk22y08xR/OvZOc0Szjyp+bX0iY8H/NIQhxVlexTnKBvc1yqyi+Ef9YrTcn9TZeKXNGOonI7Kfzbf2tSjeIjqNbhvITbu0NTBXnB3hgGusyTiQzy+DvfCGl3U0c+UgH8u8DhVKP5kYRZYH/7g0b+Xn7JKz1ELSHOsWKsnMuKULSTxeT/dnki/2UwqnXXUX265LEujyhnodF/ndeHwBkRCFRUap9LRvFlRR5T+g9bQt3thcwVZDS+dv5Sk/zCc0Lqe+dVAHczoKl0kprvJMLXH8Cpm1Z7jSKX3ommJB9UqJ+3ovC6p2kCPz4EzhwS5E+eiCaKogg0KKUj/fiOC6p/N+CFSKUkxD91YDaXpKYutJv7t4vP9O/7Sefk31gdEX/07rfqPBzpY9ETmGMj3tMKMh2XXLUQK0KmMam7mmG2ochm9hqn31kF71/mpebv7/3ap2Bu0XNvIqiK2jQSjmmJoGzvYhGFz06RbtJgVRYj+Sh/uODqSxf5YyX1nGeMD30ktzIJlmgKRijelDeJsJpxQfmJ9zgZhr/zbW6fUQ42aYGafv9VvoAZyH8uBqm8wrBXpCTi2qgmKRsq5KNTHwad5CB5s97C1RXSh/Ppui7+fmBQ5gqh8KFmIv3mRNjTJVLEPy7rVcgLsTJ0Dzt/XErAToDqWkMYLnZC+NSW9xfyzxO0HnzUFgw7JWD8VCyuLvQH+bv2F1xrh8bnXpn97gWOVcGeMxN5i9ixkxdREC05iieIqHJj10xOV2DzfopM1Y708Qav7mtIf+dP/G6NfDPvqQvovb/e4SzNSD9s3vwQM3aBhtHdmfhNI39YY/P78YiLmQBjFbTXu9lm6GvZ3s33x9/+MeXep4oKpk4K+u+S9Y8B6ev2QUu2E7Ak8Crq64/mD+HL5avqatDxHZpF0mhIUM89YC9cQ5PGIv93RFoRQqWAUHsW4WV42/gAA/Mw8FIa2kg+puX1G3bNhnIaiJ5iWag+IJzk5vXTEL+l89kw/g8LoF+TfcV/xr/199ZbrEjgr4pUWTbOuXfthFqZcJ+P7HMi+GwjSU91unZiOntfPAuRftVjyu08fkkTwADkhCvnvhKyMEenw1rWBlXmPr319zWLYFN/68+atW8nI5IsED6kBNQ/SZJyXmCtoMeYzlx/8oj8S/vh5ruiHVDNdMSq6sQeIGVfB3oSdlak3/OJ3aTYGqDqkZ7N1NTYA21+13PTyqj++vPpCiHORtBR+dR9PlIUf3C/4uXIpb/9MbZf0FPgxVC5kYnPmYopgKESWvvRP1B88zXQyAnfMig+fdc+vwLK/+F1H5y+e6yd7O6dJ4CbRCP8bzxTMQZbBIuWBw+db1F8PcN8NMlzI6GCC1cewzZD+F6ZXIhUxLcDjvdN2RsX/+1/zdeXfA9YAei03sGVRoZS3sX7RX+P9ILyG7rEVado/tQmb423MP6tPwl6ob0N6PmlTYuU6VHPNfjdM+LWBg80P1ipFtMB5w+qvxg7p8yyaqSf3+tLiXP0fB7eNovCIEemE8yXpFYkS4C609N8o0mkfyn9mrwYR/gky/cj+joFwqdatscb/+HKSHL2LeR39sCg/+apybMV5E/LnC2cJ8HUhGT3PwN+XEaAxjutg/vVIH7NVdNLV+7dID3DkSG4wsKC1iueckH9pge4V/oXTYmD8r8yrI//PGMD2i0lOLmlIvyonaEIaxfvOtGM3tYnd+Y/fax959dovJB/eDzbGLFRh/DRld4/pz096MXNWpIajfD5+i6U8d72WZGlSyLbGrI9FMvjk9RTwD6AdA+OxqXKOQIx80P1Xs1fKF97gUV29rc/kmjcxB+tJZJ7cavbgEhn6LwvvV8FBNLAYCNC2KoE5W+03xj/oZxvqFRD3y3FK1n//f3RJtsxkn4YtJWmamroFJVCmCXBTEB31sqJhXaKAGYbo2tI8Yji43wfsdmmNdA592UL+TVF0kNUbvvrk3ZQv6dPowkSlL/2QjXAZHyEf+ckv29OiQQneOCJyzc88h84/XVUYvHnTpbYD62MdrpAc85Hq/1ANgHfsxCvF7V8IwBrcSIGO/5Bqybz8SbWyP9DpxTw5JTHTroTl7UaSlpCDb+9J4wQEwb0EhXkH2/pCfFTvJ0GySfET+PFyM7bn1SgH5kqrtzVd3KXY/ekwijkBuUbm3tqjvjN7du8ZcV2UCS64vO1GbYnFFs04xriMxckLHUCE3t1nWwNziV9rGCG+q9o4UOwUPyWkfzU/WZOf/vngp2z2/SLpvnrh7i5IXzO7mLw1OxrIeTC0ZMP+uv+v8/nytqUAZzFNkLGMSh/7lK58+CtRVAc1hGRCzmJYL05GnvABvFn9ABq4E7xBj2NZkh4uGkP3tz2xOj99o3EgSjEjI/ZGWpCXnDSvKcCiNNpcBJL+CoS27ePmLnOE7pPHq4dmdLk388AG8dCkBtCit+DU7LhoEODema1efUvEpybJDvLtS4KgJocT69BQvhMDQxtydk8AVx8G6Cr7xPCx5R/GL3C1lDXhqXRH8bf+Rwvn6lH8u98R7H5hd/X1XgQhAkOutGZDiCcOE6eOII4uc4KoavS+Qm9xE9im4iQfpK0/RXu5j4S4FfKTjU+rB6q6nQ4uye/aoQfZa3xwe1DiKqwv/sdQ/oZBRx6KDJWAg6xaR7+QbYdCDth1xpksKEalEI4yp/pAR4ufa3YtqP6X9SUdyUpLaDsuuU7CkVWBMmAfnfzF9UnWW/YNWvnB/oloIyLNBA/6eKHjNvJnwm5X8yPFhhBAt3FXlc3+FokiGNO4aYEWwhRq1MxAfq2QucQ83v7apB/0efgcxpKUESytIyKITsqDmWp03+E9pkF8KLs6/3QbFSfQp3lzV4XaHxPzY92hmOQ/12bLc/ScyBkh6SeNH6jFsSP8oPWNPstAi1xE035aYg/4/CdfVxtRv4JT344EvWLCtZ7XClV+/sRSP5rv+dWYgziD/21p3Oa5YDPmlH9Pb5/+7OL7fP2KQzVp7iNjrzoqP6/J+azjNKPhAyYryb5StxDX2534o2/PiuQi5zUsV9SEyJ9uuybYlkFmlrba6sq3xjASPzKru5cduJW8Md9z2cJysQdOaXMQv6Jb5xWtptnq4iwQeTLPhF/SaEozWnUofnvm/X0PwjLFam43aWEVLcDmqEYlYZCcyZwND15Q2b6ovwRS4y6d+wXOm2n96c9pSSQDq/OVOpv/VfKj+KIS8UBtfF9D5Xxjup3/W27d2dXFH+19/TwwQYN9C9Ka0p2mRMQnPoi+m/YRRLrUJxK5E0MzSNy3dQj/tbXtdvyMnKI6gO4CHqlPsihlzPnJSUS4tdbxW/E2beIHxIr07VI/auf/UK+qDPmHGyMZQLvGpG+SIRLVuUhjaFxKHL0q+pEAADrdG20QsTfxerwSUIEJbTi5brE18isgIqed0DnCsIHwf/OxpuhNuhblI0oO0XzQ8OY4o4lQvpIEnAazRabQBBzYmNEamaCOK/pR1EFaH6v8XxnDi2RUMt1Me3aE+njgzcXfsSNgQByzM8FFswztG+tKpLTPPWADzpwfLyz78CpH/IY+gDpk9EBzaZHDeInc1uY9iOphPy0B4K2RUKBFgafn47kgjvQK8ftAubjEuJxX1nZSHYZ+sjhwqq7RBPYIiVY/G5YhHStTVeozHP1aeG7TMtHQvTzcrTmYAJib7Eyewr0RJy4L/zVfFEMK41vFyQe+u8jtMJm71z42mXXP5YYe+yB7Cu4mH0evwcWEy2u1bUj9Fn78Xd3x+HTsaEJBKbMO7Z49oQMJyI0PgfrQvPeJcfX/I4CYG73BKkOuiHEgOekhVQkpI+Urr2vXYHwUXPuyER69UQAEtEfLH5BCF0jILyBatIcUG1/BtEyI3zbPeSt30zzgJLb9LbKHch//XCNTDjmi/QJaX9+Rro2T+gk0m96UvOUA5nrCZP7OmMkxzPfjqHnddA3u2679n02wbZzj968LMSf6xLwAWzP5G99bZD9nDLpAfjRbPVcrKGTnBQJO1adUyi1Pc7wUr+sgF9xN1H0YlXEoYjRY9hziPD3al/xzUb6gpJzkXk+2rkDw3yjHjznrdAOrztlyVRWg1Qm+SELTZR/T22Oh+fkofr1ltg/t+GvvtMpkcVtQPjp3Cpw5WlDQcU59G5pF+4ObNWTVoMC6P61le/8khckqo8vXB58zrnAxtIcKzd+QfoG4Xb/c5B+klxqxY9EZnPw+tAh0ucc0hffJh2VtxX/rc/KFbPbKpT/WK2kusK8voTs5+12eBx7QYPOsaD+PhC/suFBNJhJoXbMMYnDvHk/6KcsJlhmuoggfnO/+9sHSN/s1OapiRpQUKeFbdjD3nbB87Nni0nEX0L0yMoVjddMQC/qPPiMGYTPHMO4sRa8P4q4vEbtZ6gn8gdr8wrIJEH6XoHgXVxZ9e0k/K5pfCcUF/R+mrqSh4/aj80K/Pa+f1F88lhN15lC4+eRFkcEaCdgOvv8kTxKdP+k2eCi3RG/g8N5Fi2/2iaY/CY/sS+G8OXx4lKc37YTGlJkdE5wy1SQf2OHt2hqUeRKkLhiuAakLzZZMcVaQOPfqMStccVFz3/sTXSXT22DuprQRpIZ6Pp3xuTUYmcQvuCWouJyQv2geybR4VjPTATA6QnWOwWEX/ak06NSUQf06NGC31O2VRDJdoEdkP4qsnGuoekvwQNqE2PvNUUkd+Dzj4M2IxXhT811kX9h3h3xL4EFsvpgekAhEuRKmu0jqQ4hW7pqg/TBK5KG8zDNCdhDgHuKPf2dn+4uDHC+SD8o9h5xktih+oC3yre40h8UOWfeb4V+WE+oNtO96G8K8u+vfYk96VcgfVgqjJRRcnxA0WXHCdQfpA9u7pgvD1JD/imY3k+/TjCk/7fJJlZbRM8vH9/s7dyrQQGFG2RKbxcZNM/G4IZ3mEzg5uu2eHfrIZKDoqhiuUD394+LSCTmSBIAZp6rFinuI8CFq3a37fgJtY5qeR/YSN8q9NQqZ/l3fvbTKfb9PSN+8LbudXPYFPHjlzrfADOtjgD5G5h0KsYPpO9/geWk/Z9+6n9c6L0JND/WxG11ySB/a+24XswsOTFAGMMMlXaM+CFJS9fcHa9H+vcBMuU8LBV8ukApb8N37qQSVVezb3MHzYHZvcdRzHfQ2WKB7fIN6XMvwXT+uqQUWu7uQ5SZ6PmZ1CLxhAuHTqz+flbD4bAh0kc6EH4pYSYgErgXHp750Mn/WsckEVQCTWJr6I+rI36Mqt5nvec8KCLjOSulClQG3bmt4qH5Ivz6l79Wy8/QgZWfdTaPrBSKLFPeMhND/N5eX+CHIjdHck5+1Gf0o17Q1ml+Ltkfwt/0t50y9ZQQvv6axsZpAZugcT/M/sQ8NP7p6pmu/AgIXy3IqCb/iFF+Db+fOQcn3QNlSj6qool5J/X0KT9/auNCQ0TDFV44SiJYhO35Csce+f+kXre1CXSoBc7qDxFHP0CzbDaMlK7qpJSgooN4DS+ofO3w3U6/9AGoVO5RHtA1omk+Naxt1kRoPdMJ846/7xPdjT2W5KHUBNADQWLfmaUifw1xEfLLyID4kwWy5siVItomRaiWi6kQIJ3ntUdPM4B+3EJLHL6o/Va8ws6u/96vEy5VPF+difC925WXZBTIn/vE33qicTV9Un9SvzVSwxFXf1Q9BOXTlfGUvdrklRayT+Y6G5BMT79w0W/oytOGl4x3kbioF7x7Pt0m5kfULEXBg+NgEM4Y8BLCvtG8/KnaPhUKXw+PsheSe1Qvr2D/ZBfOfCbFaGNp8amxMba1DOw3Tkj3mKW679xi9zHjgLjPur8vry99MPvnjSvYzWfHPny1fPLSp9iOgtlnPIJAqDT3EH+IRts/3au5BKrjGcrjtMO/iiJ33jq9OPiHrb+x6iZ3Gau0N9Tz36H75zV7kv/bI6RfuPN9GiYNLyx53fqnHwPMp2hpbylV6Xbcq5qHQrSd22KQ/rw3hiVV/1oZzjHnmhjxe6v88kUpA1nYg/U+CJdg+3zphNw2db2B/51Jb2I6HclCa3K7Ml0M9Nnrq67H7MQOzvydXsmZ5VPGeMPJuaJWA1+4if5P/pzDCy9mCyLVzT8vTN6222cLJtInl1X8pPVziHDLeKvL8yUXF6YwGWsvj4T3qXsTNr8KSys8ySVcoT73dyjo+CBXW1kAn9Jfs9BF1LPC79vT/vqvdxnyrGjQijacln9oj/H1KO9vBQXNGFnzl3QX9m/9J8SSz5AHIYa7kTn4yr/fatSpp8zfB5nCb4uv+zetIuL8zqL+2mupTN0c9gsDjyNaVhs9243rP7IvZKmB1/hz4TlimVD8pmv1fa34+LfqLbwznGAcnP9w7/LXd0uIcTtSMSEoVv/om5lbhNnY8XsuN+TGjEuIp1qtORWxtT41/XjjaT6cCP9QuopkLDm3Am+5WnAIXuDT4rSo9fNlOHgaHt+yOM0m5B3y5dBH0pP+eeuNslG6l4M/DoPY3+unlnHcFOYdxMfi4xi/fcJ8etD43jcPh1+mKhS2cdd48W4SPs2Hb3EQ93HE43YFzNITVYtTqodReygsPlGo2GFwiQrxobEB+6D48ML6Gj89X1slf/fqmXLte9ThzVSvYCgU2GKWHXEaXJjexyIm0y7ghBE+lBpFDNv1DvE+o89N19bKv/oKdzsiPmm898H0993ebLFYus8e3EjJv7FaVVaWjuzYKCLlc/s7tZk/soOX990h/LMi008gGEeHh7XCLbPyC2S89b9Ed8/4w6etiitM/V5XeDmmIgbGt4Tq0+DbW3FUKL+Qc6Kxv/WKOHNBe5W3DpMZcVGa+JbfCL+pk8Hh5fQOcOI9NeK14NjFNHJTPmjKefsMsuxplf7KEYvF7IArJvEhTRe6LL7oz+jXlUUBRuM8Bwsx45UN0caErLhpupV/wsCv2rC54tsnVzDuyvFNlQqu5eTeNH7fmbP98W/rrRRk7ojhJnF7Xom9X0ypxQ9d0K+P36qq+rdGYaGx59H3d/zOrxfHo5CXbveT/2mfaSxIMX742c+5pfliaJX36+n4n1SWy5A0Moi1G0WOfql9ZYaq9hshBFrnd3/8s5wkO/7TPsqMuXBnyq9F+k8781/brX/ab+M/9y/a/9JOj/+MH+HO/27P2f93f9Regf/yS/yv/f/b//zPX//n+vT/+Ufl/3P//zK+5v/T/n97/v9n+3+f3/Sf+KUQy0fHFfyoPmRmCZcuz98Y6fd8kkQlUVrvf9qn/4zvf/T/n/sP7f/k1/nxR25dU/l2LABzoijifuD8tazHZXEl8On+T//3f96fffJpPCgcPv6Tf18a25kgsDlro/6Jb8H6W3S1nEFM3xeWEiyjP5/+EbIoz5nEeVzuf/avsro+PwlBtOwWE0yoxuHDX0MerkP/wOB/1A/D1MaHxEWc8j+aqJb6xyzBP8+HtYxP1/WWBBzpT/ZvSR11R/0nKafK6etjISf/a6/m/tv9Xv/XWU22/8YI/KeRDJPwLTOEjpImgiP65zjbwFqlisYru+xPTaAUGU/UGZeRQ0H887WVSYXs/YUDluxJynyrLf+Qrw+a3Q7hn2fI2EXbJ8DdURgnemMUGQNtPl+fNJr9K7kJtvBujhf+P8+nt1gmHdY98rrYZ+En/7CZjPAvfhDCLRAe/oWrE/songo/+Vx+kK8swpsKD6TL+wVn4F3YrJm3xuTvko8Vvcgui/Bw8IPlMK3AX14ovGqiPUGQqD5b8796/0bdG2+NPCC/C9IPOOFqEhS0Ht2rSr5IbzUKwGf9xHTpCO4XPvamrtx8QfR3tqplTpARf5yJ7u1Oa6etgIv2vaVeZueTnOqX+o1B+iOnaPLeJU0W4juf0qXIT6dPF9TyLM3gaeDFbjy1lnsVMt9hZizEu4AEe/Vddo2y9Ao/jpNtGcNF10+b/UGokXr6XNW95mcOKQK3xYHSTTrKZMFXBwf57zvmY1J3gOHzt319EYS80IS4bQVyWFYH4A/eZ/+taXTE78ppqY+rkHtZkCA5Y83zTH18TWzlefZJhYM39o1xL1la4TFTUc3raejvTZDvTD+bIy4+edPsGmqUBc2ZJvslDXefDZC6LCZrQjI6FHvakOLzwvGoeKrEdfY+JVbfQlVCrsPPT/sD2BaOF556mrH61VPxr/LHLe9vn0P8j5t1rizJVljnjb1fD1RMmDDxLBIOToUjNvo7yzUeL/6N2/5j2EvZJ9iuJSHrCA6e4UMLMBLZU1xNd+fNCD/bxwX5keaFsow41WVnwDk/ND7yJ35tqfLv/s1Ix2rCxfWN62sJVfrItpYnJ1p/3JkUza85seojPN0XXtfmTewLi7p42YJ7z40X9HGv2MLbjXQUXF7KUSolaQ95DydCUAKK9oWQWtidsLI3DnrN1nXis118b9caY03zy+f3322bI2R/cEeDKf+5h58LX/x+bXaPUlB+dPdm+TDzCx8uNh4CijhbYTi1fORHz/TxvmDtbMqNCPfvulKEjTiGfKMyl3g7kaU4nLm7xeGbJvAPZtC8NjPvC0sxZs7MLP/6pIeyXi5YasT1RjClVdfyFh8k8WN8+fXm08RFl9bFGRDfrT8En/aXLLC1F2zZTd0QfgTPWLEb6ovblBu9SJcmWvwnrwJt5/nh337si3tEXq7gY16Uh5d7g4x1y7DOLY+eD6u2JnOa9Msj/Rljd03laVmo0ime8dXe/VuhZ9wZW5iBT9/0cVheQVyCA5ipJU159XkDjzmSQSYa/91WvYXdQYY8xdLXryF+L587aXj7PLCiws/oeBF55GwhrvspAij56fmoCuySybK5w0cyff3WN1xl4UO4AN/fMaqfLc7NQKaQvu7v7LP6CNnV4m6cCGcopoLPZY5DSJf7jnBWQCJUc5fvJQQXbcLbt0h84fqu7jROKYEDi0UY2x97iIf+8H67IEb55WcvhbAGlF/v69ztN2k9Irl/8t+FJJIEWv2kCq5DPEiAW3I42I/a6v79fmkMeAgNyZeOeisaFXzm4Ee2fIFdODtN/MA+5N7nRfZm56nJdzg5agLBsi0gwNeyFbiP7c9nZ+hLmvrrGCB/gXY3WjNSpFcZV/vjZCSo3YVnd3q5TILi9rIABiYzkvOlvda+MD5Q+pl9/vBTlQFI+sQGss9qJ1/38M+rETt0o2V3zejeHqDq+JeXySEkgLZJYtb/HAba8zAceKorDzD13+zaUSQVcc9ruRoS/oTGZ+UqhTV7E8x5GQS+zIaK6D7dtvN68QmlavoCabAiBmTjXb3fj18UAV6JP+CIBAR+8Pg4yd3sV1BN1Pe1rOtDASw4nR8qgwp6B0I1VX+xKqjwbknc7PaJZOwN98D15hLKppqxqKpMAXTqtaqUUf6tP8cKXCw4D0LzK9rf+nRSEdxf7yzgvwKizct7ekRPo8sYllGUK/CnBNSWiSZ5faP21jgCyv/+na+CrdviXh4jgsHWzoOlXj0h3TLNa1pCKqCfd6tyr1dLBCY7fNgfyY8KoB0RaX2iZ6De2SWm7mpqgjHeWCyM1llBRh/m97KdD2hZcpNMgmKLID+JWsfvyI2KwQDzR3+yBXT17lXtr5elgvjO4S8D0bgivZ33blpjnEPPZZ7EFleTABqcg5eOaej+fP3NETLHFTRqMPSZ/EpVsCV3r+QjHd0fJkz+245zR/GB+Tj3eyYC55q4/ctbX0JsayzP7jF1Qn1cne5L/K3PVpHzee7uPiry/fqGvlRhGRSrduV/2d/6K9jE2wu//t4PUmLSIcZLG6iZXTY4kWrdgeYOStrc4imSsjZcStufawim0RhO3kLxvf2UG0sRn5GQuvwByTGiVujQmiASTwPNz00bD4JW8amTYbHXKGTeDIHf/Oglf6Lxfc6o3ReTRePjzMJa8WOoodJU0hUKM7r+8NAbK2D/zlemhW5l/7X/TafS7igZyDAof7+EEvXXhwBi9tHHQUPxcXSzC4Y5R6mBHFN14mP2IaTUfdtfap9HaD3XuUi5G5p/LrndH+3gT4RI4z+uuJ1WCY2sDLN3l6P2kMv1c31WUySbTIh1AxO00AqV6ArxT0qCN1RcinT7pQOj/2wCjtpQfb4njHR11prAe3mUjclgKH4KYzG/V9EMUAxdgEClnBOgAxbJz9j4W/9CJOo77YYv1KW7AdS3wPagMx8eNU7lq5Om9Tm/xCvpoBPpRBZbcQbwKfxiKHWeh4zRezJGjrP9ncEY/hbteDovnJlw392I1xLyQc5uuSpQwOdDc+yfgc0aeHc9Z+O+5F3IM3gxc5kRbz6Rho5eCf67w8tPoYle+fmF2DN+3RsLa3OfI3JfY8Ker/C7pVimc1P2C7uxK5bSinTzMZc9G7Cqigv+3q08MYvhkaC9JCOKaf3mU2V5Xn7vlR1SFyKUXH9gQ+xfOl99ye3/YuzdmpVFum7Bv7Lju6UjEgUE+i6T85lUUOCmQ1FQQUA509H/vdOn6q3SN9aKveumKtasPDBzzjHHyEzBX9s9YO+22rdAeZ0aDS+ZsAhn/ZECUXi9fJIDT6EMxCEEpwqJ79+oMTL1nISULWxw9QGjRNaqV6AKZUZ0V89rBQspGlVDQtRZw5p/pkmhOm9LSHmCTZ30xC0gHWjrZmTVK3YvRoymlL+7MAWv/Vl8bKwCrvKVu4FY2WBU32f/zK8RBzXl9urint3RcnpKaYc+Zwd/aTxtEpkHBUHolns+ANEqoGq7PrQKvxx8gXpaNTD9lCX1hhLB6YEdRdbfOkJpxye2ryRWmhpez/DFuOxrV6puCE/D+72nR/aJFau/ZM9ufRWhQruzU2m2VkhJBrbuI69v2Jqm9drzDlcVhgYw6N6uxrvA7Oe868Z0i03lzo2blkMlXB4O9+r7VCpkI1cuQ3xWZOxrNkxvoMMlBP2QdujBSKHMp0fYGocRY6nNyfRLiBJYCM1gG34pvQnik4vlyKf9pU17le2zTAAT63TnoXUMBXp/vlC5zx4+Y2fHZs3K0ISq3bVWobhKITmxcUVot0B/nuvoseJTEt9CvlYX8YRIYVn8+pX1CYkcjoaXQ+RmLQbnLrhV8fpRySBK96nFkPJF+Dc1RVHFOSM4+5V64Fa7TgacrKwoxzww/siey4fCTDwLLtvy2Z+vSRuIY38dNszuZfrT5XA7jNPtVANFneAIkp4OKDJ/6uAtvufzuDcJ2kSdAg7AoTaJwI+L4Dz4S/4KKt8fff21roYqbcGIziOLBEjs2Qskj1sPXJ8nQoQ7KvsT0ScnmwbONqUXAc33hlGvd8MXpW1Td5e9UIPhfFezhxyPATVHYXIw1tLiTxk19hqfCzFga5ahjuuG1N/XkixFFp4PWFE6lIPgTFQMld+ulr7vZ1mosi7Rrv0J+7O+M892mzo0uL+mG/CeORsIwr07pELRYewdL4mmULtwD9PkRb/ScKWF8Cy7cLvXcg0rjHZX+rEQWXCD721XXdvIIhNvZTGj9cEXgLKIL4N2U8C6xWW46BS7UK5fd9ZdGJ7+hkAnd7KnjgaBNTvb+8YXFvGm3qNlmKc9ft/ZrFr/DEj/fukOKr+iZLC5CBtJDLGKlXN5weuRBDJ0LZDkNn8n8XnzzMO0rQwV+7sWCNwWDjm4DjYNnfGuKHCebKU/5c77/GlVuk/7gSY493i4Wc7TKJB4vRE9YNdbbNuMH+6b9bWB3XaSD3NhmwUM0SM8Bkl8woavNathe9uqsMmZWzTsJE+RxcvS1KNC8lPqX1sZ74fdBFHOuo55p5xQinLrMRJGusJef7m+iGSZ9zBs88149DyblurT4ToQzchif6M/i43Iy6S+oy5I7tXLVFAlj5TQHRuIfd511Fdr0w20JxP0p9bFhVxuFpuo41Yk/Ehv1wtD0WfY8aaScO83VCIxtKfBwLWIHcG50i9DLUTYh4enF79Uwu/cl7yZVVt0sLrrWGSfptUVdoehqnXZC2m0pKZgr4lk95kHI2d8smlZcOKTy8V5+iQ/hHidQZl/v/HdlcIXetUeBH99v3xFs7KgHUGq9aVO9OVL5wasPc8OyDnCH+9ts75TvRlXlsUsR3+tX1h6DLrOAX8wc5mfq4U6M1XX7zle8Wmu5re66gsQlCt9C0LVZALxrmurh3/XY38xZb/wgkrEwPFObDvwOdFPRD74y/H21ifpGT4tPhNzYB6r6cztBqKPLp4TK5s1n/v06jny4y0UUzCrXh4j6ba+g5WkAzwZ0danLHPabree24JtGcwUnZ/YQORtnqvvU+b6onEHihKUBP8DZ8UZ0TVi7yIJHmmWzpHrr+vIzpPnnaR+QONj6qv2eAcjl1Rz5uk7fy0iglLtNjWAOVebe4oagh8PuW9apWUkn6auz3idc3wL/GKeDpedO8uUePb47fmZ+T6LFAIPwyA4gJ1rsswaMwRgvPUIWGK19el7JOBtpZ5JNFaeSlc2vwSUM1gzgTX+4Qvh7jKuHheP6PeHw27U+bS5g/zyqmiimFifNtJCqhTJGwE9Xc7XNb9lZHC5Zuc3PQL+pHBZsMrScQtjbccKusFIJL6v6/evFPWrvw4esMn08erC/tATvbs5UHdhvzqMQ7suPCyr5qh47YHkl7YcNkyjOlQgmg/ISRypPtjD1aU+PNHWhecbO3kLXMFC3vqCrt6uL8afI4spbe8MaDDVSS/m5ydYBBObplHsWh3LITeVVKFgwi85+aDpwSwpkrqbzcP6Ge6wnfJduGUJwYQC48ohc9wIMuD5aSylVw6x5Ok3swsueAWD+PWUiMgDASV7ARomr3CxXTi7KL3eJwRt+2FNB3GDFEQ4rXwTCHnDevtSrn6okPq3SiJfuC+sIAt7NPfNqa4mH9w3hyY9jlsEhYSV50nfUbLARDiqcOscsa0xTC3n49RB10F5cdsfDAVNDqvrkUTwRxeTAs0ZP3Mw2d3Pgdy9VFpy880RylPF+qstFu89148ufNbiuni4k0HLcxZpza5Mr1jTNZVwiJ2swrZL8PEGNlqIvN35dN0Yr42/sadKKJPTLMJ/97ffX1bbjDN8Jv5qn8x9vi7XCgiz1thz3RGS/BzMxcirfPHBfHZXwnonOtR9D28X2e4zWYT7Z+KJ9eHmg5ts3rhW6ApAQnn/bHp7Dqg4VfyqIHjvr9GzPL6o8JWDc9gLQVrJ3F2E7qlcBpW5+csrGTT4IBwaiofdXXMOjEjqU54YkkTJV3/xPN46KLdpgkvkKkPRNwQ/ZrSBur1/9f6adXY042x9Ir/71229hq64CCTlg16Qrd7vJWbKF052Y9AKxcs4PAhKg0m0wh0VP9b+wkRh0wfpi0iK7DEfkiekF0o1KOaVxLLis4173pqnHcGHfqdczbP2YIN/9j8W//0NSL6kJNEB/9k/L+XNSuhmh5Nnxt+UIrMOCPhB4Jly8TQtBt7BcwiN8WB3jD+Nl2QBzO3mgI21v8UrXl8v1EwkIuM4keJvsq0/TQAQfGljJaH8OCD+87v3iUBs73y6QZHLo7MfA8Y0H34aPwh/JYrNkgbHt/yZIE2V1rcuB+t6CRQ1eu9PaUm/jJk1uD7w/YTr1nenJvgPrvY0U6R9do7XB7gwmr+p/El6hp6QgnJo+65sJoJfUNw6jSWRPN4AB9rzc+2GAJaBUxkPMaLRYW974mI0OZan/GgDIKgIFsrxWSr+2i0kr2l3QNsnhL8KmE6IuHw0kEgTbV1d7SiUnXnTK5bykLBZe1XCRnV0hkfA3FNxVcaK1EG5rujTPsYw8TOEzopK+DMTmMxuvqUh0k67aX4EpUzySzXo3WVa9u93sJ7v7hR6hcSAyZAKtlcx2trrscw5vYPJ+3Utavw4KZLVXGhlRNwaI1U/or3OhAmM6bqgw2F/pCUVBxsXeiuAIZ3SrrV/rSZI1/ra1fXWV9DhzCRy4pUKNpdcLEXJXJVwf3Lia1fwYSgD+3R+3vf7G5YKldlvdun6SgJ30k81nb7fv58I6oYe1AW7QpnXRppHCdyMQ3Q4eLsTDWFO8el1373e3w9tajZrDgm8niRQHA5KXECZkFrNjPYTtsL7fLvnWbSF0skartfII/13ne4dr0EzYFdiZ/Fx0IozFEs1uqnXNizgEXZtOpZcjv3D6XYpJevOweCY888hggdFyjJCs6tVSfT5agbWcLsf9tAcHmsUoesxlMw2nMEW7mvy/PM9Zspy//59rX+iii19IvNbuwNixRXEkApzmbED+QoXSsGxc6bCAk30aj8S0udgxb+2BE0PFVk/kQohm9o+TZrzhnDYuTFW+P48358aeb7Rl8rdqpECBUrDRrVDhquw3jyKkV6ljz0sp9Y5kwjYF9AUkzJGWRJhTfLtbljwQjDtvHs2G/nphTApYrfTN+INqz0NNfpVrkTIlcKDCx9JEErX9/eTQrWUsFpwMms1waGELS1shSMqD4W8n6oVHpzrHbtBmxPxwGtbyDBJZKMtOodyuCnledlsC2zOL5yROqOW0MArotf9XaDIDzQ+2m65XrGZXp4WF6F9CavjZV+dyyZQJDwUVVCrjYk9o6vTCacEU5msoJmdnh1CxLpDZAvnaYstXUvXy8JGCI7d0nMRD+IQzsZzvC4mprC2UsP9STLfpygRoIOkPu9CSL3CizYeS8KfBZe/Xus7rcKtX1RRAjAOJaqIa3zUOgurOcNc6WQVTLCx8kWc5C5U5G2WbFsadQa2vCN/CNdcaEL65fhHU3gGtMTMRvYUF6RgR7sk7zdGFRxM7bRA1EjyA2n6svY1caqwN1DtVj6f1ypM95RI8OIaFIjut6N1qZIAm9sId5ak78+Q7aS1iAkpIvyl2XOpOltH7EV9yiztxlyR+Cl2pIh3VQiZc7+702hNBOhh7ZeKFicr2LnnqX22ahVKkDqJ1IWZT1jiJs7QDbrpIN1fG416JQ8acZOwgXdW8rGzrE5wxomxgpGk6Lmq5rWCwvf3u6ZNnxH9/TAzzwNPBPNDM3MclAsaTmwwIbR4W4xkQN2t28E04ZMwu3B5yaWCCFRvYZU/A6yb02tO3ff7q+3bYu7E4P19Ry5ot+2NP16xnuka5J6lZcK4kuRCIlgQym532+CYv2Fsy3ThAuSaCLblleslT7zTElueynAHH1vsi0Oxk0zfVKHdKPaSX/sihK9ICVf52tpimJKy6x03mwRi6pbvhPupCaWq11BmJBJpn3RnIZzV5xVeffG+EseSzN/RGRgkznOP3TxLidvFxIVJ/wSa0tplCAVutX4B5tBgBarnvpOj5gp7oia5NTJLWjLnQ9Sl+s3FaL0XH4rhvL+Px01qiTqycPIl2I9L1jwcon/1Lr+h9u3/TJdFehcRe70kmTv2vYf9nrfD7NAQLaYbOCynOG9opAhakA6Rd8fGpF4kyFQGBy/buPHwfK0VGPNG0j3YdYtNQUvotiwtUnIWxlsnjvQqJN08B5JF9S7WN/exYpJLzMFSzY042+6qAmGwqpZx9ApsyHveXSpnoxLQcdw+OJ7J8x81F+82/YHgK9LFJ8OUzy00sQvVU8u9CqjvDGHTB7sXlsLNPI+aTeZ/k60ha8Rbo0DCC5rrnTgLa5p3ie5P+f190+2lXuXz+/tVVGCrydZTeWwfNFHQKIsl/BzWy4zIOoXy5S6Dtc/OGkbx6XmkmePThDpUHn2HRvL8Z2ZvxPfgeMSyoAvn8aAlEywr866vytOtkNt2Co5wTdbfYSJtPaw0vYT+2tmb0YW+EPxpC5QfmxWH5Wo4NEzkJyq8aGEkmydUKPB+uwV76vF+/2tlAioA0bGD8Lg0q6DbtwTfRr1mrK3XYmjsnmoRic89lKUkYfPr2NDSCe54Yz9sZGwBfq3xbRwRgpWZPX08MY8C6Qz9GLvg/f6pU/hYaXzTuLBrlrFjjXtF8m97KujXvT9jn+nHqg9K8nzqbdqQJklDwxrA2zxaWvn+Pq8+9GNtJXAL78k4ymeSX7tjbLrP+r0/7FfB5ZlXtQjFTcYta7G+0nJRl40iOiWDXWpyKFkf9Su8VfE+vLFPMr9HegoVkX3ssTWuwUaUnuYVbmlrfeWgRfJnu7H6Y/d6f1/O87MiZAn3h5I0DSAzgrKAo3KgzsQpV2zoJH/vtnJU4ck/2DO0QU3LqsK2zXRb37BxUbx4gHeTtJ9isXncH8Qev44UmPqbiW1mauT+EBN80HzJzZzSLBSkGHtGx8uD2J1+3o+KHieQeyT92d6uchql/f2e3wKVxcqAEn/rbqIrjI846rZtcKHJQnm4vSsNh9G5pnO9GKsOvveJSnF3LmkkHyvBgQ8vx6rYXRiNuBfBzAvUi+8JTYgWu93vh/1ui83evNcPNHNnQqBZR0rj9FGQUjfYKHYf5fuFGIv/pHxrDzc8PHPsmqwPVLqOt5r0UGAILvL+5qDNHj6fnYMrtyf4n3U7/kiy7Iw1REXBNB9Ifr7fsludnmeilvP39lucUHfsXJXmMLVHo4Q2utpbGui5AquBDqsndYRYdvUaDmRZTWickW+uxVdG4hMX9tCr6/f70449BJs/70+t9/yon89ZITmgjsFhe6WwE1evalc3xD+d3W3Pl9VA8luPDzxDSN4dI+61oafDnXMhz7XO2km5mpYenno1t6fNm1/b7v4u1mR93Mma/XA2yfw5NTWftu/FGGlysiUcNukgopuSOxouyW/rdhXvXWdl2E35otYp+YjgNRBrtn4+6pCI3Rd1tda3O5bSu37eGu/fvzst8pNmvylCadpkl2XoHwjL/pB31rUwEDxNlR2s98qFhruZSTdh9v4+wsk8K34fGVdoRG3cJaf8pqC2WZkx/1jb2M9aFcajuTHhXcRTFYz7WpFqXhHE87bPMcJh6JtK9i6cd/Ui0M86p+WBlERpiEl9lyfcLNOOCDOoHLYee7HvBS2321nwoysVY5XInlQvViS/H+ziS3Eskfq8usWAjordBXux3WE1kJMSqtYahXXpl4R/1NsOR8cbwTc2vtGD9YhLmKcqQL6g3ULpwMTmqTqS/FHjc74SQqqeIIjKYkjt4kpL51qhvWWidOwJozs/DkF1helpcqIb31xCqL+0UzW0Jk3qm3EuxcytEFzHnAc7+LyGcMx96XqVHyr2ZAKBTsMTfbJ9UFXMbjdJgWATPkM/bQDWWEb3FTDtSX4dPe9+6+WYRkzf5Dbeux0245fK7utdvIXCYVLD8Hgg/hOcOQfBzfSwbW3dYDe4+wTW6YPmfarZFfB8L53kyJ9VbK1d2WHGi36Gr8bLqItyO4coW1F7S2BWpP6pUmb3UNnv4cXRDvJOWyLCj53Eq91lmrEGHjUB4eAxwYk5L/CJxSSU7LTdrdL9rcRStwdH4nXCz3i9vfDnIn9/P/7KSc0xk1KsgwBhIhAJ/lkXPggMc7nSKH/u+NwMewvL9ftzd+r7+0YvbWoyXt+eFGS1LnPbViLRT9edWCwlIPgUDhLXmyab0egWD+5kJ80K67vQkqRduG7gpTsda7UPEkVeOStEPzR3wgS6Gb2FO5J/RempoSe+6kKOHXOT3q1Nhh19OopNAC1S3+iWi6hpPBeI3zizHuJmxo6gq4fjS31cYWdtjZh7rE6FJL84zkyjLYUtwy9fKnqS+dmv50vGW/GsIJxG6XSzXAHbRhlqJfeIXUjlcj+OA0v8N8B9NyRh834/4bEoSuFC9EHXLfRY5VJC8NGq9UtynkoMS+00GmetvMJWwKH4YtdpIeEsOLT8+/1G8ChPzzP/qkx42FzgsbVI7MpdUVusbEikfuwaXXmkOuEHgvMqbpVaEfyArxcF95f++r5cFe1de0/w469zEo6qCkL127I4PL0DlnIgsJ6z5RJYtRS8tN2mLGTnPpbSZvU8YQ0uUuO8OlL/AomGTq5IpSJ7G8sUkH8JsKbL9Nx3BeGHh/quCOt8TdrvDrc5bylif78RjhvHTaNCytbPD+/hFqF8VJJb/HAOOyz51AB3N6oxIW8M2UkUslKRHlnkEs4xh9i/23kfQInbQvcSHyXu7BYF9CNhwAlxD0aN90jaKiD18UYfDV/pgkKRlceyZ33x4WOTAXKCvIMhwurAmChr3t9PmbTzlZ5uhB+RdM5nlqvJ/HyP3iQJVZD6mu9kZtOdbj7WC3cfj2ud9F+15snZ0mGhSIeIIEUDZmKnF0NWx64i8d/MwZJ23UWBN5Alq8LcKViOYGwa5bEu4WBuLjY+yTnhZ6+RIXVB0jEy9SM6MIgt4f5aCqERX+8h2hR+deojzcGwnYR8BQtjgjenLPlEvr3fP85LqLw9ewWj4WU7mOYijvzRs9uNL+eKvJim4FYMGR/NK/3Ijpmxh1NTjlRUEX4pmbC9DOv0omA9fpVY346RCEtTbQyK1gn+3a2GV+rIkrECbumcxWK1grft9sLg+Uaej7vPorbZrVgsr/nVZreutASevHG32vdjVEiH9zc+XUJKsXzIS58CyeMMc56lrtAyIlru0nVvEGwi+KOJD/6qEdwg9WX9LNDllRWo4VigXJ9PDTspT59A/2I66ITsbFlVfCmkomWtfZ+aApYRn73WVVir8Hy7hnm6i/MQ7Wz7QveNKmIT0YN9vbvVBLc8M4FV0L+/H0vohqBfDhZ2y+SRhDfVIPyJjtKwoIuchsLlaKxyYzax3yR03A4j28BtR2pxpfVEvzxxshCeT5H4rlfVw3kl7+/Tr/deSQR8Hkpu3iRFCkoeO3hD5dtVzXAQPej6OL8UUn8S8XZjZseyCL6m2+Ag400DO1WV9luVaHuozwwdOYQjYxgcYlcOwXGCVHnE0pyOT0Xq6+ZF2EHfYHeLolzYpVYD3aFkJrqvnwq6v+8Su532wAZ2gw1Fe8ctnE+FbK3XBuHH28JMBu5FPbAuJHekmuzThYSjnqg4cRpFviflyuglrSf81FrscyTxBL9pOuELk37SEt/wU9UMhwzD5Shup3nDdfD9zQK499UylD2/iJTdtImxQWBbu9tbwg+fxwOnYgOVhJ881p5F8CjAFr4hsz5A04U3lnrmW8UpCxSQgJ2U9/vtvKe9FE5lJybEx6VjzGdA8IdSYxrHKdEnpptoOolDol+6Z0CtohOh41KMVDa16DXp/zLnm0OXcwjK555/jq31oMlSe7eF9m8BNv12EsfTJdlDtE+H8/nIEP3X+e72NHqXPZbw6RD69/f7jcC902+4WRF8e0mLESSDtv3r/XIpEcYuXIQ2OubuluDD7rRq4TJdMHb+3AnsIcGPzmVDaoTBvZCNUAW5IZD8tqvXgVv0Xe1COS2KrEUG6V8eg5K6EPmHfTDcYLPvTBOu+MmnnuLrEcrCK7tf8w3Rf8apTXPpteFMiFZb83VdbrcCtv1wONrlRsdSYA74SSXv+0/CrcHFTbyGyFBUX+eE9Y7Ur7q4VF3ZNFDyHZcIaIbwr+60ml4IUlfif5ht9pcVy0EBlHPr3wnfgtb6Tj3P+mOLtWvuTwIGBL9cttlmuroi/EiMV9TsHCSI3enau6J2YhpY8fedkR5ngi9bcWPpu80NYoO/kPqr0YR/m5gumFpe5YQfmHq8E9v3azBloRqYsx6rkOVQHR02r1sou+qM1v1EEUkettaGKB3DhU2ZhqPCvkj+Hv3DSrY2moX1w2wv2xlWHKmdyzGy2jhTZOH9fkJnJUkYjnp16JaW6IPVWXf4CmtEPxG0dOo6KkX8553vVt4+G3hHJ95sF+P9fgI6F+gTkSoY9RK7WMc90Z+n+eHQ/fHyCtHqssHpRbw83x8Z2OxPZ4HY86gySr1LiH5SJLeSQ/vQYOOY8YMdXY8rKCy5834vzUtBWeCVvp4cauxWO/Awl+CE4BFcp/tmTtsCcl3gOtz58sLKMa7LcV0ez3B6CJa17BuiT+hKNpg5Wy9YhWV/Mo9FQpB39ov0+uIe5Pkl2wzL7bzD8i5KElI+SXw8z5LV78L5QUsZoXSsyWoJdlU3vGyjbeLCkhlS5QarOpQIEa3ddUcRfXLY3Ssr5w0Ogmv3nGvc3UPpHtTPfCMeEqxjik00QjtMuNz9tRl67+9b9/wabZz9zsWG5W5EQNBmBd1te0SpMDe0hJD2OmyaS421MBsmm1eI/xL2NVxuTtgU6Cbkx3i4EP1oPmVqNUOR4Fvb4Qx1otQoCHjdrjS22h1bm546XizC1WBaq+OzOC11KC8d8Ba0OpDElfd2OSseJ8LgzJ14P2Trv98fjdRLTvjRiz1g6kb4b8ZcnYK59o9CfojUNPjAumCfp6tlH7EE/+Ko1JSz7DwU5IYDPhWH+YwNNTPoh5EmDfzz+8TYbUtaGjxxxXk3L8Ver2fHdC0QfuXJrSHYk1f+/fvaSruR/rGggEM3JStIoV1pxaJI2nMPoOunG3XANtjYZW+uCP5ofVC4/onkr9xw9WVNS1ZO8HmHX/ea4D1MSiDrR+1O5hcfkzkavGOCFTtmhNvMJAlEXl3H+cKUCkqL3F2/js8j1pk+4oMZN1u4Oem7XdxSRH/RlPrUmhvRX4h/mO1hjgh/eiVSjUrpQtbXvC9Hb+0R/iTFL1q+X64kPsRBhgd6kO6KRAB76KnHsSD6FjwSOedJfe68dHa3JSD8BR9wF6M14Y7qSam4zKjJ858UPMr5SSP6d56hbbvN8Y5N/eHayLuS+vU//9//9b/+h7tcjuJZoC/HM7cRM5o9ntbp6sxuhFS4bHj2/1lxtMCe/+f//l//7/9cj+2V/Mf/cRvSfTc3l3cTtayP3YYlPPs4v/8+dMX7z+Rffn2ruvb9t7SuOgKt77+f7guhHufAbP/54dOELZOlXMrQlQau+9o3jMPL+rSrBGiespLSv9j/+QlVCVnpnlY0yYZf7PUxIgxuOBrph12ZkNSjixg2hGS+P2NDkvTTbmsnqCHjEnZQSgeeoVTW+Ozf4zboIasM6f/f+UnCHabQEfMWK9SdAiD5LzveDR7AHNt+zm9elGi0Vp4pQP++veQNa/Sf9g2p3oaZJ8YvzxcSAottNjAdRFj1AYYhO3zZkSCNSJ/14qO98TojKMm66kLryvMZcEvl0+4fGeTBTFVNWPq0FBu0boSf/pHXcA1pvTSheY1GhmlCk/6cn1IhRfZZ9Re7q6TgLizGagsTI5ZG/1Brxc925yXzGX+spc/xLfoJZ7g1yfwvh4HPJlJTSek9S/fcuhfPz/b/ji/vqanI5zRtsHmZiVsLZe9+2JFLUy2AulN/ti+uhUX01526Cz/Ob4H2KmN0JNEIID8BzyVuP+3bMr7H6KGZys/rt6ZiWEN+Y/xi/49/jH/99xUf3eJIrMHujC//xms0yquB2H9en3/b/2jXw4dUS4tE8uPDP4edeMlQmfc/t0fSZYphX8c9NhsKhUgvw6/+G8NbgVwSeuzrqcgAWBbNz+M75x0lipFfdFBbh5KB5sH4jA8VdEiQ6xfBD7SpQCWI56/8sLwMIDE2yfr+iB9Oq5H1r2kSv2EbUMMmcr/wwbxPUIOaoKo/t/9YX532N0DYsOpne1LpQEaNx5JQ49dC6ezhZTg/t1cPsZ6jlacIH3a/kmAsl+e9+Tn+gi/brDjXDaEGMswl+r+eT239R/bYFl/xiw+pxEJZMVrZaicWHs/4Kz8+2q+XbQM3Dm6wJNzAVRyo355fNQcgU2K6UmEbKVuSnBT4zA/LuSINBu9XMz/ugslKuESf6/cRP6QKu6zhYvkzvwmLlCR5txD7lRcibJ054bP/j/Y3KaAZsG9Xy+f4Nw5d5ORVkPxoc8Uwr9NG/rBLvi12YHci8X2ShoWh+QZ95p/b1JKHzAeJz3/7F91htPJ6Vc+f/d9ftRxLYCLz46lxzqd+nLHRncCJ0qnwCh+pXlasGwNZ3F+GKsNlO2Ilq5EDN2f6+tPzfeWXFC8g48EA7qLZox1UoTJjB3jiSQxD0l7rgn6ggueHf7/aw3EQq/GwUn7xf4Xrba1oEfxcX3m1EjsqfNElXOyKYuhdyJ8+/KfIT/iEkknqc2Tpk79KTfTZXm9C4Arbmvj3+jSk2GqUzWd7eVxTlTgfSHyoKc/p0zQrn/lhPc8knvB7/QnaWKyShdIv9e+ff5z/Y/s3fsFqM2zYUPnFnm1oBO0jq/7S/23n89EszFL62b4d4QjdJ1mfy24BOpjvwolSBKoDyQbPWF+u0EE7TOLnxKRmrKFUbuFdGhxwPsMRy24rTmJ0Ie23PtZGRydlHNXmcAGB75D1XweSJ9Udsb/4HObu7fFV37WGBov42rzz7xxxwzL76qddqRywBRNH7Lz0/s1FgrRf4kNQ38HXGV92586jB7rJdAf7Ow8yDifKL/Vpm7wEf1qe2i/xebjlKFcE84NffNnddaqw8NRwn/GjqzM8EFVKxr+cY9lwGFr8tGu5BziR81YudIG/yaZdL/2C36+9z0Uzsyf4bSwiQW2m/qrfL+gDZtQCsn6TtBWgOca/4ee//Xt2AVukGcoEew+I2Uz+38/6oB8d6SaVdjjB+1IntboWzc/40g6qFEqDGq4++kdPRpwyP8Ut1hQMIoD2SvdLfbrQgBc4GHKf/FO8+VcweOMLG+5VuiFNpkn/usxHq5rWP/HPebAUI5pgj36uz8aCwF7g6r36Wf+j83bK41x5Ya+4wlC+al/8UIqiSYBc4jR/8UPko5X6c/8ydwYvEcUlgtfJFv05prVP/xjOWlxRcHzn96zIo9I1X/npjw6Zv1sT/N5eWBXb/KR/2tH45rfSmeATlUTCsLIp/dN/yCBQi9SK5Cez51mGpgL9f4Mvxlf+/2ufT6kEDbfRfrHXNa3mxm2lfz6/zdhwLe9LRYTXuRKYxczUr/WJXyJHGVgh6zswwJ/a7IufG6cnYAT8vmhtxiHMtQR819fyBTcwk1e/rK+7ORI8uzSk/5/XB8igFJahmD7Xv7h2RNLGJL6k1QGcRfuprD7t8m4+QYUOn1hfZVQkRB15PnlXS7lR0MYn/9HEuxgIFSzEn+Nbf//cVWpsEh/Qe3EMX4ral706wBm5NzJ+ZvkiwyTUFz8zlZniwNjTIrzoUM7Vgf/KT1W2CH42L+Kfj/EJj68g9NMndpKD9ECeEX7OT+4D4GXZRPjVH/wVXgOZnxnGiqEEr6/18RoDxWikiL68WaFUey+gfvrXfzUoRXRBf/m3UnI2F2SiHw3BR70UsaR9oNp1JHjTyH/gn5NvoIAUi/DHOc/EbMPZ8qd/rVAFJ8G0SP6uz6GUwyhXvuIj2qCDVFekvk+cPQ6CJHzpH5MUDkm6K6UKo83SM6uRIuv1r11xaPC+Tkf4+7mKFagCAD/9659JdElLR+wnaIsVY66+6r8q2ZCC2pngmzfJw0CVtvilv2xVSpGYk/hMDhnPrIcjb3/yw4yCO8iqKoK08hKycT5pX+uvpVIrx+/xR46fB+HiSZ/5ZRSsBOGgEPwdVqk/KsIOfc7vT3zJrk7wNZpqN7eH4Cu/rOBC6eKmJvWp2eT66ML71/OZaIVqaD5IfQDcqwPcGC+vj/kbu1QEYILELrN8WU26/eV/q1fRDYoeqR/Fq3axtrvQn/zWPq6knWxZJP6fHSj1MVmBT/+ookL46OU7f6FvQgVey/aGZWsg+mL0yi99fBahDp1rccXqKifrUwnf+J3eM5A5p/z8WR9rneeicbzqCuJWYM6KVZz/rM/RkaMuGRaUZoT7BO3kwla/xt9dsZnnI30dYW0CXhTf+uhjfA1jGtJHuhn/1kfS6sv+jz4afxxfal/DlD128W10LQl0QnH8Gv/f9RudqUWWlDCrn/c3fu7/w44UHV7g6l0/dxdfGJg1/cnfRqNN4UEuEel/Y/A8I85f/G50E1K45ejtnxPK5dG+7nVavggZDVSrbcb/zf7Kz/OTU/ecZipL9+Pf9XUOf94fGP/zX7/sH4zysxETwpfor/2DgJdiIqvzfnQXTzIkfvnS/3Jib1uo39L+5/5lLGYVqAXjOf6ND6HytX+QPbIIgJPyGtUtJWmQK77bA5wP+UNvn5/9d4R5xroqmiHhJy4H1nbeftq3Lq0b9kE2Q7h73wng2HD4tDOQp6I5CI3/rX+kQ0WVWZrWz5/3T+TXaaygz6cv7BoKukk5R3/tr4zP2zaviXQa1n/FN/rKT7l+fzh5Sgp7VMQCcBTDfOWnrCt5DHkuDka/f1CdeDK/97/wGW7hhZQUbL8AvMmztPrq/+r7EoBVIWPL3oCJUsTyi/9dM0K1u4aVf9l/2zJYz2nHgJ/xB31By+WK0wtkHfsuC5rBHsQf82d/z7fQWZx0/NpfO7EMv5xJ/DfueM45lg0+7cYtRLF/lw1FDmzo5+4xx7/Mz+z996YAW2NZysVOXKbia32SPaHVq6Ug9X/Q0UZW26/9MTko+zMY93T1y/qyL+qUtYVQYp3T4QEpw9f6ytqIHtAdnAe2y4PIiVVK4vtz/68c5Eyd4+fP+4Mo01APbSL5fhmf5/w16Pj8/ot9d8C3/GYV6fgH36WK/pof9Iqsz8asDUeHiMJM7Jkv/0C/Hh5gLtP45/hHfeG/AHUYk9HitmgN8/nbfzTIanA3jOwXfLkFGZvJTXEdjZqmIor93j9EKwVucz4mdrRaQ0Uqm+/53VnoQfpWb8cf/SfvXqOXdyI+/GJvcY4hH6aXX/AJqtkqy/bh/ef26E0zwdZlb7/gQwXOG8BobT1Kpguugtd94a8U9oR296+0GI11g0L4mL79m9sQ5zcqf/zS/+YJN3mmO49Rj28UoIQi/IwvVIHbDhbcd/uP+FOhSGVEej5/6f98w3YeqCT+fCGikBi8vvXBOSb519BpgbUTFK/i6Uh/6gvpXoExO3g14Qejiy7wfCg/9YmU2B4LnJvyHN0SIUverL/siDZHB1KdchvVzCD5dTW+9Ks8HQYIrjh8jXZiU4N4zYj++LF+qY+WegnR9rt/nR422VmKr6NZRhBLbFD+rF9HezMQvmXn7+c71xJ0KOdzf3+04Qo66HB5/3S6xGrtNvyn/htNVif6ZLv6fn4x9nvQ3FJ79PeueKKY1X/l75/45UZ5dBmLykSl+qqPyPAGBaTrFzfwYSG+qB39HV/2YyiyZ5Pj8Q//k8flq7283cEnzEAq/5IfV27YAVoIvV/iQ1X9Ojuuosc/BfS/8guOt3xuK/BpfxLOkKPDW99OaSZkJWpvP/MXdG36VXYIlHbUTzaqkV5/6U85km4J3Aa4HH0qASvK2xU/69vR2mAoyFL7rb+O1u4A02dejc5OoxqRfilf/HkItnouynk3/l0/FNJeHDMQCf3jU/+NCmwAoIq6WP08/t/6Ykf0z/2WUWDd0J/nH6PqRkhCT+0rv+Tt7cKAc6Xb/qxXIKLS1Rf+SXwA1ll1CiHWXyLB3/Q7flCVjXdobfTJ//D/R3vBGfVcmkiFng6YKHQ4fuG35O5viOidYPb5g4cu8qYtvvClvuQy5J8v3v95/UOQ73Jdu8Phx/HRvB58YAS1/nP9ktjHMICpb30MTcIv4WX1Fd9yBwYqu5+d3S/1r26yBmwC2sRWwYCGurz+i7++4DGn+zrEhp/BHlr99/nVNQRUpkQwwo5nSTv0Wuiv5+ueGZ2ZR8H5pX5Psz9lYevsfzlfG2Siv9osTH6xy+z2mFvrtBn1eg8NNByIvt1pJzEDYv0VP9ZjJZbifU3aXzye9zfQ+uKvdhFRC1CZb36tg1zJPW08Y+VwBLKQPr/H3/hEf6Dtu0r+ND+Yev4qm1Pjin1TopAwf/MrwtiJf/fX8ILdJwAqBUr6i/9MDEZQ2rHnn/0nF7PfZiARbr/4Bw0Zk9kcvP+1fpL1+F5ffJ4aaA3pA6upDl6UHBH9/mFvb80jk0xr6/PLnWLEevnaP5PzTe7C3d0JRu1Sk1jTM/WrfqRxNmWnoQ5G1GJowYX96p9QehhCW4OEX6gUZYvK9G1XT7kFjZOPfXG23885hl/zOxgeUUhRjbAkAzERh8tXe8kPcAUFhpVGsw7FK8i++5fkbgxzMcyTUc90EYj48VWfYUoRxzZcfR2tyw4eJQt94+vNyI95/RAw1tRA0tCx+56f5A109rrGR+ypDymXpKn4tEOm89lMuBYJ1p8BJVN08TU+qhtPBAUO7f/wA/jlX5lvhld2EOEOo2ELabT9r/1l9jSqcJHgDWvVGtXS46V8jZ+rNxmulaIY9a0IBqFuvtc/gLmVw22cY4kJxUTAiP7C70nwEVGoLcL6+iKeKaI/v+qHiv11Zl9BOjDCIIXyZIRf/gMqyDN6rTij2xXUXgx2X3ZEvJtCDrSEX08RInpd+Opfzsb8CF2X/Ue/Ud/7O6tgtmA98euBFH8SX1f9i//IGzAOudfUMobiBvgCrYXcj/cPPuv7K2PECGw+7y982f/a//asL/7z2R5kAgOez8/93xFtzsiAtKu60AkMedQ14/N8f/QO7/O1p7wyf9wf/qs+wuf7fP9H++f9jR/O5z/t8nuxliP4PF/4T/+rr/7RxroUWaA7r/HP+T0sva/z+X/vl3yNbzgy4cOm0UrHRGwzpqafX/p4lypYES21ldbxDecz9X5t47/2n863Pu2X0pFjZTjKn/7/g2+C/N4/e1nvbwramfxZH5SHC1PJS4j+p29Cwnph8Xm/arSrGHTC7a0Pf/SvAm7iShRSUh8jit8Pol1/nm+N+k6gSmBvi//wm+fha33lmwY9OTZJe3wvlNrL5s/9+c/4sZOIyFpW+Zrfh/3H+f1oJ/jrNoCAcvuL3VE7Nlu6tB21c0Oir3zXz6MVDBmn2qYg3bxsAlzV9r+0p7bXJpd5px3d+wkSkffeH//Zf5YPOOqgk/wNGQERNaDrn/zRKBmkoW1P/P9sGMrnpPBrf+9jfG+fS7UtvrTP9n/OH2H5vl93DUM51+f5S3/8Ob+D1wvhd6VqqKy/b9Uvfvzv/Ycfxv96/kjThWjNx7qChDrf5q1ajH/lN6JzMsx64NmBUsjzSbTv8RmHjXl0pQuKYX9RrpCxFHn07o4WInZ9tXJMpST+HAQx3Fjk+VXGFiuqXD7vl4zyo0OSVL/3J55ZjrC/dJ/3H0bJ9tFBNg+kfbEfJoZeWumX/bvMU+DoWl/340ZlPIgTlXgkPv+6/8Mr7Mf+/GhVLAxlgX7vD+ZBH22a+PN8ZCSVnIooeiL+l+Q6gDAdqY/9+y/9dFuGjD1n0uf4/nqFcjnekPV5XJiJGSmVPP9jzF85JeTzaIuxpMDDQvwrSLLAcMIJFhKdjFr+FOpxhHiGFxQ24fWn5/9av1YpQhYKHfXv/L/xX1GkUWVCJZR8zjey9828UZcsKhLXW+JffGJEZhZe7Onn52O7TIzoYL3mf+4fMhk1MA38vL8wIlUDgRDvCD94hDrP8Fr+Ff9/718PRH9dqBRh91h/np/+lb+o1En9/ze+kSiRoDdKdv6M72DvoFxi0Rf+29sKHuXXQVXhzWBl6G7yL/xyhwe0kDeV6Of81ucb0qTxfX/qwy7utoR87dvnqAkOTNGkqV/1a0a7B7zMynP0Zw+2yKDVX/pX5hiUYvg+H3U5ngWbrvk83/trfpJnkPZYGiaw6MVXffBcC64ldluqsN0zYraeTl/1+W9+ZIU/n8+O6tmSjjCF7/NjhtVyc8o+z2dHKZipK3UTCb9hc+GQw3HzVR/MvpRi6fC+/5ATNj/K8vB5fjv+ub9CTfL+8/mlaz/6sD6Q+vv3+bGsfN6fkFySNJBXMfFvf4IswQ8yfzMNCCW++/oXP7kWsIXNkcRHlWd8xamS/lX/bAlZMOKJvowLWmfd46J9+uczfv/+5/N+wNf5Q1Sn2GRN05HEarZyMxy/zhdOt/oIJUZePs7vRvMpwiNsDMIvfrqf+ln/a/Y1ZOKVEnnhHl8u4DgUX+dDThFsIgJUUiFRJGmA99aPH3Y6zfiBbbD6+fzaiAi+tiyZX6oMoi7uGuWX+qp5QGDWqSt/rq8GXKRBf038h/e6MPDPz/sRJD7KO6VSCUPwja1Sw4DdUfla/xQQPBpHgr+H5cXqE7gov/g3w7kKJXvUfrGfL9FYzSmPfuEXj9hu/DVhyh/n66ORNsAV5oXMPzBs1h83R+YT37xUlDz0LIh+Puo1HD1+A7/6P8YwRtp7/6C8B9dBMCPKFjxvlPIiN8bP8QOP5yLWO8N/4+tr/kkaUfqUT9zn/KSnBUxQcwSf/rpfQuL7c3zDZ6gBnHWCj68WAJ2IjS/+K69z6YiOHKlPdBpL2Nkt0ld+zldqoLKe6CN1D1HsZv43P37vn1LRi+i/9lFRGZB79jN+XQeKnNA8Sftb7aixGlbs63P+Wg13aJMSfe2pQ6dP3g0sn/WzeolXYcOR/LypJLcMQ/6Kvz/3U6hlRfgTnhWHMIBW/sK/0CeFsQThBKMR67G+f6mfdvs+igNYIaKvcLQUYPbP4LM+GwcFiNTlVZD6cw3W+gpUX/wZXVORoe4z4XfzRvBz37DgJz4o3URdBfW9/70KeaDTtyP4ii+soVk+zmT8dBfqhpx3zGd++4SoqgLSiq/7YXGLbbhy6tsIqxtVUT37rY/+OZ//zG9mzYsZZ98MQW7u2MzVYfzaX/1oX1kYQ1dhr9jzTDLf4+lL/8gZxH6+L+obdrABezgkX/pH7oZOADu/fvzCjw81ivMorutR03bIkYX0fT83IvgBpNQUZDb1GvD+FebP7SV76l7ZOjJqrF5MhCHIvn4/IlHbyzozgPB1PvZhX58AD1K/Ovri+/62OErf+m2xSVFwKcPFHmDBFVjs/rN+yyWfn/LrbgyxFbeEnybf97P/Pf/8+f6gZMr+DIyrvxk265oSwZ766h/uQ6jmq02x/c/6yOXX/P45f/1cv54GYsWtA6OVn9dRz5VnsfscvzQVhNE9MlIU7nMZblb91Rd/XP9/zl8/24Ms4hkBdkYqpYF/BR1Phz/Hj7ynoJNrOL1jiaZQith7+PX7HuuM5bwtx6/9Q2TkVexJGzOFwctnMulSfO3vja8XF02KZaayx21BPpyVr/NXHsOzoV/OpgAHb3eFD+v7/P1jfpKcu3krhBH+w1+ktP+e387Ow3w6O/jn9kinQZp5I8P73Pv3A5LGf/2+STrPPgtOIpvhv/XxnuDTh51O8jzn0tjHHovFRTw/w0878s65kg8zOH3ujx+lEzPQS2Smksl6Iigre/7cXz+BqtR5YBP/FWdo5tFeOf5yfzHLKZB17Hv//Ef/aKuszw4n9oZ97UxN1AV9868WE/yJdvkVm2sT9sjxv/Njxw8ArKNcHeWZhanUcV/5ibZOVmZsWu9+zu+/4/saH8c/9x8F430//3N/JYcJzFNjPyKYkaJjvO/PfYw/B2AFOq16DnxXQkG+O4Qfiu3QZWDZmST+OeCCrBWUz/EFp0oZmvGJ//66/zESGfXz/KIIIngyjfwXfAIHrENGZ+9/ne8J2+NXfEl0MzBgwfg6uqYMayQx4ef+gMzHFADjK36Mf/wrO+t3/UtfTbSSCY+V1rU/gbkVvs6XB8lmGbp2iJ0GmQpGvq1+2R8Z5/GRe5e2wK4Qk/Hv9Fd9kdmDb2ZDSj+wv90iReoFUt+8TSrXEj4YgoRI9AD2YNx+uR9t1oDNFq+9jcTVsJWt/vt+M51lPLB89jpqpUsB8WR96RtZkEYDIprUN9nuSX3fnb/0k+TwuZEHah2Nbn6EmvySvn4/I9MD3uc1FQajkvsShhZXfN6PRptj/j42do74z/4rCBL66/60ZSA5XzOh+s/9vW+7f4dhrrb0dvRBTPHiuPrSfzJmhiYrBXqLTX0Bd+Al3/rw1voc8FfLdWAjmVpExChf+grdRx2ilD/4zPv3A3BHxCu877E82gwk+qgPey5bHWH59fuk+s4wILgS+0UDNOjj9v6Jz9eVzlX0tUY0ClbZkr0GtvhsT+JBhwaeiH4uJ3/Jbo6Qf7YHT0HN3WCvpNIl8umMylnzs71WRmImPhallQ7nKc17NxM+7/cEA+GnvsBJtHS7+PdMsmLza//1HAEwS4WiwBci+Gz4sfrZ/1QUKlTG5RkICkmcfNg7X/PrVJ0npEBFCuRO+R2iCzx+tn+WrMRqtKY5cEO0Ebiv4q/6tr3RUu1BU3Hk8QyjHB/S6LP/ac5qfbJy6vX/E/Zl64ryTLgXxEFQUOAwA6OMCgqeOYGCgiMRrn7Htez/I3t3P9uzXtUVMlSq3kqqKuomzxugaEXOtb/RfQq3yeguZC6dQ/mRzob2NRhlBrWuVFG0Z0h3EBtFwMc35e9U9rpa0fwpm59csrn4JdG7X0KN+dkezi/Mqe3y7D7U3/ttXaWTFx7g1xc1vZzZN61IjjDOUy2UndWEO98pLzhC57o6wvVKyS01ExwP6WqOgX5o7v/wb7sL9At5Ks//QTeVyIMu5eN7/qOTsgkn+USoUuoaOwTh5anvh/SXyPDPPvCO1BVn0EOSUnH0zbRQi2O+q/7ePrba/AbafZ4O7eeAP9IghtJexNTZuGx/Jatk2D6ehlEG+yo7/MN+Fm74zOntsYpm+VWbCzAXuf4tJwEAqRqr4aTK0IYsPX584gaGRfD4lM5+swlXj2OOHy2Op3VxPepnLj9sYxsNXCXG0L/9ie8Fh4StX/9KxXSsz8mQ7jGgtgYFZnTJLXAWpkdz6F8ayEMyqQImH4PvTyPkw+eSyRdBR6EGc6Ma0v/jj2atzuxHjhhdrGIF0FM3bD9yRw5A6matc+0LVjDN82d25e53pzuj0PVOH/J7fq6d1bPH+te/IynSnf7SD+T3q98ha9/c73TqRFtheL4YaGNNA0HMfR92bv55V0Nm/oFbCYYwRtz4yL4WMgCU5voP+Y2e7Tgvdsw+G8upsAdYF4f8uJvDvmAu743ONjdhC/azf8zfb/sYYta/xU4a1/2hgoP7tejn/J/MPcYvT1RDxrC2hufvzvsErkD7rN9/93e4OIcaSK5iEXm7GEjC6MM/uN/TFxGG2aZZR2G5EdaabDD+xVklBUmAOfy+PlE1RZg5jH7chUqo6g99SLeCpXYEqqNz7e/3UQ7TV0P+xM8TketfpdKkEI5pFb6DB9irzozv/2bWIdjN7Dt1rC06EcXi+Afj92ZTYSnMfY6fQVOoFPNGrOhPfvQn6ZZrH5eHNtfiXUN1J4KfeDK+/be3F0Bc1H0rJC/gai+fnz+fMnzURNSm+pJgD188jp94NMoKeq02FI1HwNGskO+flBbMdgnMvmLm8Zpkxa8fOjqA5vE5YvhluYUBmfD9R0/xZeXbqXr/zY9Hc5vrH2JObQwojZpoVhd4Aa8zfv7XdxjAzK/mkX9cs/H5SPzL/F306je/BOv/l/wM9ufH/8etwfh/86sTOrwfjsj5xebHMBn/lDn4VtetzQR7Zujmyj15R940FJZqt0+YvQyYvOiNaw3bD04lttFuLvrMf3WnrabcjSHdVT5l+CuxmkOpyiehGKhmRabJOy0kUxajQJUESX2woQ7aJ9cYMaddFLth+7Z5F8K3ctZFaBptA7Bsv6Of+1EUPJIlLOQGZrMZMZJvfOqFtY+PNRJwuBSXUJmnIJzcMLc/vvc3QeXAoJWEehSKXP/NSY08uF/oxj/m954DRchCcQ4NNQfWyFa4+f3GP06q+d/5jXmsrUG/0h24e8mW7T921jD/8pvfEehr5v80ULbwTh/Sf/IjQOWKaygj5pR12dsQCZHzcZ5BUYl8/4YeeC5w8wvniFrFPrWnw/lNPUnLhdA1dXQeBzK4X0Qpmr2x0AtV8/f1B0P+r38D9QTddyEGewNKf+oXJMka3gNJbpVHMTjfA7/5oWCy1Zdw2ilU6r2aVCQzC1TMJKhEP/ExWt6y8YPUVaxeGBk6Tn34hpamTyNv+xBK7XJi83crCksmyhMP2/etPTygSEgMuBirtm0dx4P8IkaPG1Brq2nlD8b3rQ/SN+Ph+JSjRdsuJMzfOs/DKld8SH/j2/CBMvzwX3660ApHt7g9s36Yn55E2dy2yiOINcthhlE6FEr0k39CRhnTL4P89gq9TTg9R8qQ/y/59WBIvyzERWSsPvebpDmMgJXKk9/8SWKMmH4qL3kvjcIb63+xOXSg9HZyhHoZyahoP/jHg8yv2vloOH82umlHYf9idHNe9pYYjeADahJNYL5vlCgMmLeIN1OmX8jTovm0WQziH8AvPgZ9w/TLJbV1hhcmg/xhEMH5m6lC6fR5WsBwtRbEi0F9ABChQw4vUL2y/d1aGZKDd00SuOzBLJfL3ZtBizMI1Vhk8vWbfywmeLg/nNNLS8FzwfqfWrWYizrrL+mX8xBesddH+rTGbNlzhi9nZYQacsHGkP8n/w42Puvf1KrW1D07Wi8cHjAraqxLkYlvwNfClls/UBhhCBQTyn9fP7DaR35xForRkL627LXtXBgeES639gLSyJYiGPgoQNBKzlDu03HbH0fM3m8P7QaI5m4S/c8+niFzQ6YATPe4gvkblpCOGB775v8A0YDOii21Uctsfz7btgC6zMb/Y5/IfJk4cLRTrtL7DJn83M03hE3gidFP/LTgjtn4ZnnZtuPbA+lo/ih2xejhjSJfYeunJpThY7AXCQ2kHvRqHhUmxJ7eR27mgasK5oyf4mYGw9FUu2tgjGJ4mDRipCOkvYH8iR84b0JZEvZvXcd9Di4gfxR9BIszumBrx/a/r8SCBWbMPyW7GBqwgPIo+t5/AKb/xrVqFf7aHNxvMv0djIRUW97Z+gVdqqbjy97aEf3Y3nItkOmv/cXXHZMPMWRf80fIeJDpNEqh5mY0IulEAEIqcP7BoP1v/LDF+QeY4OOmEHXv+lu/BJsB458z6JtOLGo/0N3L53lSye9ffAfkEev/f/yksk6z4uQyfGCPbviACeHog+//3D9je8v2x1SMx0A6nx2O/hvfmbP9sdr003aSn0I+vx8AQz0JBDCNWmB5Bi7h0H6h2w0ADdkJgSsXMmGbFhy/sdCYh7K9fXIuDGsqTUYuRyc1UraCbrP2F73Llsp9hcw+eHhdTD3xEbnLEGckQzqBMVbacPx+h8P6BIa8F0I1yCoCbyGNqDXLuf75osjW71ky+qNIosKFiKMzsQcOcLMewOXN0qyJ6wdD+/sT34Jfc/b92cYV2771Of6w/+R/3DU2/v0TtFYXKWGC+2WwBa9QfUU48IRaoD37fryoFtR+NYPx08jGS/aF04217012Mxl1DRzKp9GNmf1eacct7Jf9NZwedv3AP4rsqaotBfVZ1BA8ErdBd5Nw6xtAAaj+OIph7Je7Rj1Ym/uA35tNYIBm6OTCre52+Yh9fLg+lgcZfrlt31t4uKt64UGL8++C9YPZ59niZMFCIEqq6bo1/L571QRNGCfzmP0rllNlG+kPmD+QWqx7sYnc+VyQtPMqug/5hXm0KZRGvAz5LVsCUq9v2P47f54KktWqjrxTiJi+8o4K3NDMs4P6AYbz8xNfiufuqYbqXJxn+nuLH6hYvvMiCZj/GJThNBa8A07hvBcttl6cfxY5r4W5gjAIKRBfIoMd3oWjw0PMdr8Tvx3Yr9Op1K9iYygf2J1oSHto0T/w3Wx9B0tVodE/8CP8f3/W3+pzsN9v/sIj4vApqe5grz2WrwIM+N2LAHNJVm9D/oH/kXbQKOTF7vp3+vD7MwWeyCY++kP/aaXRW5Fcs2s0S3SkQzKCDJ9mWzV/G5UxrN+CaEBu8KJHT3g53dVwmgBu/b7+UfR+fvHrpjW4/ZHnEJJXdHzCxYmJCAoVjZNvL4cZVl/0H/rZm++RCbPujf5OH4x/LCSWrZ/W+j/o//ETcMm1vKwqbv66OFVadYeQilcBauF596j/xg/tv7d/6RuGbw4HQ8XPAl8Kyc8u/9/1+Z7P6Qy/PF1lZE31kzeUH09ZMHvNMG0Mq/dWBF324Og/+cs4bcQQ9qoyakex7HHnB5/6QcJ8VIVMv+TTVtoKHP/3fGfM+FegwRHZZN5Qv7hjW7AEdaHHcOToMxjoNcdPlgr85HOw/v3GR7U9Rw+eOgOFkzWj1zNrCt7qsP8Mf589fCOrexJ/+7cp2fdvz0gr3Mfj8ac+YMK+71ePGOLRykv+5J/tHkw/nmCCBYGjMwQLQA6j6jWk/9d/PM3zNn+2zL8f9H85kV71uzU9zr9LSrRCvlXF8AgzyzbugOu/N2q0OSizz/ocG1I4o5MnkvNlX+f0Y1/I5oRkeIrY+AhVFKkX9px8up2HKOxf/RVuk0i37TFWhvvrGz9CSoYvMZOPSRKLw/2DrkAhmhqWo//Ek8M3TqX4WjTr/0EPZ2vFEWqDHGHb6oHtT1LC7f9f/LAol3BEC4ca7QDef/RneWb2JXkTDT4nKoFs0s0HSdbtDpgg6SJ0eZEGy3E8gb1n3+xgNXV2ZPykcVGrtIu++WF9/IQZ7V9AvRqzYf+w5usHIt5K7R/j0+dIQPMZw8f/0UkCulMRTnZn1jjz/zC4kCE/ymqMi8eS0Z1lBSxgZPGVweiGULiIuO8TqyMHbD/K69+/T25LAtGyLp0BHV9oa+WeXZ1/61dh3yFL2IkJzOC1D4b764sPr6IFR8xFy6B/5OiWs8EJiTxGp8r2Jk1uVjDc37PrAb7I88DcUPfsvhhU1oPh/vuJr1EPaWVBpXzMIA4Kjv/n/EZ4KKz901n1onCqc983drn21Fam6MLLTBnlwmjFtW+WIaxIKiYWzHeV3YRCx7XPYBkqyG6tuzAWXCmVOmVAZ/j9kz/F9k/iwkMrMg+xC4Ih/vqJL4Jnk/GPnVK2JNIFCW5eUVqMc/V7/gUNjX2/iVknDfHK4cNv/ZQTmx/r2Gqhcs6D4f79ni/3bH6mR6lru3vHjS+8pMod5GuiwGC+SyIEW25+vGqsESGYlgp8kv4lCasFz39b6AkBkxLAa5RqrXrh+e3LGHqkd3oJLhw9irxVwuPf/oRPqDR7BZoJodLo0nPj+8Z/j+Mezl80ZvI6Yvz6/HUFj9Xj/qc+0DVW4MpOx7lYUEYfZ/RRwFC/RcEh+STLnNj3JWuXQH2z5/r/cz+hzWPSwmsSTyyBvgIRTzdzB66a6hYZ063qarFFeoi1xoLGpOPOt53RQXkLln5a/uP8zNnqU1Lk3X/n9xw+QuXbXKG5vBhBwYv7vHf3kJvf66do5QTiM7wuK5My5xFx3/fucMOM8QnBRtkq7Xg+4foX+C7z/4XoPfrH+SB9wR3Rlgs0pFNVa3O1eDQRjmyYkOY65/Lr/HMRFOCmX6Lv+fj8NMSXaPFeuLDzmX7A8UHPkBEv/vH9cCljG2lebHzrH81bbnxm/1QA6HbU+t8foY1GQevlFRzE70AMzyF1ZC9z2Xh6Xdvm+6V9jZDVs/leS+AA6tomkY5D7n7EcTdkg8WcLqEZWi8JRDPMrc8n/w73wlMEq1ae01mnM/+qWZ9IsXpW9wjXPrN/aMfk/6/jQ9rHf972+vLr/2823PkpHi+FGLyWDB8Nztf1NH/l8TRr/sT/oGooX/gJTp932pj//j2fXTP/eYB/JyYuoLdXGX1qoY5I68/5wC0ihSdNOPscbJC8Bc/nYvnf9A7p3/jV7DS0Pyh2QyO/mvYlMhfmqBfW69PQ/8eL6LkCyxdbf0dYIxmH6/c/7AuGN7yCo/j0HNJn9ckspnJxiYz1Eev4KjP8HqWiDfVdwvUfRQtQawqbJUh34dQapZdpP8QPu0/8EZqXBnx72zbXxFBzB3RTVtVcS4Vu2D8Ezz7NNZCdI705GAtsohjBFwZ9+i73nH76+u9vkfnPL0VI327L6ZeAPsBTuFTMv14c5aVtZ3OeP1YhRoLO9LuZhUoL3ClPH+egB7OQ6e/3qZVq+bRidAnvsxy0zD586z9ljD/eh/eQQj0c2p9v/GnA7N9jLtqNHa44+k/9MXBXEwKDVpGs99Xn6jM6c1VzhGzK8Fd6UPVmNj6Kw/kN0QEommLrBrzALGBewIXTXzMJKCPBnTP8UVlbAFTtJZQqc6UuubVr3hHJCqiTumD4xryrXuNZCCjAGx1DGM13ffTNH9uL6B/+6z5GTD/pyZCOpDqIwEmGdRS+XU0DbSJy/uFv/F/qXSIvNbRWWEXs+7/1b6Focu3LU+xh1nsCazmeSlTY8P714qDOVfgKTdDfUpBLp4SrT2lr1Sdb+dCOQQlq0I5MiZtf0p9UC0R11DP755kyPFu8/7+YQwarZApg87ItGBpnhzv/QiMt1KRRocCLkAqppEVsftpy/wBFyuwX2Uo4wu41KuHxYbPxX4md4H7zhoV9U5sIjUZIRQe5vYDf+kZW7HP2YW6xji8Chk8ufTtNp1P6/9K1BYM2X/tdA3/Y/5/8ctKSiqllN/Eit5c5+je/KGftO+dSad/hkWv/6x/cGX8jP+IifAQc/Ru/rjFo5Duhkk631wGdRrilgGibG6MXS1cA4jkImLyFUVlMP/sHZwiJ8HBi31cfMUjHYsbx/8QfCBuN0UvdMxo3qrn++xXGOsko619SQiij+8Tn7r8Wc1ygo8vw33sl4wIbPkf3mgNrX6lZ+/72ziRkGXL0H/nVWp3BxJuYzajTqPz8LUSMcRQxun+zrQI7N44/eLZ4B8GJ+b/hpLzX45HoD/Hnt77okdGNHehqwTH8IX78wecoCpl/7SAxkM3Dza/I89Zu8in4zN/7peXqwWT8N6h+XMEjJ//O5gRG6tF81zBqG4vtt6fB4RtzB28oPR9LKJ4kNQX9yxrKtxssgQb0AFtwsn+saCAUznD9zbqAJiqu8xIiJGdReNxw+yO0MRSJE3cuDCgYh50/nyWfonErWOmwYfJ7AHtw2L8lCLeSaI3zwknwSWg/R0XJNbLoGIpQuaIQ7mZ62RjaccbdL2eQ2Z/l/WTBTdZLqTJ5+Nz5b94Lb223+sD8jClZ/Zlx9O/7ASMmHwjIyCbFhfPP9RfVarX29RA2lyhkjq7F0fHZhToyb6z91zQGFt3w7X/r648Y/6aqH3mXmH6CPOUUF9Jn/dzHBY0RurP13aU2ynA494by722W6IGoWcVwr+YSGOGTP7QfxH4KiiqK7PsU07oItjdufcLRQW/IycE1XPu91nYLyOEfonT2DLWrroTnNgnlkM659XM2Y10mm03PvND9w8sMdely/PGCWX/7wOi9SfXGqPjzITKlsqLBKS6/9S2Axp/vhDdFE7abmMBjGN7z8QF5zJ+BVID7WmUzvqwsARZn3MPnyWvorDTY93/xSc/sy0/9HKCbOIVb3ZqASWRw+J7ZDm0O8CX+R/yDH9WCBmSnf3LxK1M0L1z1g5/G+6kkXLvyH/jZBEclB/dZP8R/cHddzGCWRefIqFOSoT0lR6jdd7rsCCV3/uUYbw2oC5+t/7QqjCLEqafj0j9IYDu177/1I7FWsfUVhHQcSrLgJRg5xxE0a+Z//eQ34jvWY4Zv+3feZVNu/vWy0mKgxx/98bBncviQuO9/69+kfQyR329S9XKccfrxVOkv8jiXMRz1rpyDqcXpN2N50XVywXEMbQ3k+VSV3OH82Io6LYVzU5bMDCkdmFgxt3/gw1AJsHZlDsXKw4U+y5h+y3Z4WzzPWR2R5wIusFqWKZyHFm3fBmHyfzFykh+a6PJ7v0S2QezCzXY3s+3FirNPlr8S7mAtxGybG72UT0ONmx9IEJySffU5P/i9X5rx55eHK8MPmczw3xxRvfD3IcfvIhEgMKEM/wnr/NVqguFy56sMax2gWjP79PtDEdc+pinM8PXG6Eutv4F+zMw03pHPk9dNdov0vcD8i8WC0c9XcE0lM3NFbL8KDW5O4p3hiyMU0OcxZ9gnn9fEz2uXw0e/+Rsjhg80uTIbe51x+v9bP/oR+3ALqqhBj0Tg6tv/nm/NCOffXBgIyXUbnpn9nOlshDfif/XbSuXG/83fogyfRzbp88mt5eTvi/8mTDXfyrC1poXL0a0k0C+oODCVoOuNR+HU58ZnbD09QKnB/L/3tG5TdfTm5PdbX/lz/7bpLTEd2cVMJOX+FeXTmXyNZh3SJsBcs/khxs6K/PfWGfbftdfCXPU37PvHZ7aSXS+Y6Zg5EescpUkTGWxSPGTFbHxVaklgYmscPviev9C+hvOYPK1+/n+df7lPLRRQyuiRkhHZTFbc/ggLg6yg0JI7LO6lUCuvjNt/UDuhgBy3cQ/38b23Jp9YoGH7iQJStbjGLXRvRSKbZBIkqEmiG9Qfj2uEmd84RTAr79CPSzntrxPG728AyQO3aSLnHRgRPoZxCSU5zGsl3XLzSyIVCZgS9n1QZRtmjbcOh5+OOt6homD8x64gmUljm5vf1Gf4er9i/OOM/cUZZdz+8t21etY2FelhdyByOBK2DJ9jEQK4ypj/6/VEQFqYsv6/WhXbln13dHJ2P8k3p6r+c7426iX4LHqh7gE0uf45Tywg6aOfVpsHinxjzMe/PUKtZOqH6bff+gmkIRz+b8+KD54XRu9s1YhM6cDFh3gIEBudtyWBtlkZ1DhAnSHG+KUBUUouzFkA2lEV1v0WGscKZ9bdHRyAs/27zph9j0vC9scZKGkftcxfg5suLLC5Y/Zx91aO2mtJXLg+F0w/vW9o+H09fquuOg+Z/T/RBFODwQdOPtIAvkhlLFw4akrmwazqqSu82mAO1DPzz2znNEYqvZ/6wf071hdzG6pUfwzv38UiMm2MSCj+ie9Wn5FPRkIulCbr8xNERmG+xXCIb3/qC0H8gWaZlOhN0G24/nnrFAowWR+5861NGMlF38NrBBUNuOq4fjuwwA1ieERVh/NnGhfB0uiI8cNbqoJJwPsv9r4RiLYcxRKszjWQFLXhzyebGO3wesL293tfzBtYdQHnnywEba4ej0z/H2OGwBh+lIf3J5armyaUi9McEoFpE2fccfgwyGPBFXDA9LsJ2STMpoTrX6ArWq+q3uf8efsgdGauOP0SIAGeyLJh9mm9rjtJfjSc/vi+b/Bk43tfE5NaUOT1R3XUNCEqmP5bLjwj08f8+f/P/QxA+GP/ejAJFfTi2v/G7+wZfr7aOx3ayztH/74/8Vn/3/sBz+PPp98EbbA4Y/Ss3yHqEMDRg+VTQOp8x+SLWqpXmInI0fX3Ghawe7GpOwHrWU+0F49PVmcyg7ZMFNj3hSGT95qb35/6CjCQmf0YyfUDgKDmx/cb/259zoc0nUSOlfHj+7zvApKRbsFa282y4Dnj9f/6gVTiWoyuMVXbGHDJze+3/Qsb30QL5Za6d47/i9+uTP6kqdKl0vPJ+5fKXHiq0xMb/wB/quR0hK8dvdLQNCBFrq7v/4pfqQPH+ITqhKPjyC+aYjKqqn/cLxtHVBabXGX2f6+RG94vgDiIL0BnldnHYln8434apQhMAVSKCw3bUEWqvC+ef+8fYfi8VN8rtr8H/NuE6TMaNxeqLw3hLvTX97D+FVazPALbbXOmf+//f+3/lY5nNYN6E6ofKRMtQQHzmA7Pr+BaKdgMLeU9nWklaLVWRmu49Sszc9ahmWDDZPo0Zss9bH9lx8zTMIjxj+9XCgB5r+dD/5v+vO+ktqtoD6vcNqi9f3L8ep8Kd21soX/MH9aY44DRvBv2H+lHwcxneXamBGxmNt5NFv+Iz3eUrXlAxzce+j/IasMjcK/FjuLR1bQZ9MWcflZK4QLatXim3/eltvEwvgVNmKko1mG0YXuazGyEpNMIql47Sfsdl79ArWc1aoGEFv+QXzOvhbN6GzH82lr5NFV8YYhvqbG4mh0C79Pkmz+zQkP/lxr3GLTgYjN+n4gws3atnUDtGdrgOc066j2p3pEIfc6vH1adT9F1iD/p935wXyJYbNISqMfcSbDU5TNwvYsdZZtP3mpRj69wk0gKmLT3Ib6klrEd9cLUOnHz/1vf/2h1Ifi8vwB7W+T2Z7zKY4CkPG/VT3y5mm0rjr7eRrsifIgr6iGEN9C5Ftz6TPPczpWqCKgdFKghzWXOyQcSqQf37c5i22AuAGF1KobrR4xjpBcuc+n/sb92MrjnGVb3/9hfjxGY5ftEhkO6tgMqkOzEqvABRZcCBaI5pJf9jjSz0czSsXmjXqGUzWpIF+ED2sGdmhVpYyZfavU4/v37pPIow3NSdYpm+kIgQnrk59d5FgSqYnWIZkoI3to54O6HkBUBKd9ey7JVA2cy12w7F8GAP/MWFuwoENvJ1mX+myZCjdMvUjsCOEovoTY6CL4WLujwfg9X9V7It69P/VVdnZy1rgJ02H7JYDaIpXIZ0r+NDz3O7ZMpE9H6e/wYrtRAzRcPEf1/4su43ydxIYPqfni+SH/iK+Fz9S/7YqwmzH6dQ+5+DPW3IoSHySc/kgbgrFYhF/+GQlIsCuwWRqTXJficwEJev2NQgfAoLiO7wzAiqc7hQ2wzoAKImS3/bn/IY1S4xZ5mG2boKGrQW6Jc/J1vhO88Uunh7/ODIjt8gLFTbP4xf9kjrwEWmvk/vu800C/2z4hto7bDAZmUkLs/cbe0KA5mkUf28YIqYgtv7v7lN35PTarIazeaom2dozH4Pl4eilmBleL4D/v969+h7Eq/75/eE+7+3DAZMFgYRUl/8uvUsSdydFJGcUFh1NCf/B+hs8W/xzfSb/zxOOHW5zd/a6Gef/NDiZSL67/zB3bJ9t81EH24YiCl0Ze7of9JXR8IWyC8Ex9en9tNLosjTr+GqwjO2Hqx/l8nNmrsW+sw1ZofJvnTtt+/9bvg+3M/vFOZY28XhV3h7TW6wPNx96bf+5cJ1z+Gd4rNJx8gogjozP8nK15/3FFu5eWRIhq870KpOSv+fvk4EeZA3O8uf+onLaohvoHFqPOL53N3/q3fJTS2/vf7N0p0U5O0syly8otyuIVPhdln/d7DFYGf1Ouh/go/9UPyovhTP/2s+39v36UBEcmri0ewUTLmbxvubDi/hJ70A1yCWIPTK5gAIXkNz4epUy+Frapa/PiEeavmz9QronA0Y/v/ukdDfEG2Ti4Bzyp2kdlugKbt3pjTL8sSjIEw9zYRWU3ZV0dTMpwf4ofFumC+0zoyPU9pwSwsOf1DT+0ZaCcxpe4F4Qt+7jj9RSwjLMGhgwdmPxPW/3zHrR8UQXSDZQ3PNHxU6kQo9jF3fnzdt3cQmTLDP0qt9YK8i/8h3//DL5z9nz1DCkZZs6aBWuovFNr9sH4y7txiC0s/WtMZXCEV+mk5geUtHbdTYHH4BN2vwkirDuQJVS1e5yMfcvQf+QSO2nPxDdMbww+R2GwiUzkDSzuVZDg+crKBmm922fY3vknDK04+kTVl6Pd1g/nv+bawuHDrj85mYRaF4Z0i9AxBCJYHTn8gl20duOjpKvrW5xL4+Ir7Gz7hTU9mkUUcbS9kPB2bBsMzoyZj/stUQwLyFS5+Az3MnH6efT1H3/okHrd/iTyPHOhM6InO/AJ6cJTy9t88v8bguoguf+qn7jn8BRdbtv73vbym3/sDtefwlf1iTvVa9Pa/+WNkN9a5/vkJNaF7lE/RD74H4yevHw8LaEMy++Sn/uofiac3VSjm25DmVEcP/MLakqOjxsllcHw0qwgrClu/3OHyD1E2BgbYj/WAGmx/brXjJ75pMD83r9Xy21Hp23ERCkhjQsjFJ/2+3xSJG2pePG2kCkDn7MOvfVXsOTV7jFTsJJz+QfSYv/NdVr/a0W/9/IRf34NJAVxUlUO/+Tt5xckHcGEKk7M6/30/DTh3fv0n28MI3DppGsqf+mraXuboUFahCumS4SODHpGMjTLm9OP5k5Rxjhv0+z66apeY2//TWXjO45NqUWs8siguKedf4a0evQqsPuCf/GGVj6+4xuGF4RcbUj2DYC/4OH4P+UcncAPwGN7DblILQEueiF+/C+jy8twsqaM9hV4l/PpjfIA1/FTPpWjGrI8wLXj9tIujBi72OorIdCccQWWW3PsifRHFcHR9ONHP+0Rga3D7m+lfhj6ZS4qotXdAr3qzkrNP2j4c5f2piKJgJoEc9C0e0nHNVAcUPdWKAubfjzQlOfL52asQgQZTEtnlBE+xdy+H+BAVx0NXBM4Ut6Nvfg/m4k+KZdQXQijiSHcD5t/Ic07/4FSiNXzewl07OlGc4EDm8AvpTHguiKDPqH/56NF9wOEn3DwZnjUFpWg/D7diWM7+r/gXvW3yZxgh6mQ+hiRyuP1BdAzd4j6JR6Fgndn6+cV8BCMLTIEWpqYKJSmf5/09oX/y1wWGbyaWbjUwR1x9CaufMPk8b/X1n/iA0HiQRcQMR1QlbxpWCDw1K2X7a9D+f/yD9k8LG8tmAQbvezL7NWe+Gip8pr+6DkxDdWEbKlpOYAFnVH7/1q8lCWH0QfvqIVoWeJp0w/b//Lj6Ct/3i7LqH3RzudFqcI1Y//OzaBV2s7OG/fvGz3ds/KEcYYiMYpg/8of/177nSqh0W91DgRP50Diw+XW2M4BUqWP75x2GYtgjlwz5Z8cpzqA0YfoHndNx3Y0+x/e/76eHjUJtqYEbZI/F4fyixeodFLLlKcPx3xCZpqq21FXoueEcGJU3oV/7eGH9d89ETcWSDOoTAuolLTohMGf26y/rB4btR6Gk1Rp8jhQ1SfJ7Xu8T5c/5oMz4S5kaNsp6uPveT4BMptBqkAAf6ad9TJfQWFqD+o6A4j5DGFtldYQrb1tJYA8G9ZEBtSwqzLVGZPMjvwGtgVMM4v/A7/sLqrVj+4fG0tSaBN0gvhD8qY/bMXy/XulGhNF+Egt0z2zbYVPQX/9SO7viES6AVUna2tGIasKjWdzrqKM/758BfcXo/b3x7PBoYebGvotNcdLY+lhHCmW0lVj/7bYWrXG/JhV+q22ct8vHhDqii0/QNj/5p/+rP0wktTXBYiQqw/rDf6m/DYb05SpJKdJUtdRWWWHBraTK9Pv+w+d98ObkfqD8sL43oMZzrinqXWX44jADQJJG02F+/J/3a9ZsffSlpErT+Se+46gzfzB7PJRf/AeqDWt/0P/4I1QdKPph/06STmRvlJkVPF/oprhju6dQUaFImJvB9P/bDuyQrAjDd8kxLpqmECkqmPzAl8PoE+LpdNZO9AexP2U9w4r2f/BRzeTft3q1nZzXTH7rnOGfrMrY+hSRcNbCBes/8qkh4zRDO2heoAnfF1H8876Gz/C5V3lItu4y258ZFFRQLuUxZVsFrAXjrQ/3F7FG0C4qEImc/P+3P1Irf+TFQZSG9JzaeoHkrfHAYnWcF7s4G9Of+H7h1jL9f2DeY8FsDtNvstI+QGNmbHyyxua3UZj9ELUkyJhskQTn2/wBoMb6932/HnPywdyz3Mjfq0gezr8o60bmTF7mn/PxsT2h3/dBRX24fp+KvFJeHh6jIX9m62YTBjtTJJVKlYIWD4l+41/en/ofsJhB19wxf2RFouKTzyzSn/qA6uEjHzOHaEz+K7b+OGv1XBBs8Rf/4pHyyc8/hlo9OYrqVoNF6IPLle0/R7JBqbV3pj9HdT5Ku7mAdt/6NWeVUoSPUMe6z9bXHbs9eO8jMLgfo0awYlDW2zH59te5aE1H+tgFszQ/AmlBu9/6+9CRP/n1EsQRXFeGR7TuIOS+x/an8cmix+uU4dcY5bQeCYZ6//LH4pj6aYQumNyY/CgTi+mX+3q6VX/PL8Kop9/4MMrav94lsZ2+7HEvaOzDxTLV/7c/rE99nZ/8ZGcdDu1PSApUYMn73H8+EoeGI5ejm7demKi+HQNomsw4Otk1HNqnb/6DpZM//tuJ4//K/yf/uquqULYJ4fhD7waZu3+sBvnRQ/s0uJ/1qrSX6KHg2rd/8e8nP/s3vgya4QMdxi+a72/0QS3thTY4NpK/tR89hu3r3X1cixNx8H1KZ90DX6D3ud/93/2wilc2Dgraqk86uB9WzJbhh0sz6B/T77/5cZ/8aJve+1Ba3sMdwsG+yk9jnX3/E79NhJjNb9bexyloBTI8n/A6jB841+kZWue2s6buC/7j/iU7lKDtnmOkI+N4DIpWVK9DOnCZ0zSOLha3Pr/xFwWTH+MQg3A8U63h/IfJFtyFdP9K/nc/9tf64oMfR/dvDdgK3eil/ne/Nmx/wNeugWSpFeL6h+eOeSIiBg0INopWC9NqWP+AokuCPNxrQjTsH8oXdzi+Mw/BU9lmJ/j6kgd03Fznb+bcq4//b//Jcoof0EPQgOpWDyN/pwzrb1B4KcEReJipxKdh54VdRlz9O8OwgKTWOypBQy3l+n0EOnf+d9QhU1cFLP/LH+fo/+WPHya6Gc0Osc6dv4waEINqciJwu4ondbdKOq7+2Lxj8hVs5yn0660STta6Mqy/h1KF4eeXwvjtWT2tRaTpFa4TBpU2hthQQ9/rHtYnzN8a9O9FBB8wIH4e9u/ZbqUcnBnuIw/6moK2TBr6k1+rzpu5BLurOpNnICc6eYbvC7zEYv2n/nZ1iuFRqEyo37j8JOoib/bCDADncG3IBgzQyuPk83M+SiJPj+FiY93S6cPyhvjfsTdQhvtxFcLez2Kq65jjn5kKVPGxZfS3FmHbCWbecP314wWkgGGBQX7skH+QH/s0d6iZtT1H/xkfmX7ye0939x1K45G3w+U+OOdVyfSTfQqBJVRpwrd/XjD/KVfvw/blvJ9K7+rhDfXT9/2aT37w//J7d9/8Nfj41Cf7X34vpK1W0xXwdmjKgChUaPSkbtSgBDojRr/rrhJ2scnN30/+iDb75Pfqu0IvjBDw3/+c34LzJ7/XPySLzH1qnkpuaSDnca6+ft/XxpXP6IdbYciudwHD+nkhwzPMAj0XV+i8YylV5mc8XP+QOeorshgthvmjA7p3mGu9NrW4+omwu/hlfizonfrTT37A+54M84vQEaCwmLif+m7OGmgq2DH7bhcypsHzMKwP8ef8ctX/Pf/+930AgZb9v/y/9QpfUFDEV/iwGxy56glx/t2rJTLpFHKFsqCnURhK3RBf6Gcm8fBhxms49iI9C7ujzsnXb/5BUPrD8eUFOOUFlj/1z++6Sgy55Oq3yNuXAIJbdaGOftALmDgc/6B9QnK1FFZSOawvgKITDYtj7V3oLH7rHXo25fvv/D/v56qyXmpQXpUqkOWY678zMTUg9BqZQDVgoNndVc5wfpx5DM6CGs4VWB4JSEeKwc8/vqMKFQJKYSboBmUghbMvrligF9bMowJhUC+lyaZzOPsDJKFX+ykO4YWq68aSpRlnv9j+ynDhHiVorh6kQWrBj8+6AB8k91MIX4u2kqbmm2vfYIZvBDYC07/PQzpJAdk7KhYN1BVu4F2Zf3YQSuGQvGt4iPRUdlw8e+B4dLoUlxdtaFBOGD50u47AcFS3ofgqXA4/6TbyiLdfhDCtyR7Ioxc3f3ro4Qg/EAV/8ptNZ8dwsr/KH4p3ow48glSrm6MLz6tYzdVk5XH8n/NXqN0qC6onOSyMFeb047c+weeZcNp+3is9X11OPn/fB70y+rSOL2FHytlwf3nnI6IouX/yo7dJDmeewvF/328vRBeGtvT6PCvK9e+n/rZmF4kL02tL21F44vrnXQo4RuP+E99G3EaSa2E25P+5nwPX66c+D7SDgnT27EHAOHyBh83wkzN5s9mbfOLXTlPl1NLs6O6+9bkq+cbWX8HMY7IqFz4bht/kSHVV7LlvCldhdmP4hAiK1kms/6IjG8VMLrn+O22FDlj+5MdEL7eqJ8mIW1/3fdSI9nyXCjwcE1gEWsbJp71q9Ruqqr6F1bheg+kKDesj0W99lp4o0B8BtZarJW/fxgDecLlm+JOmLduKk4DrH3zqigOuad9/6/cXKo//dhqotU3Lvi/ZzL5MHddWsY6KXbE62zWdrYiWqkFAJCiXzTXyndBRydwKZaBOsoZCaQmAWmCG3/2HuImCMuLHd3fMMbnQrmbju2vsv1b2UH78lS9I2m12qiFUKYyCsOLHXyhkgZd6TKAbywa1jndufP5u5lTIODD+Ym1N03FvuFx92zOeToR2XRKIJnEHRO3lPjDVCr/wQ1pTsh0plnDEiy2s79C0nc5k8yu79F3IVK+pP84nJQDNqYf+iXkcZi7w+AMtYQfphrXvqn1aTz2f6z/0xrpJ3Ocnv8DdarVsYe7874uvqjj/xvfvGIYe0L/v59gkhKNtEUQEmi5H/wRtYjkuS1jH2V72xkt+/mMGOrRaj2Omf3ItVOSdvsOj5jUBS5nZl5/8NHIsSQpFK7Opc1pbHvbuDA/WDqNb66M2Avm1rOHscX/nI+OFOP0rQmafLrs4hAx1solzFtz7Ou5zbp6w1XUKXHc5Dd8+5fzvsHroG+wjhg8vQidZ0shshnTLsh0BvwTGP1nfNUnwXtz5r/3QcYIXKs7hRKgFSSw9zn6Y0wvECJqMX8vre/tOtmqveS5T69sgulB7nVkn1B7wp+AKhTaCVFO0mfQuYTZRmX29LZSnUBalBSOdCLVivA1Of/3mH8t4BHeydQLibKNy/T/YzP9+0R7B48RzIXo5cDg/aDvWnurb6P7x/tNP/S6V4u4KcSRb1Lr5nPygZ60h4frAXP21lVyM4GjN9Dl8Z6NYM6f47/VRqL0XmH3e0gWHHw47Zo/mM72hzlKezNWT8nkP+zf/BHH6B19OmqsqPolh8IzszDq4Pje+3/x3UsZ/6rulHD4N5S2aIicl+Tc/Jtj6HP4fzVADb5DtD9rWo7YPZj7z6EdRB20xqanp+upaaA5lCteSdA9Fu/Y9tIvRFS6kB5Pfba681UovXaiWzTZzzKLdDtbHC47YQ1JBY5jripLSqTesD0B1ikkDVTc8/M//HPw4//f3fqN4M7y+cF80F+6U2Ze6RBkydXACc0kZ1Zpj+Bx+ChLF1e4tqaGY7ObQPZvBcP6YslWQus36+o992nHz53mevoKXK7nDR5iRjCze3Pyb1hximK9JD286GLdAHwecfdimYA+amun/ME3H0mQuBh5C7cn61M9qqH39+HuCz/TL/kb6lppFMOz/z/2VKiekhUVnB3QWSsHuW5/3ml3pNz8u7e9QBttJ+l6vOf8VXmSsIteBS3gOFUUaBUfBHeqHmyakWrOJEAwnxcr2rlN1SMdMxMbkfTsakI1j1ErXN/f+4CdYWibVdv5f/Q0Iv+9HBA8uPjaeyXrhNALm8AW6GAfMwK0KfvPj4A0M5cfAxSQXrpN2A5YF09Y63nH6iXgrgNRG+tTXEMpeArjEnP97XjHUTEvswPl5K0sKBZz+RGMRdhipx7/XT6AoOzG6EM5H8HsUoXHnK/7hIKy1fob+UT/8ez8y/uQn/I+Oj87LytVev9HZkqIVYjqAq79uvCMVyvUHXxUt0snJ7Yw/9bF0Tn7NsSAQNbZKCeakHIXqacrtb9ucC2ft0fUSPLlNGJnXhuP3sIADbI17BZJpElKrMYMhv5s76l24zGMFXkrVkfFixNF/6g9BIjH53+1pVMDH5/xz3BQHaD8eN+pelioQnCKW4G0nvfI+ewbqt37FmeFrlIbqFZzMuIcvVV3I3mvJn39uPHUONhbDZ//NDzlNoAvnDdv/P++zqquOuz8kThYxEEoY/Vv/R9TncF/d5VabYe7+MHxEuEB6JA7XZ0D/xs8tkzmc72u57mXI9c9u11oKPLMEEFjZrHHTJbd/v/mzVwKgDTKnQeUh9FBshBVgn2T+9/yi9er2+BnfKoONpS84/57M2MYndFE63/c3YDbMP/oTX/Eu19B520aGDxcz+d4/BkVHbUHWV/jUx3O4kVPW1Xmp6x+Vu4HTMOn+vK/W90foz5ijGLwzxJ2vFqEaqoJePmFtfN5/jN3R8PzuO36GYmGgJ4sCX2ZcfX89HIGeQeLKgOkjIwW64MlW3UzzZ74Oqo7OjqF2196nBEF5sb3VSv9gM16383mRhFFHv/VhAPOf72edzTAJuftrW4+ZYairN4Ll1GPWZHbjzke/+V376O/1U5l/Mld6bWnBN9zXuZZ36Y473/h5P51sJkz/6dNek2hdGNz7f+JdAFp4i4byh61NWIDlanenTgPY/qga7vvIeCzWxfHA9kf4lmCH1PXbgGGYa9YIaVz7GF3RjqRVMqwPM6D/vO8KxrjyofV8WJkPef3o4l6w1K0r/uP84vv+7p6tjy/W41z0l4TD/9MN3uEDSnxYJQWi7kbk5udnfLgK2P66EKK104IiFa43NCgszWPyp4boBdO96MAA3UE79k39QdSycOHJrt70J78JLaes/d/8T+XJ6RdPvApbAJ8MhRezust74HP77/s+6Kc+68xqGSjopxx/kDLpBt6nvkvyjiehZjSM36q6CE5ahhuN6gULFJu6BcuARrYLVoP2Kf2pDw5Wn/otn8K4mZ05vH785AdrE/jJHzp+qiHcn9z+D04KnMF2+/HfjBgAORxx+jeoT4jNQcfosiVj2080jt9WIuY/jxLW/29+65X7vvNQhLP6+tQn+z0/QSuOPzxtQQxWn/pqTuhOramrBw+MJ772U1+CkomBbuh1+9SP26R93YvdoH365/7nk//meQ+nIZXOzc/3/YlP/Zv/5Aut3cKGycS+Uiu3NKBFV07+SHffJwBZH/92vdSu6jNMHLifFXMaTHpufkgbCXsV1qz9p+QKoWLsOPr3fnDGxr+MW7Z/8ZLDXz/17+H8U7/u9/12IefoP/enGp7o/6s/x9vXn/gt9FO/TqjBuKZdz/Hr0Q7ZJP3Upwupq7SjVTDgp3/eF/vUnzvArZhKXsHwG5GoW+ACthTPd7jCs7ByIdBbSRK0PBieH9vTs3YX2k99OXF9H4M+Jzx+/23fZe3/5h8vep/Hr4XQqvjK+MsubHMQYw4fk0QWDHU6ZfTf+z2l8v8f+6XZe9a/3/rF/ZFrHwoTwdDST/0Y/SQbtpde/aH8+KOe4fPwUx/GvsVdTb2Q5x/FggvOn/oyW0qZfjFUX8Vb8dCA92d//twvaEBMXEg3WUTdhRIM5c+e74UJCD/1/0QHCEBaXHn7MFGhTeJKeAEH1tOWjZR7f9aAM3tGXp37An0XyqEiPTj/74uPr4cDGOFckcCp5+/fPvHd6vqUd+B20HETqHt7KB/WBCMdg+PhAg7rnUVnd8z714I8eWrGGbzA+tSCVq5Mxm8u803u7uGDkrPK7OlqKxzAb/3y84q3X9O5fAXjZ3gb3h+yRS8Bpg13f0dAKbagMnn/SO+EiUbfn/qJP/En0pLzb77xPwFbn/5MNEDBy+fHZ8EV0i9M/ppO1zPk3Tj+7/tNhhjCsu1v4TRRue//3B9j71NfZ554NsVrnv/nfgYKn/o6tm1pUnfT/B0a+69FbkZs/wTBUdPU57YKv/r/PfT/KP3z/iGj25sC2VaT8fJpbIWrsPzUH9Ka/m1p1xE3Pk9mwIk8N5/6tvNsxnbbhvMP/UnL8FO2+9RnmbXPcJKWHP0bX9wyujNtFhSXN+8v+EVg83+niprTQ8Z9/+d9ExJ86susLfdV93Tte9/zNfgZPwRMv3Uwib/1excnf7g/ft7fgP2nfoz4rLt01BzZ/Epd1MLd5/4JeyNUYOXK2v/zY/r7juZBYZ+zmlqzNdqgbs/wmZ2LpAlsn5dvZsEbeC6jLUTzB470Etrc+ZA/BnOh30YpM/O6Tg0h4PFLLzP7nLdQgSGOiDxzVG5/eY4PFLCkbwL3D0nOR3OJ87/cdgI36GUUOdyUCZEZXrUfaH4E81x35DvDlxUco3ceWX/qE6e2igkDGfk8zu7Ua3JtLaAgusPxgSIbuTPbI+48YrPSeAyf7w/Iw7NdvgC/8R0bnzufCWQFF7h02fyOJEuUOrLjzk9NV0YmelEmf2Hp3gFoTf5+9sDQp3BdsPmXro1DkVx5O2SODlXehcX9z/2BxtrfncA4l68jzyP+LL8AarP+zfI5yNXHgdHt+LPb05LDj/qpgibaemE2uN8ndvZMQbtmIkeScqoIUy+n4PgsbFlHF+59a/uxZf7hAc0BXFqynbnVlJt/yDx2HbF5y2Ex1tncba/8+ds9Ue6g2hQtzO96VOAu48b/k1+tJefP+T/zfhrsUf58M44ZvivSUwg1JRyl3eXM6Yfv+2cXhg9+v7/h9dNPfI7AwOWn/lcrWwodcfeL5IIEX9je5un3/VpT4vSTbvuCAbYJwweKUmFq5gV3PkmWiYaAN/3Uq98kZoYXKkd3JjswB9OiYMN43tVWuFMuftcbLVGE/MuR/Km/jTj98K2/HTF8uL1l0NbJlD8f/61/7LH+SU8xady9wfNLezXWdi/m/3tZKbRTfOXPr5o9Vsmo+9yfVDCO3BV/fvA9/xvHgO2fVmkBlbjzG8OHzL7v5fcc2uXDKoiMheH5rKmekECk1/wJx65qRdbh+OTOd3ofpKB0O/9bHxd7HP76xhe7bPyP+b2rNS/m3s/zvRXYgjZh9tea1CMAxirX/x/9RTqbyUePRTsi+ZG/v7feUCbylslH3+lmRGDJrR+DZrpNCuFT31QQo4IYKTd+Etdsf9t+8YYv564A5mpx8qt7M3KAFon2cHMUXRquFjz+/K0v8NL/+Ad+zvUP6xfhKQgffEoR89+l8ZnDL1ZagquwuXfut77ue8ydf9nJmulD7xaq4GhXluy/Vtz9MtHfDH/ez3kBFqSW2ymziJx8SAlDZ+vNXIF+XivgnZ+58dm0EI7aw3stQDvZfUqRGRzdO07AW60rph/WCtBqJic6h8+Tk6oJihTVUK3Cdy0VFz7+ejIFa029zv/Up16ZPL5Y1GiMDnJFoGboeoQnS27/u5uZdlb1xcd/+cWvd47/ez7kM/kCarSwjSjg5OdrH++s/V7aocgAqiUyewDSfPUQ6Z/8vNHn/afRp1DATrKrb/yELSuf0gxaDnZSsoaaWiv5WLvYOpx7x0URjDOZfuvDXcU9tBZk006q9aA+G6Df+tuE8fsZeEgdmIf6n/fxPIU696t8FtbeYv+t/5wK4ZA/kJZ4hd9Vt4Z7w72HY48Ew/hj51HrOzTfLUawjZO4IKNtyMUn+wAeEOje7wEdd2dg5UkGJ0P69/47DxM8T6NJ4b+88Z/44HU3/9Y/MBaBiDDbhvlqDMeURI1VoSTDbP+s0x7I9TRIoOIIk1x77qbM/1/qGFVFj+DyENkQt2YwjI8OwyXzD8blAv153/XG2p9Zx6Q4Nmz+3Vxk+ukxRnMo3W0ks93MjR9vH8JaOIjIgYLtGbbtpwE3f5/zA82zuj18JXYA4bNi47so0aLQXnpHnZrBe1L4ePm3+Xv9ff4I8yN72EMqDumVDIkNBS8Qya4vTjB4Fx311MrSSXHunlA2wjalQAq5/L/qOYq1+n5awx5UdoFujB8+ouMcKp/zF/SaohnWwduHx9uD2MF0O6yvQnVDgBn0OzZ/S996pn3RBlx9iN/8otnchw9HDWUyEQIRqzJ4ghnZSdS/LuCD+bOs/dUzFICw/tT3NAt4LlRBnNKZ5gu+etXLJWxuntt40zjQcahRCb79Yszc4C1+YEUlDrybYgCD24yb//9D2LW1q6rz6h/ERVFQ4LKc5AxVUfBO0VZFQUVB+fW7qHNNutYY+/NqzpGnpU3b5E2aJt/8tFAPIMfLk3SScgGz/tlWTeF7/95AORPdct7LrwKawE4lSZGn8y1sQ5GCsVnr99dfv8XUvhcuLdVjO4q/QTKm5/cFnwlcHpu20cYySGTlQM/fw47kRLrObUNtF/UVDKd527zrG2p5Ts9vfrqJibi6WDF0hUcNthJsG6u79JfdlN9DMCpAIoq1xeuCvxPxpsgGf+r/dvVRp50RETpbJ1d3M1jDwSSX/vifjXgB2yt+4iaOHUMbwadLxjoSG7OccQPO6epDHZelI0LfcY3v+9QgFv7Y10tj+s0vKO3cXCeY2GQw7eTHttVcXbXyAEp1E5RQ59w+/7/xgxKlXyJjbk8GnNfnvzFtuQj4HG9SMEmFqGHd7D7/v/j3lptQSHyT+Nxw0ud/OJjDgz680/4HVmWIznVv9L9vVC9wA4dtvoConcvF+KrR/Xs5kooIcv76xJ9DI25NuDEQxaLLRcj4r8OdfAOWdBhBW66HwsBO+/l5GhdtlS2XPY8BrDlJtF6jvJ+fpzHuWyPVyuiofuMHh0z+3Cb0seyA1+awh1KQp6K2wx4Pi7q+4/0uHjcTLtSgftcpf1xxc7eAe/EMbW1GKU6kcvjHvlvwDqwu+CkMLMGn88kwD+iwhs23PrnOq1/5U+V+n//mfsLt5TN/VKDlC3z9vIR+rnHnp09uFJY2VgTUWM/bOZXvWaWn5sL2mPPR5ddV0/H8DtctPKfhYcWs/zf/4LVVoOoh21a1jDk/mu/KrTI4tHcIg6SK2nIX8OpVo3AfAiq/vvXlt+0C7hXbSnVh089v1FjkSU/b6NJuv/lxbS3I1aegalAD8bCxnkf6rzA9buF+Lc/KyewRGFRfNTWsQPWi+IoYjRpW+gluJ/ki9Z9MfqzGu48kU4Ej/Q5HadJEw9nLZ/JbdP4pPdLa/Z/8rw+fyd9SydRe4DZU/tRHujP9bEjpxCUnEuDufUuJ1VL1lOMAekLxKl7zp8/k98GKIsmFSe3ncEetJeMaUixbSWgC94H8aiaPDRTh2KT7I04xnzypMUHlg4WW0MDp8E98TU3XJ5QahNx5FNDzT9CFeJjqx/f7NE3YHk/f/MFbgdkfcKIoqlIIVP7tnGqJNNNwefiS6hE2zvarMXeOijQg51T+7m0PWpJE13/kdvlPfJ+n9tdFC/WzxAewHdsx1JZrh9c5AV6gw8XPxlkeuQAUBypf/H0+s4P9wIm/9W1lm29Cnv5PnXfnF5aSkojZ1c41JZiGMErFQRPVJ+WocOI/9e00iGJoP0AKConqR7cQYazLzcnq0//8Rn/8W8Rk6MtdJGIJ+9/3LergOtD/3/aN6f1E53+ma/W9yaDxiJvGvMbwqhrcgPm+xDUv8tznzR/5KZs6TLcGtFXF6uGDUeO/brSN/FhY8Lq0p2k4qyJe/RTNdPnBf78PYS+/3v8a/z90RL9/KKKB0F31Gz26vTCp/SM/F33+6CtI9nDpZANkdu+z9euImR/FWs0KphP4RN4jB09u8mT5v79Cg+zOGY888alCzWoXP/P/U1+Ak/Di5/X9k9/kt/Xp07/n79DnD4rSAViB/E77P0/AyJLvlP/qVa4x8BTC/7d/lr99+ud+Dm6QoasXaq/fIXr+j/E9fqbr6MDd8EMx6PqK3f3QzOmSm/8w/7/1zYv/l06MTZ/+WsIx5I4y/zNdpebJClxl8vzEDymbI9//vnZMIbVHMT2/xnINdDkL8hsc72xDtMTuWbWypcI9aZpBv//ZLHoVw03E7M/v+9W1cYQPs5zYgaj/tH+79mRyG1ojPkSGaggoI/e4ev48/q/82NiPn+l6OdoHREH5AP1I//v9/0nXXKQhrWiZ9dH9BhA8l+IWaTuO4i8zovP7+DflLd0f6TkiODP9tt9/jiPKO1Gl5294p/oRt2T48/e1pVgjoJ3tZ59uFkfO4vhXX34wdCm6gdH+wdBDZNFGeGYw+2t+pvbQLYv5P/V/FvHt5/lbxwfF/yQ2ajirfTX1YcX0b1xc5S4Pdka//Vd/j/0GaYczpPqG5P39q5+qrtgw4Rtko4n60teDGPfbf+qDhvytP7/xUlcKPpghahBG+wWRduK9T3/HVz1pj4bOO7UJ1pr//IW/xwI0eOllfDNJDHWtTvO87X9/vH6lcKekdeMOS06RF2Ze98evaGELFpXf/Hnf88yFPh0vgIT30+58HyTlyGEQSz36X/79Pd//P51Q/n/P35jRH5NiqJbwvMsBPCbSCw+1B3u+4rWWQXXCC3Am6UP82lUM3bjyVP/vbsz6fesjRzKP7Meam8pX85/0j2/+dSnCCLnnDfKzORC4wdDozx9yz0YgV6p/kTnltAkcVXGfv3+/j97xrwpWeOFn+lc/RIz+0K4v1YCLE6GrfWmVrbIW6fg+8cXtgJHf1mMMLE4X6fq6SjMvLWHP0L/vj1La3nkRj0yGAbO/VbwDN3nXmMz3D3eAgDu21U9+LPnlM+dLG553Q2AMNLFu/qwfI1+4LKQqTxQG0VPguUi5mIz81a9TfMGcbZEaND4ngEBhzo/m6NEL2KW/aN71/7RWYc6Pph9AgdcG8X+R//wYrsmArkozKQcU39vGv87/uC7wYyNn/fY4KkThFbtUPicZWZGqQIs+3SiTUSGVL3o+HTFUwOlE+dOje6tkFA1HET2f8gtfgGTOr9GP/NHvRjOA+pZ+68fxw7HRJPC8aC7ond8J3nes/jxJjwd22+aGDLPkBop15Bn5VEmPPXggO0chEMFedjc5s/9RSqVTfBD3yBeuwOR2MdO/ao+iGEyjLO+P710/RL2kVL7rGhhiaqWUfbqR5ratm5SuP3YAYGr173+RT+6s5jC+Npuf6ao2ovgKj9C+sclU9XW8zpn5i8WshOgq543FUZiiDf91vmv76ZG50L2/2BtgoKArOz80hzu4Mqozo58/+clH9HxwahPBvG72fTpIb2309Kj80T7vq5fo+ov+/ty/xfblE78Api/zR/z3+B/4NmfovqGXweBOz7fFcyOcHcmlT59x4CXwxSTKdelS3/BSaJ6/9K8E8ABHmbH74/+6MfhXi8L9mSSL6tQYuKT24bhi7AttZ8E9td/gorEONVAU5cDi36E+hRR8GmbjUJP+BaPiZ/wb98f39V8tolyd7WFBaofX+vQxyR3bH9uU/gBRhTeyuP0f/Pvn9y/75ryJNhiuiI7e7/9BfWLsL601VAI3h8ipJU9TXS1Zs/LZmzRHUhz5GEW2ToF2tGHti92wHmMVlFtkgQos5LT8Zf7/A1/nfXoZ1i3gdy86f7JuNHjblLhPF2pLiZ6zjO7PpdJY5LDIJz/3r7p3PAIrt5mjb34/i5HPajWEAmkb20L65crN5ejIM/jm3CWmrPM8RaG+UC7A7eTr534y3VP5qO2QA89TmZFvJzezUnMUU/mx8+sWP+co+UX+ffJX4bxEdquCBTe6M+dH5fb1EKzOZY7sk6BOtOmJXZ88UGWo5s0DebMzwFzQ6TdrHg0SsZEjXq+PDwDKVXP5hT+LEAyA7WbPRg8q5QmScczgg9kSA1wrafP5vjq9GAx+mpzQBmZqfGu++f32bHs9oNZ7OPf3f/yfGoM/9NEJv0BcQoKig67OoF7zffykzl1wxALO9T/1+XwWf121aIFvC/n6yX+l5FO2f22OOTDYVJtP/VKwXDL4RZ8v9jwJFn6J3vGRcFez+CbTyZg4R95EwX4FPBAQZv6Qzk4ChZhTfeHVmg8PVxb/6S1UoTiEm8YO9tpBnRQG8/3X5LAhHLTLP/ktTAZ/asECRrDeeHItRhg+oBvQ8SkJsUk0bNDf+69R4+3X6kHfQYpfPu83wYGh9/afAwSBHlstkn+mF9mRi4bctZcfYtSogyE04AlS/fTNf5Qhv0f/vo/O6PnZVtWE+BlC/fYel6guFOf/6G8Ip/32ve//SDeqtUpXG9DzO13d5Gj0clClq8ZOwuo+G/7cXvOmT0Tcof31TwEu/wffdfTv++0Vz9jX4+gmA8WKkK9SEOoA6yYy9vE3/8UqYvwv3flVRheqPz7vC6Us7OPz9/t7dX+n8vdjP47kkNeyFgpUP4k/+KcgDH/xbynuUaxfEWD6t7kAXEAm5Rh6GTXK9OmOob/zD+r6i65PKiUjPEjOzP7QWwFMOdRS+S0JG0GQRwtmf/jVRIWwtKh8Mq0mKCeRwNDf+aGApfXG/9P6Nr/RHVDDUuUw1c8bme+y6a2Y8QXSE8yVuOrj9x/29xsffOpXnVCmPS7hE1sv/0f/W+/7P/Kf7g/LAAq4z8pB865vrCWXgfVT+3/GH/2DH97tsRdWuFHzYaPaD3Wmmt34t3wBoqY5M+vz1S82tW9IgEwEFxeG/q3vJ1D598f/8tP+eJ9vSZISMZkE/fbf/Lqd/+YZR3U9qKzA+Ln9UJR9W81xkOszFabEDglzPqLQj0kUhWGuaSHZkG3dMHTZlOhWeFQOc37DIeT0E6LyA6elj4JBv7736HM/ooQqxbcWnotgeO6/nx79yd+n0/NfX4FcN4+n3e/fTHINwptL8f8nP7nDT5j98cmPtqT4mIglTF37af8iH+VT3uU7Ddxf5FNLeVMGt5lX/UxXkmKJue2Vjh8sdzKYNYiRT+p+M46ae+P4embvRuBx8Bn6/IFBIuVH45f+z5mv2RM+nFSaOUUhxIHNyKeBaYelNx6Gff6967Nz8V98DmH0Q//d/hfHliCMhUcka7mGnhBBY/ijfPrl/D3V9oab1yGUNVMiItw/S+b8HaxqLho4DPrfd2sDljq+Lv7UHx8tgz7/v/WhOvwzJboiiMOTz+yfLv5Vbm69+QW/yJ9ssBnXSn4I+9+37hIVKfsj7f+TH2R2o+NboUjHywz9KB9+Wv83/4JkWFBI4mfa8tDo0PQzpv2n/q3tMuO3zBdcascRj+HlehvVA/7MjN+7AXjQXzI1RiY83d/KEvq/7I9yBGRrcJgx9Pf7BJ1L8wKKTWVBZ5V7/f3xxu8gnVH6936y+35YI0zm64rdv5JsNmq89TN12ao6WbQyQ//Uj5uowS/nS38kK6vJpsz5t4HP1TJ3o/rxU58mFhn+TgZdPeuwoPJ11wAAuPpu98f/rl+vVB39fPJGQLohi/n+zYVnfXNd/N0fzv/QT+Yv9LVVjyIpkaxMb9f4iWHGru9lcTzUPHHcTJdSCnqbiqXXU6ERmqEP++N3Xnuu5vCFzj81LWpWEfT8mz9m9Mlfpe0PdH7FSoyI3xzVvvzuqlPPlVHHP39ijfHAfBr9/t/yF57+2q/M7+f5/6AfOvpJzMPG3paqoQqH6IG9W8XMj99T+T7ZOFDWna7U4Fr2GfrwacRpMC/8vv4KrgCYHCipfuJccBYke+H9cr/grEEdNXnl9f2n9h7R86s9qH32wT8z3+33/8WnF6o/vvHTctCnv+Pv5HVL9QdI8xOiGMs1tMBthlDEOaPfzIPhltE2pePfx2hI9v/Sj54RHaJBnjm/6NeddJOxGBQBg5+UozLnCpXqJyG70RM8e4a/6J8zh0zRO+4Y+aUeLC3XL0an37b6sBalmDl/aliBrewQo4ANNOJGUwkjv21XpPOXnpQeiGWUGnIdVnq9rTFuz+z5/9TnNdYB1Q/7BsH9imfop7KCDYUa0S/j/9TXsY4Wsz7+Ao7h/k7x1XOY2cTczpn9p3MGJHB66+3fn/j79p/MDBW5lmH398e7vrJWVycdhmZ9t55R6DL9d/XD9NW9pz9+2n9d/xMXZPhlEzdWxzWpIHcrmf0djjO91Kaelev8NToAW7IZeiZDR/RNi9n/7/realHR82vk3qN+mZzfH/93fJdFJ9+iFxaNI4PvfEWA1B7txj+MDaO0Liev3/83/rA4/eXfT/ivG9/tAvXGd69BrqV+NARXx2DGf2oKaj+cl36sfvJL3lj75fP+tzpGjPxt78oT8N3+aq52l6+ajzJtYECe3K8Zg1+srNIaW3ha/fmZ7oNzFHyl+PGS25ZtKuZP8ul9/vbQIqZSqv327/rXSpnT83+WipcFwhG7f5QxiGRepPJjHjZWGqWO2eefNliCLfB4Kh+Wh2IMnnFs5Wp4aa6Qj1j7cZD7fmrtzndGfv+lz0VhIDyjCPJ6+CAN4UL2fjeOjyLg+DljX4f5HsbaPuZruK49AbyAxNo/n/pwJd/+80fGPqHKXBnJFxzXPbrOFUgiKqTn+52fFrR7xj7X9nmkAyqvB3/y0z/yX/r/1o8CuQCPAB+i4V4CUn/+n/xoGeV/wSMTdldVzPg6/wfIlvT7t1XsNRF3GR577fXRFtwUdU/X5/N+Kn/CSivnYA3kOc/sn/f7bOeIGf6Yps1F4K4aABqhLhevNWHs13d8g27lsfDNz+BLDD0aralQq7j8b3qLqa9WECFy06h9aQgcNXpMj/afjEUvNVZ62N9fPrLhQ60v9Pxtajpw96Aw+/tbP2xG+Vfu0iWZ7FZun+4VUK30SI5bWM4yU1RXI405H5/89yb9frtKxkK7aCGzPz75i06G1D1inpV2smLlT8dfoOZGC71zqhFbZM/ft35fEQN4u86r5MldfGb95xM4gYVq1BCvpIHQ5g6Lv/kYmEDvzo+egBUeLQ7/xV8aPNP2sZLIwlhK3b5+++avV+n+dingEJoxYewbc3WAmVqPu/vVvfCqXxfI6ldfoPxA87yG/kK4AeViMu2Np6o91B3OJXhK5QjZD5uxTzx9CLsK53T+UlFOUmNxZ+2Pfc1NgcdR/q6zuq05beUw+KTLL67bHg+gnQiPREJ3hv/v+r+6OKL2/df/4kIG/3/qFwf0/J2azCL+M2Xs23d9TLDYU3qkb8ZY8BIG30ziDbdXrIzub+Mh243rYca+fcc3qvclnd/H/6doFmNf1E/1ql81ur8eXOZCB8Qsflqc1Ie+OFB6mfBQNBYV7NO9+4niweOLrp/uSlKtGBcG37ijqTrUSHe//ck/JfvM/rFeB3WiNU86P39uuMitHIc535/8s2t6fp6PdhwNVzyzP9/+LQWN6PfXfLIFY/HgMf4DYceNlOr1z/33W76Nmt0Q7B3x2ajHiXqF3iLu+w/VMV/P8GJvvJpvfdQBIz/pij5anJ/EhvEPDCha93wTVap7wDYYTsTXz/5L1WkjHmezZoBgUiuYk1aM//Lv+P97v/CW780d+xRKVvzP9P+2/xuf9P5+rj4ncFz6TzS5Z+oLpjBnvt9s1ZhMjfiJ9KKihp87Yefv2MDFq2s+QN/3m0sqvy8DOvcJ2aJKz19RhQFumPH5SjpBujzp+49RtAiUjSyk9PvSFE2aIHT68v2X+am1lhKwlh99uiZiATeuTfn/iW9sjR/iS976b+eTEVnIkGosu4Ghun4t+v4/dTx+vOgMMx75IwSwEt1Pff/ft37Ck2/Q+32SKsJf/Ic/xa/9uL5mv71+nJGAPMKMovDOvtUo+P7Zv9nv33SQ2Xgbxv+L3u/TwPRF8WfjRAOLtyn/taWNJ9gz48GP90c/8P9/jb+LXyyLoyiIxz3T3u7uNzT3xvhPNbRFa6htjOZPfa3ziZn/7DadEPfEvz7yWeW3tP97TO2cgBjd+bpTIVTc/eYn+7Y3vh/up9/0r/8uG6BvfLEZ9/W/dj7tqVZc80/0jR8ymPH/d/5/44Pe419dnxFMjyXdP7MJdwE8YfCbuhqDFD8qu0FRocFUOyHa/qFWbqNXBnM+vvjQovrl7T+B8Yahw+LAFcpjGP+M3/7u/z4+VK01aeD2IDfN5BRwXQW3uC8ftRWJMjAI0AxF90g9q2fCyEd9vsA5NvJy/Yt8ulpRDlaWrf9y/qihaUGOSMfolawh0aMN079G+QMwyfPDpz69vNzyDD0pIglbqzRD+vmualqZxwy+ja9QJ84k1ZGTp+paX5RUfm0eiYw5Z0n3/x03S/KY5bP++IZcCkt75FP65kJsmEzLH+I/3v0fVlCBtzA/9elH21ZhkMl0ffgZEAFyvPK/8TNv/i84IpIMY+G/8Ufv9dsmSoprtctPe59oFVxPGf5846/B3/q2/2p/ETHEyc2v/sTPDwzcpxcXamjsdLT/ub0mYegQOUqPf/KznAzmfo9L8Bg0KNs2urRRCm7yr/3xeb+8TKsmvNhqqjYFo3/0iwYqvOQgE5+0CyUpeqlUfmuHIzXKzDRm4pu++Qdiql/O19cazhLj1KcnS6iL2pbKN1V4AkyBjF39v/o3rm4IuicQcfOE1f/qg1PxlMgl0spW09Q2pfvn/X7HjgqUaZ/8R2F++R/694f44jd/x/GDYDmOL8jYqNCGN37xo/5g4ie4J3ShMX+gTJ1NwxPYCqTs09/vawW+45/ogQBPQrn5RX5Hel3jCMRdfU0ATPnwYOSvRhfXJllendA7v4PKNQtG/l1fkQKeGlmid30StSlNhq7P6gI4w3iCnOMTTtRJ9bN+ZOJH3vkVRByiTF9J0CDGkTcY+rIAWIhmVL9865dRrPHz/P7z+xc98RsTPoHvNkay4hyO27D4a+ejgIBBHjfOKYFIFUtGvqhPOcrx2t4M6uZic0+FYqUbPCSZkZrGlJ7/M8INVjne+eV8LUboAh97ojZmtACB8qgY/kOQRBeMRvUx4j7xb1eWv3xOPCKMeNR0hV5Ocluy+GRaRAQ8X2L2iQ9XsuvpZ/739eM8wOMabLZ0f9PdfwDhJWXik8LzbRSJIKH8d4VGhmch1f+H/s1/oe8mgAePbVX8yd9eMPtf21/wEC/lZt9Emy4+Qduz+EGxHic8cMtbo9khrPTbis6fu5ZOatoUf+ta9+azMOSS8c9R668MxIDRn+/6udr9xOLbfH/PwDlr7uibPzJi9Ks6vnAWzg359PEPKGYT9/W/CprdlepHufhTX/TJ+FdUc8OdwCKn8un7fqtg/DfQf75dXTFBUVipPFxDvo9PdHJ9RFjV4A2987vohsDiF9rFmYgN3Z8guACTUwfM93Ul2btQPJILCnaZOtbPHN/X/yq1ACiIU6j8DZpA3anbhmmvcQKcwORQdmWeQzBSRi3rn5pmjQ3HMjwiL2sp/gsJwz/d32Ae23Y5Qepgp2n6TGPmB/Vgr5JX64m11MXPwnbNzE83u8CwR0KWjX3fgI1sKdS+3y2Il9qHa8i8L+nqa+ledz5KZw7wwA7DfvzwG19qvNCTT+EP7w/e/s+PfUzCXPcmjyGe+gaDvwdFrKcOHvT9S8g/i5wgO3BA5ZdtCQW/WjN0x025Fhx0+v3yWFB8ki76/kGkC1hFqsLlGE4OR7EW04ihG/Ot+tIGbV7Ak+DbpWFc+/Er6F1/SzFE2n5wTC1oLe/M/OnW0pZ6e+ULaKyEZy0KVWSoWdlIELk58/7BjsCgGHLj8Jf3DfUz98UoMvr+D2TACwBc3t1/bWzfSyc4CZj1Gbyo/AQVtX9u56QBoDX7/msE561qw1d3/xdY8qwxCq7vv0f+4gFLdU968tH75X3Qnx/b/196vL2tElFZ9++XUNTVf9fbgo7vm188ovOLo6kJ0Tr/8X2S80v/WPQeEdB916DALhrhhdsw7QOKtpuAv1L+3Cqkk7tkM3QJ8xPb39r9+0UUnghYAf3ek++9H/P95chGpb679+8XkWpOwJxLr3T/BXG2RloqVH/zR1L77XO+uvd5GrmJUYPi/v0j0reWamvDe4//5i/2L37muq09mPtb9M4Pqiy791+uBK00mkyo9PGm4QuPs+xn/v7Sf1zGWmoHhlVBccnx2JAR016d5gh597e3771+Wfpj/+Yv67cVj1Lxknxmfb/+P4vix/my2ZYaGro/tH/fb2ZzmdrHN/sX+qJqkGjuLm7/fEVopoXQAxS/q4HAJVxznjDvJ7r4AgpN6feTrSQVXNsy3//WJ8D0fD8oC2wq7Ox+e53fwTPEGsUvaQ5GwjAIHEN9vYMCUcycf04oV7b2lF1eqwje4elDZN5vze5tEg1w+tP5e8cXWbmZwvvG+OV9V5ISWHqDbBJr65oqlvWGMP0vlPYKWqH0+/Ozzokqa1eRp/bNOvcIvIz9/ve/75sndP6+hRa2Mcf9+7c/+q+NMVyeKF51XdX/ZfxUG2M7rJ4eI/+6+COt6uKLg9umsQQw9Xn9+iItvI5lhn/zRzoRI2/k/8mvYCOGPtuQmKhoGPzCn85EEdXLldEflp9Q/CeIBoD8sJw0qukx+uGdn0bmZEOAwBa1xj76jPx95xfXrg+6vzZFfU+E26J/v/HR3zBsqf29lfwwjWYLRj9+8xvsKP/9DI8tOdiGv+zvT/7DacbM720/ypOA6q9PfYPjscsf8K7f6RkMf9ppjOzJHNHxf95Hn1j99Mmv0w7C/+gHCh/5Gg7NQq55Ydr3j6N3fJC+7+KLdisCkWUAm5FvXX5frenww+yGTOiMJK8vv5yVr07UV07lo71pr7Wydvr3B8jENlxq+7KHLzzGf/P5dfLlvsnT0odHN9OmBbzBpSf/KJ+CX+TfanzkKPDs4pM++SX+1f65z0KotZDhzze/zZyXvu/Hk1X//gR936fd8iOUL0VVjLN59MP43/EDI0uIwM2n+zOIGploO57x/37yA6BT+It/95SJXunyR/r9nfqckSSQmfbLSyJZ4r22GPnnpdQ+WxRU/53NCpHJiGPk87c+RUbt142JgaVUK0a+v+vvytae0ttJY5TmubZiuMijFDQez/CvecS+HWCjf3/0wXfAOdP1/eaXPzHro64FrpAjQvt3BADA0D734zvQNz/qumdf/8Sf7vuvJGkKSXsx6/PO/6hbj8HP8X/M+4p9M6VCyg7l7/tqmdV/XkAMG+6mQaXPr8gmd5/FNx7XQfHXiJ3/5/3wngqnGpWwsbZMfBvy1ZjbyLjzz4V2CsXguGTOh9Xuoa/Octr+tkIzpOfCT/v7/T5rEDupOtdDhr+f91Fb2j+SUl2cLAva/ye/DmDvH86z9hG1ThVU3/MRlgy9IQJORhr66Xy+5Q+WTgDc5v34NhRNpxRPPUp6Pk7FfFmMH81P+OQtnw6NCtW87t9vIW3+4vbcgafj/+S/ex2t/vraVUbtu1N3/oqVcMPjE+zH96FITjhVmd9p+20QjcBgtzN/OV/HvSUKr1lkyerKJDeCOZuZ/zd/Knaz7/vfOmPo7/oKHkJUvyzv4AL0Vzns7w91XIBClmu1P763fpCdK9UfeHAEmB/IzPiCQ8pRc3lMx++qfNo4DXzeevhzggvuxF1f1D7P7rcWvIwD7J9f57wEC3l96PhfYtkarA5Cv31v/NxTx5jb3UAr7wSok9OBxRebVaxBHUdqpclz9CBGgJj5T+zMRZN8xuhXDzw4lXt099eja6kRLT0YDD7o8idz93VO8dV6c08G57AfP4Xe8bEqtvIa5gs+TPU18Zn91/mXAOniMxamXZR2fnWZ9T9B7qhcR0YLhbH0SoRHwOKXrsg8DACV70EsH4gbDPvxByiwDfWgkR21n0NQ+aWfAuZ8O/MzlDV4MyR4XmQqjI46I3+++rXJhW/+vLifn5Du3y6/uJZkdHxZCyRLHoB+fBj61l8/0PGl5nyZ8DOVGZ8rFUrLiblRQ3Wjj4rRecTMz9Cv8Aq1McWvn/zEEz3o8/8dPwHNgvLfbucH8MzGoBd/gqz8zjmK1vkfyJLKP0dXIOMfSodqow+6+Ain9EMS5DbT/9v/pN6SHMDHIYOivctsBl986rdqFH8l91tlCWnOyH/9OVKX0FMpf4BOrMY8TSeMfujiH/Q6ovjO7Ioyq7d+/lLa3nuAEzeTKP+MszQG48FV6/P3bR8q+p3uz4gc5WiQzxj7w3wJyoDb6t3+Ee1paVSsfT5Zmlqs1TJt38qN3viZrDLy91MffRYLcDJrLGrP6w6zP7r4NR138StjvRglAtox/oHv+1iZfv8eCU8s+xuH2R8CUU6K5lL+zQi+gWdLIl6bPYMWGNvsir7vL4CRwNthwxfKpei9H2/65/cvXV950wpaVXxl6O/6BTBBsTqbwCOcPtENfetje3Hy8X9wyraXn4X23+W/VOMbn8AM6yNreLCQ8c2/N6vO6B0/onh53h+fvns+LmC+r5j7o6JM2kTZ2Mz4J2KpTVRpQr+PSgCK53oZ9b8fSlOK78dbSg/XvGFrh6rnn2Hmf5yDodWOT1Gsm2oU4HDLP3/hz9gAC3B6tXL//mp+FKRkeCB0fp/830csROPYBBvgEMr/b/4+yh91H8ECthvfp/o5UwT5KPy4PnrTv//6S9cEv/HI8UKY+7l3/gCVWk1Gr/3gs39ryt/3+/fxYkvnN7XwDjymBvO+/pPf+fBkvs93+WOVTULH1wzAMBkvD1G/f/FTH2FN11eF+GGJXPmXv+z4cw9ponbf/H3/2o0vs8BN1kE+h+cbr5aTfMuMX/y8H7zyc5g+ZYfavwDlFIQpEhjr8hV981P58Z/6p4t7731tg971XTRdjvvt9ZulzWEzgXm/fR0XsjW6bbr8HRSo4iREZ/TNbzfNIwiUo1RL2or2L1SPCda89Iys9MABWebp+OM9sRsDrxFVk1fsgEiSb+gdfwbWUyPqj//v+HrfP4XdfYGuM+N3xg3VP5nNRxA38yF+VT5Df8cXqUeFju/EHweCcN+x5+8T/1Z19WdjCVj80UKxftShBhM9GUfg8z6qyuc/jI/y//V3fD3+ReXjRKEGBe4/05uk5gDHw1l/fvoq1UtLfHb5CTQkkiT1I/TNPzGh+ycIPKHmqYXf3x/Kp76MROc/TOmfHAEy9Obj/7Qpf+fXzCWmntH1O01AiafDYxuB7n5E16a0/XZNP2vtc8qfpoU2oQI/Rd/4vysjf1R4izjgnLIdg09HtlralzntfyrXLagLeY+Mz/mAdPx3d6MAXjjR8aUV5e904++RS/+JtNWCXf/EwhUmuNr2+YPzTE2NWUzb757UlD5UYoosyeSmsjOg6+MfBKlu55jyjx/VD4yFLEDueaCcwHFG5yfMkWO7Qt7lF9GQShlJVsg5rjRDa+Mu/3uXP9xLj1Q+rRB0yHjc7NE7vhquhvR8f/LrLc/UPlW20QC31XxUv2YtuCnA6MufSks3RCNqlM768uMvXR0NiE/aeSv/KL+qv+vXl5+T6w0A2ZojX3dez5REE12oxxVlKog7+fO2n6Jt57/ZLYGNy0oMmk4jcfrl0fF/Nh/WI8f9iz9p/9In/q6m7Q+j28h6XQ+0/+sJc2Co1Lg/vpXDq6ntmt37V0JSuLoaNoOPd3yMJvcmytTQ2Mk4gdD/b36MyfEv/mPnt3/cAH6qctQfXytOtFz113R8JbW5LHn2YvgzVCkw0+4G3Z/v9xNN0IvvpfRX5Cl3ZcZR+UgWHhVFpwUzf6GL/1fritLlVwlhoOAePm+a8G4oNRjdqH4cIFlvtMWapX/yW16M+Tf/zJDr2c9NA2e8pkGk0/beYqMIfCUjXzNvT5eszPLSaFtq1IPDk44/xgZFcPsTynSsqgVRK/9GGfTNDzPv76/ZAOywasa3/v4Kl6LdwEXdi59qmjc+k7eyMf9hf0Em/vD9ftQUVTq+h0EqiG8+E3+4T+dAGI03dP15R9mDIq7qPr3gZI14Y4etr3PjOA/sN3T/DbZwksIwZ+rP9NqnTjpHVkQiX7/cgYEfic3GP37qu1BMCE/qdNMldS5/Pl/6gnvm5JXFTHyHHKdW6R4XKFPFMz6DYCiN60Y+ajYEV6Mnnyu13BEdSkdx1vTkj3v0bdsKJpS/8gNa0Jv5qPnmx9Pp/vzbXnsNAxnQBZV/1A/9/duj701BKnjZY/YvTyINaa5C5dMn/4fU7Y8XBC9wfOJX3X7iVxdxBOkhN0prozLtn937H/ViU/ronlF8XRxRps1UKr8WXErxTacftFecRz+Mj65Pb/5H31ISIaf9q4kQ3kC0ts+NP7XAEcwiOn+6dBaZ6JQ/2vWu7QmHs/On/i94Mfqz0sg1pGC85a/9/i1bEhPheKDzO+jPNdR98dZo4AgzzY+pfrgYxC5DT2P2t+sd1IaCOsqf9Jbb0Gg8hv5+H62vO/2Y1sRIw/GO0l+3xqZiz1998gtr05aO77N/R3c6v49+q8R9Ax8WxZ9ah48mj4Li12lL999Qq0ts7+RVEypDRVHCkll/derjExZxs+3P722/UNROv7/bgxH2qjxtLGetUX0/p+Mrg0gShHlO6fcxcqDhlvuPfFAOnX76278+9V97kphN3u9fWUFYmmonvz/5LdYxEz+yO81l4Tm50vO7LaMDyB2U/Hx+NHxGO3gE1Y45n1pj2HbFdedvjzS4OtrHP/HTTyrfrE0iF/yu89ltFXo+/Lw5MPHNXX6CcUTnr0OkQmoY+edP/nQl6+bPb3lVDFQ+it+GCRH+FZ/81l9Pd0j7D3iuAjCMGfsk21hKzS+NyFAXu7rAiPBMfsFPfossCGUVKVMbbl4imz+xTVHqV+ewUuUtmODxnjDyxw0TChWnGlO/yVQMoIPdico3SSULZJQiUx+q1361lgBuHhSLqfhG7mS6r5j8gXJirNNQtKmabUGzgCPbYOjf+iBt6OveEEBgVykzf7u5tZGQcNGf+JEuPrRHn4L2njyzfWh83y8j/9WnI8MSLIEkwS/23zKUzVLXhSDWRot6h1dSxth/9tSeoom3pv1bgBgkNCGzfguq7O1I6vI3uxrdn9EyZb4fyRGXtD4I45+/72pzGVBTIaD2t1lb+O7xDH9epJwTczQL+/aDtfa1AzwV9Hz63K0WRtUj7ON/Y6Frvnbu7G9PzVSi5XHQb/+tb36h7Y8b4SGI9j34ZXyf+iJmFvqaolH9sX1l7PvQd36MsAoyqPEQwOUmZui+3QRI3Vq+rM6hqpGtw9LXeVHh16INc1Uc7sbY9nO7TxcPEbCGuRXG2nqND/jZ5X/r7y+u0kuvcUND3XDEgcE9thj9XlK75LUPQ16FC0LliZQz7R/trQFPfhgy9sVf+vf9rRP8Yt9+61+ewr792nTvR9Rrx99iKEhRE6zDvn0FvM4/f8ed/fF+f+jtAgPGMb7hYsf6l9cRxXLqoHZlWEnhEKRi1jLv62QxbFTZcuRv/m2JZ+i3olnbk/TpyVpqUeNgrhns+tWbodBaR7r/h9tmBaWimTDvb/fzoTXgHDo+8YkbwHHGtE8XUDFMOHz0eU04YAHXSWww8icXbeKIRfALfz/+iWVL939iNXuydoz5f/NznMb+L/z/1o/ZBH3+AytTBABflL8f/OU/gx/8GzU9H/bWj0VddvxcXYXTBXlputfv391ZjTUQl5SeF/BIwqc17OP7v+PTilHjE1mIDn26XM1BMhwGvqHJZnQDZF5c+/2PgOgR/zD0Dd3X6iGQjvMz419SN4I1Kqgu1NZ8g+FtmMOf+aMXBn7hhBhqf/9IsnBL5Hk3/kraUVNrj4VI0HnNVXcaT9c/8FXbLBI/h7w/leHZunLRsMuvqNsdPV81bmMeevnFO/tcG4IVp0qUv2/7g6eiKNen1UPE2otn5J/Em14z4eybJ2cc3EHRERn54vmd/aLztq9RfHqG94HB7N+EAo9UVxRDVpUDeUJhUTL66xM/BDM/p/LsCYkzsC1Gvt7iKNXEMx3/p76nnE6Z+Pa/6/fygAziQR4w92Pv+sHz0DfUcV5zYLMWGfrVKh3i7WS6fudNxOFXaTP89x4ZQna08nPtEEIf2kE1/chfNdZjqj+0LBb9yKLj5/aRC/SSWCjUltyRKyG7vkjBBSgVEjP6ZSpqqSN36+PK4ECBk5j8PD/1mYEbHiPE5GfkxpuxMKhzOr/UA3cw2cpM/0qdQuR7T0qP0iYl2TZl3jcMbRQR1X/R8R9sIOM1trd9unrHisAdu/n7ErHJXCU79M5vo227+RuJgaAp0fMHszaqwCIqE2QVS/jSAxgz498eoEbqFSGM/j6hoAnu+sCTxwO4J1s5Y/DJ6w5APSKVaWjGjOIjGfAM/R0f72ZPej5mNyxTjAgPv/DvjklA3Kt8ZOKXKtsVo6rp5oeaJbnDlPFfl1gMS/3W8S++gDE+LQ1m/Om8QgjiB5UPm5jiT8VMmf4jQ3oVfEL5p5/O2wI3WnVCXnvkBLns+PexD1rKP30Y4CEeqeUBTcZnqOmQ5Z/22jw5cvbLc79/QbMeWCrp+FU42OfQ2aOS5W8X/+PR8UHuoE7gfuAz7QFsJUxlDKV//Fsxz8b/60BOXnZF+5dGdx5UDZsfucffEXwkGESIaf/RnxGVX9pqzV3xQq9u6J3fB8RaTvGz0gSpU9Dz871fmPMleud/4Bz2/Kgqd3+BdZRVzP1u1QpC8xQ6+0IHLd4hn+H/wowGBfB1av9pLcUPcGmvmPuBd/xqunIM7ZLuTTJSczb/9xOco6EreLF2vtZnkGB2f37iZ2Uqv9RnMUVkvJXvP/MH/vkx8lNd5KbtzjHdX3s3WmJTi5n5fd8HRJRuxfs5KS8p8z7wUz/nUPl/7j/mOdP/Zby5UrG2oPydTacrmCrpHX3rG3f8/+IPEPTx5/v8qkHnXxzHTQwnWRFQ+eg+eMBZiMHXS2Mztl5rnc6/FLkaV0M2//XnffP14vfx67f+yJjqH8vLPdsbT6h89DLVJ3xgMPwNPWNeOuKG4kPnoc6gGbLn/1PfaJjT76+N+o61hI1/SLJyBh24pvwbXOg/dobP0NHWdonL2WGljU5PDWYD3/uvfVM61H4SJ1R/pHK5ZOTHTroVr8qm9o+6qlW8EWyHOZ9uNKiFuA77/o8ePvj4t4+7UIbLLZU/zrVM++2tqew3muyGjH/wU3/7Qu3bQ4Mc5NhV2PffPFtRFXVyoPjo43+LneAX/+Ztmq5JhFwn059qc4fqg92fYAkNMpGXZqXGznNOGipr/hs/UKyp/WA8AQGXY8no74tiKWD83AU+3OfIhZvYZ+6/NgmQBaDffVmX03oFgC0bfTrviCZxxV59Vnb8VelTDbZ0gkqPc9CCTcrHP56/X+a/VaNa4NVZwPh3nYbi/6Cl/MUzXbFATAKGvxNH0+CzofvXrmQzpZvbr+DUgC55LMG8378QH191k5t+pd2y6RCm2nFQ/4Q/Zc1soxaobn3o0z/nQxr6GWw9un83ZcXgkw8+Dh3f1+3544nT3Y2Z3yf+ejin9NmgUUk7F/b9/j/1ZfCSjs+YviBcHTZC/d4/1Oyk+LGxZJ9MkoTSR0kN8Cg6cHXzenASmHb0v+On9j0Zk2AKmfzb4yYZF4Pdw+/zr+3qa3Oww5/jtEKpnTt+pa55IIHRPmXsP1nWGwGkIf2+q+AGm5TPP+JnWR0DohPxxAdMezufEX9y8n31tscDrJgyQx94wq1+aitKbzrg4FNDsE9/+/cm3oqOb1sQqg8UftqYTg10Wen0txJT9CVhi9J5EFI5aotW861/ANnxpWfik1cQM/Zrlej3orGFyNDSW70A0hTlDN2LRDyqhCjWFiU44tEz2/zgP5pR/tQ68iGiRinj/37fv68b34dJ0TgkCjPm+7OUVxtj3Pq+tnGiByhniOn/W39+Qec3XkQtNuJs9zP/tb1RE3B68mz7th4nY6nj3xw3FsGtvGuCrtSM0nb8e/u/tSNdfyhm0RXkxE+bb/0LBv/I+lRAFuF9m/znfeUYbmh7LYQOWRoV49/7vJ85enT+M4/it4MsHvt0/W41eFwe/Ep/jDUELxP/9Mv8PvdzOGba39feAw92I7p/tjNq/6UbxIzvU3+2pfPXxElzg48BOjXO46SlcNnN3xxRw15vu/0/d2sFm614aL7vX9j5f/Fbkxf9/tUSOmnkn+n8s5EqETIk5S/nY32i8ulJ8Vmf3lDdZk/qNeUPalWf4m3C5F//jg9T+VEYdYydbcq0/+QH8y+Uf0SimNUf5sz9T0y3a916nXzhJvcbTuL41ribu+rqww5/GJCe/7Cd0Pm3LoeBMfDLJuJWYCCH7PmBaj4NSNCQO5O/6+HxUVNeO/5FFBmchiJTn8Xf+FMy2dDxQy1QRjjIeOb97Mc/VGzp/q/F/Q0OpIy5P5oO7Fh0bZ7Ob7GbekTfsvjvv/qF9a/uo+iGh9kj+MX/CvnbCLyyMVM/+52/Vi07/PXxv+0uPnM/FgZqqMMOP338Zy09n1qSPGU42lb3xrwsVGqvdvx14woiYzOi50cFaAqvp4zBt+O7NEiaY073B27qOShJyeK32tuB4SzwKjjZ7MYUNLL5Jz75I29ZkKnVFMpwmvpM/0chX0CbwtRf+KMhPkTe/BTI6jHdz+CiEpn2g9YTMRhDqn8f8WOEB0hm/Avf+mbrwFfP46YgZdQw/oU0LMQI2DZTn12bZlquuUUXv7C5gQLEWdjnv8N72gHanf9vPJSdRpdvIa8SDyJykFn//ypOAxG+RpT/V5+T8TUsQ8Z/vqD6WFxw1L57OPUAlwBGjHzIcruMOD8wvvVrXiXjP/7kRzTcSIbVkNqH7Txl7JdP/bXdln4/sjkFKC57PylB62ZxxiKS9aWlCFgD7PvuT/2v6SzMtfxJVHKRCFM/QbWLQcJfZD/T8QS6MH2mbP7ce3UhQWp4hqaOQwmn85gZ/6yIndKqZhTff/LLjWXGv/Sxnzh6/vTnsoZgP5eZ9X/HhwTanH6fk6MIE4W1z4SjPi7adOrH2kUPa7ycpMz+fMf36jOT2kef+ll+w3yfP5HI9r21zsPz6ZCTNvIZ++v9/jkwHCuGrz3V7+7eYPDvpz625ji+6swJVTb0+4x8vERi1KKtVX3f109Y+2Y5TEgikgU9X7oNL3A/2zD4cDHVr/WgLCjd5KI1ACAJ+vjuUx/9BD1e31pbANAoY+L/1NwIYGDMPR5Sw2RF9qOSsU/DkaVgZfzyKnXREo+MDJHRn7kLV8hXAKWf6cCAHeeM/ie7jHTp3un3uSXx4WZCWP/grVWwNPAdQxWlugIlzJn1+dTPaR50fkMRXgg+lwz+2+4irhhd6PhVydB8qI/4gnl/cce58Bw83UwbG9wLtDeD4f8L1XssH2yv0rZWXYKCyCmDr+bWM+Jg7Bt6ljY6Oboxg1+DpNJREM58Q9tl6AZ3U8Tgx0996Jjia5ilT0iOA97sj287S12i+yHF7yaVsBgWCDH24aWkxoY4DGTtUpIVbLOSiV+675JRArQ28HVygns4GduM/++5KFeij1JPhmRMd5bRNoz+3QvyIfXE2JP/5L/NGf34jY/gKH4ZaiQi4zUrP/FQNEsnqrxMQ4edjFc1YvWHoCf1+Ox5uWZOag3c6xvjX1f029qSlyKlN3cyhjMgM/bhdVTU9TOvgliXYkyXSuHXzP7blzpxeMvv6kNEAugqVjL7D+AxUAY13T+GTyyyCHPGPsA19EVjZND9cyjvEhavBlM/J9T1dcLzHb3WoQWrmcHYp5/7ke2Mnp8yRhacYcj4Z+NTNS9DLQl4ilipIbA8yltG/7SZ2jjqlMrX6bTZQzniGfr8TELbHRt0f4TOM4NBARn/2lm4DWtFnweZDklwAS3Pnm/tBMb18NnVB1/o9w0INw0jv9dNPC81b+ca6nW2ewIH2wz9JRkqseTEzvRBDjUS6zajH3YGOjTaw3Ar2Gx3Pr5VOfP9T/zzVA4rzcIvh9Q5297ZJ40g3Dy6vvDK8eCEMwY/fupnr1Kqv1YQpfCVVQx/P+9fEjnM1Muc6p/Bgmfy11DTRRGafO3Jmrffa3CesPJVPksrgbMCL1en470CC8IJjP9gY1+Jbsjd+jrU/laubP9jYCAYVfR8abs9DvDgZDP4uvLrphiKmh+rO/mBwGxq/0t/ZnrqDSIthuaUGthTJWfmr10EpZDJQPfVVGqoBPVThn+6ba+h62ypfE2E6Anasc/45+/PRke2KxkZtIzHA5xsFh9/9pfo0vHfhOiKq1PK2DezrFUsYXIZ65zEHZYkRzHjP/7Uz5BfUQabAgzwbYsY/3oTpBCaj0NoaNYFzPB2EDP2643z6kh4bOQboLqbw/d1zPBvznlCIjx1en6nQsjjygaj/vo8nvaumcwudH0+9g/PxgdAYbOuB1nrxtCK8Agszyw+5Y7trRZ8SPFBdQJDcFTzZf/7QM9C5ARTn1cfMaZQa5Qy9lu7N9QyHPJBrAWgUeFiazP60Q4rH6rh1Yt1b0rtQ60u2r7+NrrALiu+27I25l8mQaXMyN/Wj0SLVwaODIGHxnAiNIz94SbpHMJW9wwKhR8ExA+fWZ9Azr3GMoFn6Puazl/hDEZ+HENRs41WsXN42e6p/oQ5o//XOJ0QN1UsQ6/L+wGDGjL7LyjFnegvh56v3ddYAZnE2k9e9wjZS/aurE/QwYIyJsz4LTc+kIlhUPoeozPRaz9k7m9qL4/4YuJW2m5YJzgiFaN/r8lmDHjdovbD5/38Vmbk9ye+G76ofWWvoAevMc/4/09JdS416UT5d2nRDsIF+z6gVTc7S5ZWLq8+raDGp4FYM/InaXPwim50/EjXENHXDXN+oXtbYWHKO/y3fgvH+ud5oyJE466eofqb3QMfHyJzvxSYcwDEEFP7VaQqAC7blJE/eAepvnwKlvz1X9sVI1+0wqcrvGjp/rY5gkg8aFj9Y4GL1dzmlL8rsYvPTOdpf38WHsltuzBdWaX6OYHkwNbXW0Y6ZwE8NGL18XicQeH4zPjPe7+0o0Xu0vMpQ59QPBYz+v9hJ+VkwVG6YWEEBtNcY/ALmrdJWwA6/w8+4XPmfmqMN3esPB5UfmXt9gHmssisf+4fb1gkQzp+QPYFnE8Evv99kvAUD4Au/uI2BRPQvgxGPnl1PRIUTvR8fZiqKrn+y//hyskFP6c53T9TtbHIFtuM/NvNmmtpkpDSwZ4aukYKmf4f4zmwmtXW57UVCjA+ljkjf/M7FopmLlB8ObTJnOJ/yPiXZju/QMHlQft/Ifr9XZXi/vdrzRMFnkpZQ78WRIOWJDL3uycRP6ORxLu8Xs5JChWzihj7fWVsG397of2PukeQlZwuGPuh9KRE1K2JoSEbIljOc2Z8X/9i6Bhf/6KVM/PfQaSl4eZhVlqW1mMMUvZ+VMlbOQKTiZ1p8pbiN8lvmPvVd/xolM5cX7Uf1PpZKSLTPkPHV9RWHF3frQ0XULlnDH7c2yRM1UXWnV8FalDYyox8fxwlgEeznOL3yRq8QNY0DH9nS4NAFbQUX08kyh9Pahh8kiuxWVrbO8z0ANLzOwps5vyGbaVRoeAZMpw9owQIPs/sL/5V3AVxcefmoDhFTywGrP55mnUhvMZzL9cBATmYQZ7x35alfICWl9D18xfNFgphzsRXUuv/binGiNpvFJ74sO7i4Xp0v/T3yFdvVL6D5qmTp/e3Pt1bfx1E0/aTI9CVT33GKGb4M7ZlLEaKSsdX8LUMIq1i5E/pbJ5Ykbv6EfOG2oexzsZfGkqGSl823VyrdyHEuSyM+/KJ0wRcgN2W2ncRFzyAV6as/+79/mmfO5lqToM1yK2SsX8qaj0JMrrbvD7UHjds1RljPwrjBqbhWLByOL5GDTUmILO/ChGd0smLp2bh535xXTH+gcWmGETD5ETxxyd+QWHxL5o369LZZZ4PV8OIB8uhzZ5fu7GgHk0cH6ISqVD1c2Z/hKklCqO6tSp1tdcOUChZ+aWcrV1Chagj62IDbmAte08m/u1VrLCS5Y6smh7FZ5u5weyP45aC7rA9ODxMp88FoX9j8NfHf+bErqGlT4ww96iY+9GZY1CxEV8pf44BnUqusvhZO8kn5J8elD+benolgQ0Z+Z3mIkwdIbfjb/3tmcHkR/zELzgz14BLndp/25HM+B9GFCJTEK2buSqLdQ7Oy5LBx0Y1HwDleXNz9SxR+avlBrP+uh+fRP3quJk63O50EI5Thv8pX18TjldcXx9cwhzcljaj/4WJfhWUZ0r5Ox/gFt8et1uffyJfUvy/7/i746M5xafHRX99xIFUgee0pvwxfbQnxweZM/eX7/wew637p/5sChn5XhAsFSML0e+nmxrjcBAz+pvXYNBMzqWTf+s/7mTGfvu8bzR3dP+kWXTHy8pm+t+coGmrRkj5+6nvuG+S/+qnElL9aXPNiojnPPmv/hF37h/7vIuf6tF3O15rgnMiS9yuqgl2F2x8VHPEo0LkVmamJVtoEE3jmfvxL/4/0vVRFOgQ7sgz+unhowXy1wdH1mYTEsJiXrLx47vkUgv3p/vnfcnVZ/w3y4kkCG1VmJm+eeAaP4aQkc/yVVhEzYyn+2tzBFe8F0qW//tjXQvtja5/7uMteNo5835z9n90PVvbqjivP4iLoqDAZctZOSoqeqcoeAQVBeHX71RcM3S+tX2emYs3K6VN0zRJc1hpMkLVyU7wLAb+uRshc/+uS+GTj48p2I/TPd5nYOgx/qNT8rzHAzJEEYe3HJeKos74l+3VrqrG+zOWNcOp1xmqMWP/KG2o20SSbJ4kTr3MoneUM+d/+pQFWT5MdO32DGaolC+M/8Z1ojRViDFZaB+4QrF4Lpj5e9PimmHAv6jNED9xnMrM+6pBC8P7cwW+z/tcky6vT8Z+QuG5RINNAPq1fMYJdlubOb/L9PzJxWQ2WeBBVI1QptaM/EaNwAWfi2rLeDo/nrL5FqjdGx9HoiYaFbJLLMSZm9WfNeM/WmYCCuqDYC9UbZ/6yM5rZv/U53pTO6I6ueBdii08nbL7P+VkrSbB05Z/+X8y278Ydp9LP4MK9PvyWr0QWrgpcz/uHC6uh569wNwxfaFBKzLyzYQbFU/FFMbfBu9x2uTapL9/59uCiO7GsGUSN+kzvdMOq33+kKuhMLB3MP+8Cp2sepXM+OiNxrE05IwFudZ1nZ2+pQv/hYPBO65QMdUTPLHTNNXtQOp/v5YiUagHguVqxhNpKe9mzP3B7zU5lccu76BBlK7Qi2u5Pn5st5dcSQaTklg86I97u2bkB5+6FiaHiVmSvAL7J8r1//QHD7EdzG1Y/2UG8onnMia+5PxypLR2LIvHGz9bZJ+7xsRfeCeMQ3N/tEH/do4ILweW0p+fNnZGlfw4WgtsTdAxNSasftW9X2g+rSc7VvcYyRMmv5KMM9MGqWRc1NYI9JQ3dwMmfsPcDUHDeCkOp9mZhIthPmTsN7gt1n640WUVBJuN0zJTGf67FFZtKY3lqson22B+kp+Z9Y0ElHKxaCWaM0xFdN2y8fdGfuYsjl9ZJV5M6jLjxJTxn11iS0AjR/wnf84FO0UdPEY5VxxOR9BPcLie3t1/3tco3B4pE1sbZqfN7/1tdfBLbahkBNeFPQz9WTPYKJ96vv/Fh+Tnf+KnKP7E0bRMLabqCEdrbIa2rvyTP0jh3/rw8iw/gz51z0jmrml/QKLX02wi8sNQvTpYJ6bb3H/9raO5V/7koxgCvDLGsbx4q0ssHrJZ6AwO/8xfx+PQMRKC1dtZ3cB+YFxrsfzP+ilcj19ixO1S9dibnzp5ZRqWR9nw7/Pr4ffmx7lw3ZFmGJRkt0gPaDq8iCEpkP3WqlczwKDTzwv/GHr9+dGg/ZCM1+rsf+GUPn+F/4kvFId9+HbdCrE0+rc+EsU3t4R7cuL+9PqdjwS5/f3XtHaooGY1/2AzR2UgNFdX1vZK2OJT4f5TX2etXnEQx0NhNPu3vyKdv1XSehzcvXn94ocS2e3TJ9AbK9PcRP3gQAxVTMzpP/zxpb+6EAgSElX5X/74jv8v/b/9FcRJ7iaaNq8F0GdhfqT1FEfeauclnsxyFCPrCfQJ/EObJqtiGHrxRUJKito+vDd+D/4I26cwOGpu//uGNkUtdx9GBt4t4By548wttYOc8giMrWE4iceSgfap1p9fD783v1//Fd1l9kdQlIk8GGjG/+JTeA9f3QacJX8Qs7++RrSQvA+A/z/ro/De+lYL55mPker152eHB9TKr31r4LORvoOPjoN+/seQ9neBQeHqirUc5YOjwsA/tH+zerV461c/cO4z9S0GlzfOSOQC3EgLYz09qgx8pMA1Imstr+GRZjuhv6wZuEzrf2NufdEwn4WmrRKN+b6iDbiUO5u6ho+LhZZZ7ZadH+1fyI2OADcS1OTcVAh4dbKl/R8mlVW1swVCsrbT++MT9WV7nGhMcX/83/sQYepnSFS+4BsC+nT5W/oO4NtrHWJlcg6rRiVoLz8+MP/65hoieb3Y/I5ufHKJMdotTOxlNwY+fDYK4qonH2HpZY1BPb0zcLmrf/bWI+xdygirg5Xbz//50k/lOIB39dUSicnvGW8f3E7Z0/z/X33cisEfZTXaycUG5tfSxklWzeYHfbr+5DQ/vMuPeznuRc0a5KcKQi6oAXdlJuMHjK+tqlpoz667UB3xc8fu50yqQVefK6L58RN9in0978UfwyeWEtzHEV3/v+sj7Xs1RkG4Wga99Q2H0Sge+BZb34TWRyU24p2ff2llM/zRPu7KRv68FkFnfw4+YbhQL242xZbqgH4duFjXzinFH57FYLB4svVVOI2byHgO8EdQh7U1KZn8qw+3UVJFcf/U7xkqIZM/xdcrBf5NAPTNB5d5Md0dgj5+k11QgIaHBSw9eDa5bKyZ+i+NWeA5GS9pfvk3/4bW1+nD3x/sY8HSLcxd3aXoNez4tJpxqZkPOH+ClSywvh4GC3Xi4VkmB1VaNc1GdcmF1/+pL5n+iw/ycCLY6KxUFD/h2keOLJepX6MIUy5VdAXOR6RKVTD89OrfwM8Q91wg+/R8F3FtrS10ZvAH2yOacfPNwvr5zxeEmf+3voPmtiBfxMluHIyzPYPPFRN1TvwS4F18OBCpjz/ePNFSlq4X649/V2Loi8pQzTQ9APhy7hprfTj3eXW4Ss/ptBLSiq92MKXXGsZH62cbfJwePqatRVbkoiKKr2p5hTj3zow/pPWVNOkI+NIqfVYDx+vVV8KZL0pqhs+Ufo9dPIyHXsLgDy4r9a0hcnHwfB40+XDDM+vnHzwJ8cHVHXzYrzXbHayZ/Mghra+FKx7ouxpprcWPTQZe6znRtWAJ+PZF4OD4p8z3BTCRRG13XTi//ASlNz7M/9ffjo7PzetZYfN3hj5g4nIbeXMC/rQ+6bvipxaTHyqByeJwjgnrm01Ep544C3+hyhHYDwMkpdU4OnCWMkZAv31WaKJ/4Znzz7UvvMY6XX+SucvaeCrM/YKqq3JGHA/fn/vRIODDkMGvaX8OOTrB+MVpEYl2njD4Q1wSVXUqOP+8Fg1jfvtg8PkEcRFXX2D/f/U58lAn92EtZpeBowf1u1EvxKb3YxffIy1BJwLt8ZK2jrAI2nrI5aih8/Peuibq8xtDH57WN5cvN1hfl//mD5j8WBE/uScar2F++dn218YhZfZX5DH3lHcj2L8uvvTdMuOjrr6Bxge4vJ4HaYNCZvymrEDCySJ8Hw2lMpfPZyZ/V+7iI58wfqe/ZrWvk32OZNRUKK0+E9gfkl9gf4UbGqLBiff7/O8OCmWmnDcwfoXFIPRF0V8Q6Ywvmf09f4QoHyR6ML4Vr3GoLkJm/oI2UfbcugH5+OM/i5kfPwMjVnHp/TUaAAfyicasT+rq0zq0Psa3PlHhsvnLtP8kvmz14Bcfnc2Z8YfTkYo1V4H1Oalsr431i4E3TkBW2iSB8bPJYiL69oX5PvoM1Yc6eMH4nf518rwLWT/xKotqLavGRUoK4kwA3xsgORcvodc/X74YKq2yV2D/t+pOqPhm6fHakdD81bRNq1FX/78B+q5WAhcLS8zk7ypizd3lYQjf/9WHSRh4/YkJT5IK4FqIo9pfK+z6jUg1yVYE/vnFX6cM/nf+mhPC/f6zL97M/SntG3TmPidYn6Hxs1A3AwY+fuzRWQ412L9fftrd09XdKjPg2gP6tFdNSWXQjwKc8kEjyIPe/Uzt4nGuFiQ8XQK8cbOF7Z4/Htx/Wp1mZgX0+dW3WsH8r/Lulctqwt7f71rJ5Zyn9bPAMAVV8M3AR2ailmS9gPWJ8bPNB+Mri7/cYZ+MaP0QlY/KnMsJo1/95n8F/PKefoSBWTHrV44b5CjeDfj7V/94yuD/+N8C+nB3exYGigf0aYcBSu8p3O+SS+DQjCVY/6++psjol/VJUs5yuoH5dfkpg8zliXaBs7usQP623f0W0vor3/cry3YZ+d7VR7No/S1aX21cDfv6XabT+1N70fG5p9SgRoqZ+cuySA5YRjD/rj+08R/9qKtfcoH9RcfSKvTrhpVvLUFLZUT55xI5Ui5oJcOfIydWRrI+p/WbwsQJ8WbPnO9x1/9Khe/zqfVIqY+Ska8AeKj5h8q/KEDVp1HY+ny0P6miRUDfn39fYuY/pP1L0GgK57PRpTIe6iPQn+N5EKcH0S7Dyd5W9ki6gX54m0qDlBvQ/N21eWhStQCRamY3RULu/fKnvthi7F60Z1Fd0OT8vAfie8vNuMeNB/wmmdWGBfq3thmgGbpc9XeojhQ8xzuqf/+v/YDrrv9Sp18fhBLbplWzcG0F69hR+2A3AaNY9luADyPfQtfyUobO4qI8OdCZYiyPayucPDCTX/jtH8S1Kq2/9XL4fLAhTP5lYGtw/wcbwL+vg0Faj3mY/86Gs/0YW5cA0frZyKLjv4rnMBYjG74f2rMtdo+CGLTjhDsqlzmML/jOxxodTaDPRQD5ENYJDolxUJbKk8aPN0pVB41D+2cbORh1QXrRwl//7DlDH+00CU6p05S4T58e/UQ3HaWJAeP17JPu/euBwP45zKoUlZ+1EdpLA/QnmQf++9f+IcIczrzmRyho/2b/4NW6OqP7KbP732/GcpAFUw7gs5MfplomDYPmmBMOBwOAf/tzoSGFk7bi06n5BPp1/R0ofBk/RwI/AfsN9jO4pos2W4RBV9/hDvQtlhafS9cpzO8Ro2m65esg1N4zFCsHCp9/CjBGFGr/nV/VG4FRcw7dyZkc1B2Fb+PMr00D8LXx5WhgxLu3P/W5KZyrhHc8sOj+JVEIZk16cUJn7aK7jOj+oSSv8jasgX+iQQoUfspWqI0M8iDvq97fH9V1gD4eccM+fexpHRaB5gG8vaYo/WAaP/rnfMa/+igr2B8cLTMnGxbFPCTUfkMKuz/49gRWT4MQ1v/v/nT56W+O8uc9q/AkXDhhcEfKXXYHDH9or214xAGxF/35dfXbv+vPprWTcXW2CtXTDQRH813/Upxnvk3z55M73mNSh+vQ/Ky5CXe8An/OzR1MFVH8rn9TXW//9Hel+D36LN94hTcfff13/tVodZT0RXDSh3OK7oGxQvnXn2QrfLeLbTg1ZDLUEEsfVdPwKYvTMu7Tp+uv0wB9yHSOo2xq28vQ2k9Q29Gn29/IB3g2TjMkH+1DaILhkxE+YuavWYtwkulhlvXn18Wf7GD9cB9ldsbj+hhOvQy76oCu/2RgbNuUv7EjV3LqJvUudMUZ3movyn/d+9/HofVH1NDH+0bOwl/9Qwrv0e9ghRYe1Mmp//1EiZr0M0a0f/0Ylel8sTiGzmmDC4zp+v6lj/Z64HkWV3Xap8+mQk36PZ9kHAB/kbW9DyeVjFL5ez4HKJAspYX1/eLLsHgOCfW/qCe6vupeRvYUAX9jfvN5ZPujfQ197qg+8IKlH5ZV7oCeOLn05188XKdwRcpf/KR2MXe0T+G3/7oaUf7iy8WkDuj8tKkH38eJfurPr7c/XX25Orn1x+/8X296vpLibaGlvriGAe0PJhOWPupggW2cI1hfjz5dfowF8lmT/I+A1dk6Dy1af1GrWPmMZVtBaVonRf/7yjPRxYlcwfo4ef9M32pWhM52qlxlncoPw08flRSbsL/P24FD5iy5/6nfyY6vjh94nKU4efTHrx5Irmq6PjUbowDNavfe9UfAFl1fbjpgyn33V5s3O6zL+o3Z33/lP8indYoCMe+vXw6iKv8E9Hx38aVH/RnqFxhUjuj+P0uELG5pAD5agVnufbJH6A8fyh09C77vX1PNLCDpNJDv/fE/egqmkDNn6j9/8x/V1ZPX8GGKkCAM3wx82vkP52DfZoXwFNDKCvr3tylfuD2nY7D/75PqlXP6iME3aH1iTpNg/LcpVVX7TFj8gAf9Rzgu/ub/Bbj3r3+2e/8a8gDv4md1/h1O8FA9afkW8G+zzCiMlcvU7zU7+12//Or/jl8NM/7P/hyBfk9VcVQr+3BBRFLN0gSFoN/Q+o2ySe3XlR0PUz57MvWDv/1x0XsO8K5/2MVi9Jtvf1iyrEA/nhlysLZUzMDt3YMGRWHgz4dzMUTvtmbqP3idfTaF/e/6+9g7pv72tz66snyCfn0tSlyT8BP05/erX7im59cB69P8CEx9smDhc0t5iUC/7uZ/ezHft9M5GapKCOMbq3CZTcicqX/27T8ob6h9eNZdo3BCxMD9hwWCbB7A+pugNNf+ZMjWR0s5PFdFah/IWSBXovxm94/qv4obgP6daudBIJ+XzP5NUIULlTsBf57O0ShtTwXDf561xwcSUv/Zr77OnMXv6qdT/wZBIrG105P5vrZP0USeXHXrl98bXENdtdvqnH5eZRkSgecCdB/x1i9/aKQx+N/6f8oBAf9/PmCUtUvaUwDM1QTFm+z1pz5+BON39R3DEVNfT11s0ED57IE/O/3Nlhj4t386mSKwfz77bFbgq8/Ur/MAIOPrm+JnpQfyNGbgVgyKJrd1qP1M8+09J2Xx1QPwz3tI/S+D5yhX3k+m/t70IoD+djgD/Tr/kSywcFq/GW9iOH+dfEYTBq4NBsqLW3Awfqffz0SmPt+3fpNczKh/pYsPvjHwSfe+RO2zzr83i/2/yJc94HPvi1EHM5eBe9S+Rh6G759CYRBw1wdD3yCm/QcaDPeDANaZIC5ezPytz1nF2Bf/sS/XOVM///t9RahAPppb0c+cI2Hhr4Q0eE3fF6zc+VRjccScX7uzbxXgj9Xj/Awaq2bwSff+sAP+r/aoRJL1YeSLP/uQsWrlcP7CmW6Jnvlix0/uyOMaG/h3tiyxGORbBj6pzxjshQv1j46QbCnZEfjXpYHvqbp4h84yUNfamr7vde8v8Z2RH1Pqf+ekJ8ifMllHti0NmPPvn+EqVWYDoF/DL/Aa30Xm+2a1RYqSbIF/L7gS4sacMvtvNyoYefES+Ku5t7yA5JbhX/cskRs5rWh9/GvQpKKlMvvniB+CiQUa6K++hK0y++8KD2Rwh5TWV35EZfxRWmZ+3/4ZpKL+2cNTdHDwbBj+8kuDu4MFBfv762/5YODaPOIG3K2l8lMUuHzw0eH+Wb1qD+QV2D/eA8H30Q74F8WOZElyGS7UWn0L6OIXxZ/+IxHw7zC07dDIVNgfPpi9M36tl6GXttwHJcVFw5Yr8NXnEQe8po7COhvISRn66xWZqrsl3K+dfccdAf5BtY1PO3QK0NJTdpywgv399i/H4jzUCWw8zqyFdQ1kXcZb4r6Z+1trLWxnRhlXQe99tctvsrYAt0ag3x1DNw8Jrd+ifuj7LeeBfEGZAvMP1l6SKqV47fQHWeMA3vU3yun8K2A8vFHWl+78Kl7GvB8TpXyN0LUC/J7+8C9cjQanW3arQP/qwR/8elpPnj7cD+TyNtJiju/h9G2QE1ZSgL8TbNa6LIN87+pzLoH+3/qh6pV9//rVj4XLNOy9f/XmN6oDAR0r0H97338LeRnz2hbwrzTzRknlS2jR9xeyC9j3tbjkKnSjEVW98bNp3qQtAnxsPv0itWuYf/C+cS/li9/TrxYPf5RekHjvf9+qXcM2N1vgv012SBEfFpfQ96Z4CIYI8N97f+aEZgJwbclhNzO38iH0Lqqqa+sz8F+s6lZmLx3gD9B0EjQXhTpQuv6+Kn3/ygtz7a4ofL06FKhyYyFAW4H4ON0AvPP/WQ3sf5c/jSz63vftj8KB/DzqlzkOAhvo19UPTMA++/WnPsD8v/n5it7C/XyibwfDpX7+079iTOlH40+wngJ81YBt5gniMcTzibJE0wb4++dfIsAfmzFCaVZeslCl76PaJWHjE0Ilc/AuAPy/8pe23cJBvARg//X1169/G/j/osYz9ElfKdifX/n63/3VqgJMRTsE+6u3v//C1W2aLfEMlM0+/Fo+ZUvaG0Bfx8y2mdaC/joxPgqS5xjo2+zOUsrf6PtXVz/Cwo8Ozs13QN9z1T6CcQzrx1VUB1m2BfvU8pfKEcl0/aaia+FEB/lPpjn1D3+SXfirH0Pl/6OKmkpcjQHfMOsJnrvrTUhkjcy12w7Wd79VStyWoD9hHmUuXi6SNFTlEzpy1YCl3+eTnlMXgf3eo9+3vwFP6ffrj5CKm9C+09ePLUs/tTnC4t61nvz9/P38Q0EZ98fv0X/fhCpGGc4Y+q4iOZVXI+C/Y5omNMJyGbpxrSYkoevDco1D3wX+wkRPxVSl8dOOveFmstcC/DBeR6K6w4Df+R9qfh66/lSda88E4F19hHAJ9H3EoZoJT1q/cS5zV+RUzPklCz3b41lQRn+fv5pmtZGBoF78ff04Gmca3qSLoI/f6ZcO0Fe7n8NJZlTiLPzWRyf/oS++lGiM0lpf98eP+UgOBhId/81nfoZR6YST3RQRWdhT/oc/ivoONCJyW9YlNh6hFjr1ifOU6Z6Vj+ReichGodWfX2f/Lk6Uf8aBAOZAGcL9N0IjZc3D/MZTFy6dGviLrAo8zxqUWeGv/vaApc+rynQsYN3+f+RzEX1O+HiIUf/+0maRHPMBPb8Sj1/ZpSq0P/1hWPoQuBjfyMR62B+/xc4gFUwaXzWbNQZ+fzQhkJsnxpq8g/PTxf8U9H35kR81bM8cJUCPh7rS5kOe4c+kQCu0D7U6GPxNPmgebUp5hDX2v2+GFp+2B9CRtaGgrNPVLAFbZ7VFmpxsmfVrRctd0DkQn//P+RhX8xB/Qv3BrA9d7GxyD8E+RsNwjg9L4GXVHZAMSxnoR6+1aIgB3Ck6CdW0SRuRB/wufozuz+4dyyk3GYZ/8vv2Yhbam5LIxJmDfGpfth66rxrk99UlKj43tfenPwzI1V/97w19fw+bcIfFq6iH+ChzLyTT9/euPsHwAPif4yfF2zbLQ3N/xw9yzej7/UMScwW94P45Xt7UzxMCL6UFcfFYBvzu/McTgM9OgZJu7XoeOrMcb9VnBfCpYOvZZMXB/JdRfQbq61Y48RESuM8T4F394SvM7xffPloncMwvwGTDf+PnzgXAr8PMxq1UHrv+oXARAnzp8HrtvQpqP6bBMeXzJP7Tf82j9sW3/t/1DPi3FfCfLoEI+MpvRXYA/qv/5gN9iP6KU5/eH2b3fr2F9YORp9VmAPcDaa/BMPUW4u5P/+YG8JvP85XzM4Wpf/T1r2BH7ftP+/WV+v7HJ32hLSWmPtP0GChP5UP7t3T+L09k4N6Y9oc9UPvrnlnvYBDUzPhT/oEbbUbfp7aD2rJJpjH43/cLdKD+l64/meQCPqnUdYaW7rv+yWf6PtbZvxNa/yxYZ1Emru137R14JHEj+v4mJyC/fDAI++snwZOLuPIG59N72FamTq5B//t2aJKGbEE1wgoC+46vEgaudfGJRzg/F2thZvj6Ycb3/QmS0Bb15T9Dn3/P58//Oghk1TWaKDtq4bsmigpGlU3P9361MEVvlTH9abyuP5Su/+mP8dkx4/ujMblpxgfsr1raPYTRw2LqYxleTFTt4dD+FnX7RnKxCvr7Q3JV+cjLJe0vE0llBYzM9HcxRzmcrz21D8+8qIbOfcTU5wq0jGSqQOj72hUML2f0ZOFUf1TThMYHLnS9sO7u/9aXwtMV7H/Rxi80VHgG3zev5KZejrC+zTF95oqas+sLlsiT3zOw//hr+rRGSsyMrzs+h2SxofER+xgh4EWG/4yXrBbkYwJ+5QdS2hynLP2p/oTaAOzD5/YsCaM4Z+hvRgna0fgf69ffQ3gz/BF8HEVRKgf0867/bVYy/U2+/U3lB7UPF6M1znBTMt+fVBdyAFEJ53vOoUbgbyPm+/hVoQFXUf9POePtAnu3MFGfx3CdVWH46vqbID+H7683tl5bbQXj68KnygYJLuvpROQ8zlZgfATWXQzXdeiSuz27452+eNXac6GamrCE9aXFTqmGG42Zn3OJuRYZ1H8WblOh4i4jpn7Zr38tSBZ8e2eLtSrPmfphX/8BShyAJ9diEhpkwuB/399wYwL//OJH3L/VH6thf7v+e1XMwLFyIj45CnC/cTpo86Z6Yvp7eOUVpVx9hv09T3aPvHVvDNzxMFqiZH0J/sRX8wz8+z6m8TS+FZSWBfa9IdNfROviI6n/aCleDOwoNnO+jMWZrDQPU//SN37DnDL4ztDmLFluAS5dUJsLSs7gT7r4liPAN6BNF4ahs/Qf3slCvQ3hfJ2sMhL1ZM/M3/YzUpBiyMP5u4VBOK1nTP8nsOyBKWdvev/apSbauxMLp+8XWrQHeFf/7Hll4N/61cpCBv7Jp9YYfWSOgZtdfLUP87835yYdO3fmfLqjEKVykMP8omGE8vbAM/LLf1VqoiIP7t+ffW4z8Ol1CKY4bgDe5X+NG1Z+n86qTZIDwOMNQoFcnIG/n/lsj1ccKDPf93Eu5UE+H0euAzfTkpE/WjziEBfT/oOz++5VjWODkV8kM3CN39T/OF+Ixlr9rBj+VLv+ZjQ+aSDmoEH7LH9NCqQe8EWF8bfZs7Zqr2HW52ZjLKv6Hs6/q6zNUFMUdn1dfX0Jzj/5OM9qNEsZ/vLtM/ood8rfbV6GtbfCDH+pr4bY6pIH+Phg66IlFuz9Qe8v1ab+PX0DUkUcsPv/6y9c0fjC2DUyl1sw4/ufJ3dWJhbgTyRJisUl7S9UiamC0k1p1FoXP0L9d9wHT7E+24J8e2dolNZWfK046j/FFvV//OK7dcAf5nWLW0Lzj7v+lNQ/t3gLPBItUIeJfZkR/InEsrbn8A+UT079M3ttWInjCO5nfhyes83TLWtzyHGaHC0APvHEWaavPgAfhmiKRr5GAmTC/hJnQ/1v3/6NwxDkczpO72D9Cueqfjig8owiah986wtJYFMQvw3qVDpK92rMCaRW5zdgTXQtwAio09BVz7eZkX2c8TYQ1aV6IKe2b39/O/ByaWt+Ln3757N2npYgbYN+/eZ2IXIGNz7qf9NPAN7DV6KLaxvlmoFznX/6DOvv6t9saqZ/33j1VnWyYOybf/mLiS//9/uaCto06HNS1c/v+NWv5OH7ryCL8YGs83o6uCMBtfT9sHsfnQL9tYH9dpAcFvfamayVmKso/b/+/3oRh67mHz4w3mxR/OGfGsafCdIgV+wIzneb+Soq+eyf/mdvwG/iuM4lVQH6Li9zEAJEvNbTPFPn+J6w9KvO+xJlqXyt/+ZfklX7nSl4W8l5/Tf7rMTnVz3ASmbf6h59Ov9Pvg1K7WJyeprqbl5bqERLZU3t159+DHDVIfsEIUe81LiL/2T8hzKR+LRML4F8/vv8SBKRO60vd+/DY7i+RK2i44u7N4f8p1zUepLjOaE9dfFicRYRN1jD+fIXgYC0JrzUpjXDKk7p+9K3v4byikG/sQ/ZOZME8VA7jkqmanyi52+Q6LZ5HwL93Sp7gb39nFao0w/ncD984xusAQH9I50FNYpPVB8fyYokT6l+fXfXeD09bOB8yAoXpsddJFWDWaRsUHuA+2fXRCNBnBG2P6SzxiFeUvzDJrHq6fMA8M+jvuLxXNhU6KSRuaoJoP/UKa+H6uPB4PPBALWcTePHu/i4ncecj3FnH50B/73Wp2uVfzL9+37xcfT9uXtfXCjM+IOToeTIpvrlyD1LFho8mfGlggP7dEH96/pbtuupTYD+G3wIkRc6StWqGdwfrUbvf9rfE0/Z/pgj+Y0UJdNBv/rcni0aPycw/gWU2DT5FOeazBckUYfUPzuxQnVt8AXQN79kZnbKk0tN4jFZ4QJMTzwwd0IwKt8A31ahmW1nyak2jzO1wHMR+NeQgicanW0Y/3yqdbivwmOtFq2qau2eZ87/ah962RXJx//n/LzGNa03RNuB/gvv6odqwJ9YmNVz/HqKGdw/W26jsP5Zej5CB6+wfeqfL52gEeLP9HzxWxxk/sU919/3MfI9X/u0GlbcwAb5UVx8Id3G9rP2VzWu1QcB/aDrn6begb6zcn9Px8/LvdaHCD/w+QL739UXM0F+/PoTZPgA8kMEtePrPyqP+ciqhzKsb32rl9myXmzrYCmqtqbsWPl4zus4A0Lu+ut3cp7YpLwB/bv1TYA+v/iGAcy/s2/wAuZ39mipEgT45PFASCEVK7/aAeIQSeW4P/57lkoBH1P6uE54xF6tb+vpaUQOZMPSl1zmwMowkaRP36FUvYQvfUnQ1ns8KhaH+uf/o/hZWk4yIzJg/cU7jDMQBKvOvlT3e4CbI9sSTZH2N9xtkJAmqRzVqgVGiZwIML/wFNdpI1kgv8xBvc3KvTirsSSD/llT/+TogFDM11R/246xk+WrxbqeLnVuBqKekY9awgUJEiox6q//13+Gzv+Q4BMe0+QY91OS6f+sf7UG+jxCe1H/9X4jg024y5ZgsPTH7/K7dlS+1vN6l+UYz+tJMuFi5b/jj1G4zyzsrvvjd/V1TdBRtWxaXVJXyJzaQW+OcO+EXV+0rKbpMKDq4r/fz4b61NbXtP+teoD1h8vErIPGxyW2P4C/jS7ztca1wB9BC0fFWulabT0iTuP4rf7n/hFzah+2oD81L96vjVOtLlR/wDPnT7xVFfpkrt2ffzwWnfV3/cAKdZXlIXbrAKd42NG3vz/nWZGdgzPq6wdd/xmKr60/eJZRQvTxe9+/76snCrEdMvzpozIfruBaVKfye51uLmCvDiQTizT+Ab6/rMb5Z+HC+uw1t0fRwJGrdnfEnKaXzP2tXT6vcQrGdF39zb9b4sMc21jDLu5/f3egQUg32n9akPcCmoJy2O0/2sSMfMQf4TTDTiA/+/vX5Wc5lD8LjgvQMdOfnf+p82+PVoJojQwL7p+u/vUKL+pffFlC86Noqo3g+iDfni4eZNacf9RWO+I8+fpi1qd29RNq99Gfv/LhjWxiIMDv6ieOaP2Yrv/scvHLnxqMOJBPUZY26SCus/r3PrWg/tGbTWoTrQG+0/1DOvbLa+3EHl6o+wHc/7dcNEI93QF/yhOQz8VVdP7474bUfqT9kUQP7m+NX4RAn3cG8u1Sgv6jTOB+VhTRtn10Abi8B8Mo9exj7d4y4I/hCOCBk4GqPZjC/jpDuP+lLY/rb/yI0qgw/2udj9LBtYT5vVKQ3+9Yt2uty//wAV86l1M89Wh/1ImYefg1TGa1NTwoe3kULX7+YfUIYk0zbiD/9sF6VVsBHDZCqH4TbPGkMO4wPzUdesd0uStvNQ4bfNAWDozPLbRxMHzOAL+cwv0gGvautp8DRLhVA3D3IavYInT/cv70xDfNvdcmfajlLA3o2+W/7aZ0f8sgSaXhelE7tD84Odfw/aNXtfFoVjH6xacoOIczRT3Aj6NsZvpLYfqPfA4pvlELM/5T3/XGwNGc4p+/8fFVXKZja8TilyGequ2b5sfcF2ZtaZXL9Keh/iu52lz+5p/WmPj9hRLLwnisM/1phnMw1LFK+2s/tNKzJ4sXAx9FdPaY+q9/+oPrJloG8iFd1hIB+0WDYX3qX/42dRvPHLdUB6/DFd0PuRsMp74SySbNn/4nfrNv3/wtPzohz6N3TfnwtOznf79zQRKkjcTYTzzVH9QzlZ+//moV219H/6gX9Unzk49beV6YsxnT30eR17ggZw/mt3xro1SKhkx/o2EXn3cF+jvS+Y349SLo44/TGUrlcgbz/8U3tuz8chfNlA+Nf+OaqM3H6pjFp/aReqfnT6xLC0+2BxZe6bjQ0m9+cmyTteoOAd6G2TF7BVUaDAcIeUpN85t//t2051/A+Bdf982P/vZve7pMf3mhs49ofIe+lAbxsHow8CF9P9KuCZyPEk6e6Dk8M79Bd389Yf7pEo3STxKy/eupfo3aiq7/UUzWnjP2Gf6i8aPakuYXT2KtFbjdiMH/5t9zWAH4VJeD2qnvDL4gGdxMntD82y6+2qh8WTMC/MY4FdLgl1+7o+9Pz3Sc1kjq+U8w/vW/o99fyHoUGo7X87/AJ8pAOcvf/OUuvvA+Yc6/uC84DS1HND7QE53Q1DlmfojmT3AuvvyJfxutGf4SOvlH84uVBMlImMQM/jf/SX7Q+L57oEe2ORAZ/ObXHxu+rx21lyDXR4Z+4ujGXTkvXDi/+OYYA/59hVfZPAD6fPPrVeFJ74dxK+TNymL6h42HBadwS5q/zAtSFXPizC//vJ+3afCt36ChMcy/q58+5Bl83hOIqGkF3J+GEFW5sB0w/cV++DS/91efNWbgIx/jBgfU/yZexLmoSjNm/dx4jnJ5LdD84IMG8tt5M99vhksuQm+a/9npD5caxh89cIILhOD8cL6KyYvGP3fv91ve7++/udwquXKn+bsayRzRuexpffAEb/GI0q8lE3wjHLU/H3N3iV3nzPQ/a7gLWZEHzR/eWM47bxvT759PQvOHtZzS94MzVZyiI9P/62d/fvOjvvHFzpalj73ForqvQT6VViSDhsfKH+EWE1l92DS++Nv/VNsxcDk4oo2SPaj/VgzEXNQ+zPy/+ZV4TONnZR+b2EmfDJyj8X9KnFP66mGA9cWBgYs0P4zICcDnaRKK2nrOjk/jEzWL5hf77/MHKcGCWR9H46vVeboI8GlQKZWYhF7//Hpd/BWNP5wVtm7rt6UH9qGPF3hC+fMr37UzzQ+OOd6qzZPnlZqgpG0a1loWjJMF6BcGzT9Ocb3IJkfM0H/YvS9R/unyRwYxuz9CplyRWvFw/yfCO223BnO/jDYuMbVGg/1ZxC7YG96bgbddfCTN79y/UGU1M5ftnzfxVVs9SPB9QbRnhf7Wme9/4yfInOZ//t7/E+b+E8lDOcp7mt/7q89x91xSWiGsnf73qx9B84sn+0LFrlJ6ff789ben+cXcBvRnBX28BCiW2VmD4P75yi9uRPOLv/0xxebKfH8wVwjYowvQLw4D7RWP3gYD/91/NH84T90Z1mKN0T/as4E0JJ1gfae7aBeq5rDwz4isVMf6J/6/WTH05aUbeWtNDvCpuHtZaJIB/soD+QfmehrUXXw+zf9tBBzZnma7ff76xV/R/N/bQfgIteJ7rrq5VDe0+q6/s+9o/nH3Pu6w+hsHV/ANh9/845Ek0g4KjP5DNiI6om/+cBpmBlYnCnO/Kk+Oc9BxBvTt+julNtvfcbFVE5UoAHdqcZl5E5G5P771X8j5BvzV9Xd7PZnzNbBrkP9bFb4/L/IGLrs5830pvnJLVDtwfrr+xcmJkR91Sf07XkH9l7eUS9vbluHfT+NzhiJuYf8s5fyJGxwx44+aI1fJ6Ym+D191mq02Z+6v+njBYI8KtD7H5MzFgxDoq4XzRsWOmJW1Nd2A/tDQ/OLYt6e26Y6Bvkob+lhZRPcK7ROQHy3NH34o7TiXpi3or9PT/oI02p/LpPopZ9L828tMnGMy591EdS8BSvNxfKlEGp+jORQ+LXMRiU8b8G3aOXt9ssSq3sVorxRMfmLyq+99AtL8LT8xIZ9ZtUivA4Gpb5Tr4hJPDRPW12JiYNgx/Cd+hOb3kkf7sJrAgvGfbrjLRFRq9WR15jyFze9NwD6vi+w0L+z+96Nn1VrNELl/6u/NFkZtdvVbaP7jmZwbgRtzgE8qsKbdrBpWn2qGeTxj8rtgfsa7TSf7ClW9/N4u/2DOUfugyNbZyNxdqt/9TfGDMvHE6XXqUv8W2MfWQA/+2Nc0PzGOozKtv/ZDl/+oFYsa0/ol3Bdew+VSqwTwcTZovOx1vdzqr36LPjR+5RdfQeEX4Wji2cy9APs/4JB983M7+6yC/fv5T1LQJr0W5Ctm80sTouyBleNZGPbpdzrhUPTAvEhIfAoXuKrdeW1/NLLF3/xOYxIatbauYf5Ogu8ZkUOr9k5rjig1k9+bqO9FuM8K4i7643fxEyfYHxylKEtfYjGvNSElofbN3+3yF25AX5KllQr3V+jUNtXvZO8/+zM7ZoNsSPt/9eyrrj9qC+snVpBpeByWq5oke+7DEbr+Lr9Z/wD+sICrZBUWsJjKImNiXBn+In4aHJB6dNf9+R/HKZ8LKT0fr21mYXx0t/U3v57s6PgOaJd5M4f1qalToRSk+bbWqP4EArSff1uqh1k6QhLtL9mbf1f/88HR/kYzUFsmtr2sMZU/2GPyNxONKwMJ3Y520p9fjKVSGDkeLeZnhacsa/Ch/uW30v0bPhI99D+Uf/RT0KYZj7Na1x5gX6qUf4Ry90h5ia5vE1Z8Gs7Wx9p0U3WLFbo+2ZBQhV6Ar4lywKHqxe/qKV6B/uUx+bcJmc2Qgib1JevPr7f+yRz2f5bCceitH9+cj4XedP36PFTxem3va2/nKkqXf9zFl5uUvo8X6Ka5vjjW+vGGYvTNb+59//TOTKxnlxMTv/bNz4ro+lY2tjLnWJxrbwRKl7Km60vLeGSJuUfrFyqHNapm4rV27Yu61kbU/n8c8MRWL8A/qqVXPJqcklPnn8J7ln/UzMhSrIWXy9/Xr8VuCmYtEs/99XfxlXT/QZ8IRLRJ9FN//41AXIhkTNd/VubTTOQX19p2h8pAxix/qFn1mYAyC/Kj9/2u/lIO8hUPNt4l3R7p+2NzVnZo8B/5GlWwf254Kfr4dyIMhFFdudTjzVXI0tZFrYpjsB9Vev7Hu/RjSbkJ9JsvuTLNP/y9/sWnzheMf+Q2ftXpKxXz/vovJ6m0vvxP9mqoZGWp32p/LxP9v/xP9GY2xit8efTn926fNfp85T8ZvYo0XKzv9YT6d7r87rPcjhGSYP0kLJVFGpL1s/7mv8o63f/POK9ieWDA/qR4f0y5k/6ov/HT2rZg+Fu1ufCdnfGl7H//n/zrRCvetZo5sv2oe/nDpV1JlbggpF/fpqcqzbhMr507Nv4f+OopiMJYHeIeHJNjrY5J0lYntJymXD5a6bqOn8eZnJ0sS/ingQzVNhbYLlwO5ksuH4TTeyyhPvyfn/2Xv8HP0kUtw7Kp9+rH4F/84R0/cQraHOKiicprF7eO8KNN1Dqg+glu92A6RTxqkJTslQjdwiOY0jKtrzucIySjy3uIjB1sQpCb3JMbiG8vDbE1BDHja0NamG2KevN7j3GO55Gshf/8UcW7c/tBg2SH+/p975dt1xb2myEn9RTgwHuaB+2xQT56t8Uusx4XTuJ2m/c0NUbVOPgbfUCplXwuzaau1geT4w7+/ctl6u85VL9U6sm/7wcpUz/uG98kV/kZ/fJ3r5M+Pv7GH8sfK0K//qNbjcF3BAcPtWXCaziTosri4xOD78sCJ3Cl0qI/+aF1sCCSXT2Rf0jPwWdqcBt5TC5/3r/Byu/X//HTiHM4dUrjq77+/5owcDI4qKo2r0D//vUvHbH4hMMnbdkA3G4XJtbejsvMz6Tx90IA4xvVbii0lg9wza2XmOetd9BGc0VS7B1bvwKf8ByLrlP166/MNk85+LR7t0cfPDUlOP/HGuwHbhhUSLaH7oI0M+xm6vtcdfapfAMNB49b3RR9/9rn70y9CmKqDAaN1L1vf15h//xi1c/ED+fN5umf/N/W6u+PJthDRY7maopHrUjWjj60+/SZdPaBepLwZLEG+z4K7T7+L7880MD+vktCNdgGpF+fEUigvzVn3wb//q1/fl31KUXcUpxLeK49P4Hgjrkzsqa4zryV7IUqaPI8PjSahQdpkRWgoMsOZ6f4k2ml6IYTchAMLpNOFT6nolXbYgv3xSHxFWSNsF87r5FkKHgZWbgmQSaMPI3TEAmwmbV2GdSk8++f1SfmJdkOg0dF+ufz9/4awfw9yTUK9bXR+3BrNh+3ynkE9LfNJxd8RnQ///1p2tAywYAG+u5m61mtvhJtoUYhHuHJzTb+xH9uTqBfwa0Wt4OL0ecPnBYcQp/FXMMVb6tgH89Nhn8VnztyIznUsPnOpXg4t23mfL7nJmiActCgjNOkWNF1qw937gqncMPFLMLymjqhSxnwzRvczp+3hYJRpOCb6p3A3laL0sTBbWzwRBxyavrc70Z9+dzlTyv6pD9/0wm0kzo3QwmbszWxncOL4a+gq492VzW8fCZa6GUnu8/fuj4jnDabk/RXnzCQJwx+9/5lnM64vshJ6CizaV/+m7cTimX9plq4WekWNubZpA9X/alqq+fic8b8IMSF/t4YCzUfB036XtgzMLz36lTVxkcJ/0s/DYweFYkHsO969KsPKWcNw8i4kOU7XaBNvMB1kCQaJs4Y7K3XPFACvsmN/vn46efHNsX4kFmi2jZTZn/PN32oDU5nDRfnXE65nTHty2+32smafGoiuN99PVzraTFhzqdz1lcqqUFluAa8uraHs/75xUbtSx43n0XVr3/VbmzpWpjAfTb2Qi+cDCf4TdwmgvtMqdXaCQp9ga9H6r/1Mi80vSGace0giv/IzzBg5NvhNj6j3NCkX30NgeaXm/hoZs8z4gP5kSgeQvlZws9NOA+12xzk/4EgJ228YBCgxUhTgT5wv2zGZw7VScjU//zGt+DHGsb/8X/ps/svqCdVb9v2T/1Om6kvakhbiSjDAsZ/zgvNNozcZ+jb6ddKJOFSQKNKkCYM/JvUCmQ9C3g3hPmOD5HPyL8u/ik4V7/62rrg87/80JE0Dsa0vhAeTKP2T3/UAuhTndEJbe/pIBicK7Bva5DToDTZDrbGAlMfzz2O0IfLL3B/XTPexp669f5y/1L/46NO/LWVCWx9TDfjKk4tYP8HijzPLO7G1De0so1Wk9tNa3/5b5+H16ef9wp1VxtWwB/xURBRTetr9tZvPR+SI9+jc463Ldz+A2fG1JfUY0OrtVMF6/MHNsiHZgLz85aBjhyVN0NVwBoG1SQ6//xH9gToK8rhCR+FjIR+s9JCNThEz1//0YfVHx/bA07OlWyk7bAeRNdA9JVpf/2TfMntZHkJ+3MxpCQek7nTX98v/ilsz/i4jpAwGm8dhv8CV32QFgN/XXjdqv1WnTLwrn7mHvjndbMvtls9GfkY3HOUy6M1wE8vXse6J08Z+dnlj9H4oC5+OEwmPBmNPxqOTNsInfncMMlHBv4NdY3LJb0B+Tne4j3Yq5dpGAwa7iOjCfBnuDpLsXy4sPzjOVpC7Ms5xUGQKtZAk/v6SaYXB2OumuE5wuSABkh69eurwP3WxRfIUYDv12RRe2LqsfjWGMnJ6fzE21GpZdpz6TL8JdWaT3wb9i80wnltFpyna2YK9sm04r3wG9+Hh27r4HHwlNHA3AL/rUn1QXtSO6FJnthWXxeQPw5JSKbmd6b+tycmeqht560G+ks4h/tnwszP3ZWgb9wi6t/91n9vYoY+U+FJSvWt0vcPPlnApxCLz9+5HcL8wvl9/5qy9UHRSYGDRfFvivUI5DXHnB9tUpOH5tH3DdN7VgGX3Rj9UF8Yw6vyfsH9NnWepVBLd2eBOTWo0WoO+6uV0gAp83kT/6kvT+tHDQV0TiUHe6GjU97Izqf2T3+AzeSiFlp2zMLzGo7OcQz6/RUdI3zgdvtAgvNB66dVJnp7sh5O2xK1aPCcSb/8f/nNzH+qLpCA5rR+cRf/PJow65/Q+u9ccdSdX366vmHlx7jBB/LxAL+rbyP9hz7TCv5XH+j75HU9XevSiZEftjnjrqik73vT4innw/OUgf/yZ13A322LoHB2/5k/oamstQr4XX0PbsLge8aOu3PL8mLhrRm31pCbMfLzF58yovWpv+dzbjL3gzdV0Qtd6Pvi4ZTtbN8uGflimA1pyIrGt5e1TrBWRMz5mBx3uk3eCtyPtydPCvN6ZeFkQOsGNTQ+79vfS58w5/fnP7rB/EYtb4v+Y8DoR/b4qjzBvgP4yV+cQNgu+/PD+hCDPk/o+/dztt5mQWg7C+05O/p4zcXyn/gaA+DJ/WIU1mQF+kvcBKfUtGQSOrSJkNrS/g41Zyn5kLD367Srv3Cj8Qvd+9+Foa95Cskb8zGtDwM3EVJePoPvDyJ8IkMD8H/9e3TmftddHk3kR0TzZwmO1pMnY39lv/zAPfDHT/8aMvQFtqY6Wk3js1OBz9tFxJzPn3/KvQTYiUSjtk4qY1/+/Dc3GL+LzzgQZnx/+eIIBzprgEfh+pE5S+zwqolTObUOjhgo9HxoH1o/6jKKymr4Vl2dmBLxsBs7fBefQtKM1of9xt/BNjLyq4sfwDD/rn+xKzP08a6ETLXxh8anHnatVX80Bt/drNSb5m/g/kl2llLxcc3WXz/f1JBcW5pfKiGUtuaAtb/DOcqRFIH8GzWJWk8jy+bJbRAGeFVgIzRVrM3xK8oqPBessVUvH4x8nXbvoys4n13/RNdg9ZMu/kSi+YVAksI/KMz3p8FQnije7dz+3s/3hOEvg/YHkOcNzH8gWLzQEIPV7zZHkN8pzb9dSaUpEk9n5Ie+I9jWnjR/crVPvMwYYEZ+/OpDUv7v4ifEjMG3kctViAPTAsdT1691zWLlz8rjBOWx0tAvfoCcmfvJt2TuJW8sWL+bpGNL9tn6yToHSjPacDR+cC8b2BIadn3tEfh77tL8jayIQB8uGXyniw8oQf7EZjhfE6lh6DtRefzGTw/oc9vslPjzeDL4djYjLklpfuI0Ow/i8XDJ0H+y9lQMYgL4r1CfdTwslgx9jPiiYvUpLf7Yt5HAwM1zgC8kjvU//WWyEcM/xmumSNyTxrdfq0UgBm3J6sddfQgav5pzsgrrxQx//fLHAtjfxx3VwWf4UBPN5jIhM2sQcz37NxxrSvVRdlrf/u/9xi9BFnhzpTLxYY8d6Pd3+cChSG0V6qFk4L62VO5o6tbOP/1RmPiyr30hL6j/bqO4s9rl92z8VHd/5sA/RJKNmixtBt+k9aOVkdn+gccnBm6gF5FJQf1zclOAvAPVoz/+1/6Vh9S/1/UXiKog0Q5BipCvp5fqGz8BNzzNv/nGd01WzPu7bYXKk/NdGp/RtJ94HK4ZeED7Kyhc+c/7vo2Z+IBffTMJ5KdlS2KMTo7L0MdDoJ9x1H+3e+mRiGOfvi++6nV2wOhdDWh/JvnO+O9KMhhWQrp8oKr/vnrarcGeD45uf/1ESrCvrj4wv85+vQzh+0cNxt9mYM/9+n/gS4THAlZDvJkb/flPnoVh4sqZn7EQpFz12W8tZv3YHkZKXcwFDHe4JEiWzcB/9fVE0I9dtwbqEJfxT+Hu/f7YOHhzjEc578fAvw85u+E6SSahj0R05KbVKcb6MRdTfulbTPxVbXFPJNy4B9o/dyOBT1ZmH27PGlXXAhWZ6JGCtA/qp9mf319+1v8Dl861lvmXlc2MPxe4s6yMDidUtrIuTuKaGV9dbk1dUx7pA/36882Y8Z1yDEJ7bAQPhI2dhJrR3vh//O+bcWJkulmbMmkO1RiNVeHaP9/qRLeyoN7D+jd1Ok6jG6r+5n+3SvWW4QK/613d94+917YmBq4F67u9whXmEnSqRtMH2in3M3dAwxE2Co87wfzvJige0iT96/h2oopRVaDima/+DsdDO70hZ99e+t//5VcOnD7/kZOlXsid1p8UxRxVyuMyZeCGiSJ5faX1szL3unaR7PTp963fiZUjnH8cS2LFRy5zPrRGxAl+7eD+LjRpg+R15fT35/s+qiDaH8mwaq8wPY85v4ZhcwF60fpv57vu2Qacv/+RT1pB9XM1Pj/jeu0z3//Fr9P8/DS3FzYupk6iHfnZNCvts1xxocVZXEr1V7Us1DUpJUcmHNi6KNmkQvXTvwSAH2eXU61/DtNS+/mPQbU1aP8mDts0/v3l7HLxPZ4y69+eiKieznA/HbxiXujujol//enniOb/rOM6GIaCz8RnX55or5Qzqj87oi3aScHAv/enFtL8h66/yN1kxv/mH8jlhtYvG7aCNUjfDPxXP4fWj1Jb0P5pf50+/Kdf0PjeEWgg6UdZM9//+seVb3+elZejlHseGfkGolFzgQnqAPteKwn1QdP7+O7EBwomEs7xJ9DVcOp/GLh5b0mJLwE6oGJaGMXk9GTG918bPNZGlyPoD0tNspBXMvIrOG+wqjaTLMCSt1ZF6+AycENv5BeX38MK7FcLoXZvGzIJNgGXek3VBMNJwO2VczTT/vX/MvfLv/7fXXsxMxxKIH+NmJTZUt0JQTvRwb4hdnjGVbSIMm0wZPh3QuMTSUPzx3Obn61db8bG59svTuJ4Gjq7Oj3bVGkKBu4eQGkB3YjWFym1oaW8kOtqOz97ZKUat9X4MMdbdZrpoH+/q1pQVmx8tX4fqFsi6ZGEHZQ+4mF+D1yy0lIZkSYYVPz5okSKfqX66Te/9u0FiTr03oNUzJ1hNbY47YHH6RnhxbWMCh/rDP9o5MjlymwD+EhL/HDiFwzc+XjqGIcN6OeKoeuhKk0Z/vrBCxj/Z/+FTPzurz60CfpNI0Zy1TRv/y/6y/Qs/PwXnM+M/80/1hLvXOGxv47WwaL0ZXW4n83wOoajOX7y8pMzzKiFC0KP1lpyAPqUuDGz61oTKq6rP5zA+MbDnYmOvWTil+3HQZ3i7ALjn9bVCzU8Oz9vOdLf2Au1/Gff+C4TXzvt/MNDTfj1jyEjJj7U6eKDI+rfvkmNMK4Tj+WPGehu4yuM3/XvEgT4flYHFxSlxT/9fdfaE+9uiV6TgcR+X8qVlhP58w5/HN1bO/enD/bCMJ2kqzIxatO8SUtlMz2ff/6V7ZXRz/SrT1a4tLQU43ORirrps/K/y49Wzn/eP2pW/pOu/+II1Py5pA3TZn9i1m/Q+FZtx7fBn/qvB+Z84NnemOLt+vzEip/yFr9zGLhf7OWn/LAj7Vf/qlx7rnq8ZEO4L3WvdtMFPqkRiiwsSRe1NvcSbdOT4QWQXpzWpMs/2kQxHsdJXqsNnjD6xSOVRspyNUdYj10V++XYYPZnGKm+WvwfX1/WtqjOtPuDOAgKChwmBGQeVBQ8UzQ44+NAlF+/C7XXA7v7/eyDXte6uzJUKjWEpCoD/nzyo6iy26H/1F94UHAEz2cm1f2L09Ffk4nK1NlsyjCbUM1Cs83/5z+980PY0wrDn0FUy5blk772GCIfiyH/5p/N92c82iZ2GelDw9erPb9gZOCQ0/kQDVBvCfP73F8F9dpZ391RWKvbLcT3n/wcU6+DR+MxMfDjp6l/FadapZ6WQUf/xDmxadp8n1gu/W2hr1nHv/ieb48oxU7P38Q0eHX4o+eXfopSRz9jjZURp1urY//9coOIoBi785/8yD2vjbtMwDeKQj3C930+zvBM8G7kUTGIxxxu8a/+sfUV7k2iWyq7bnM/S4smrDyqLreDnqqou+uuxj744tZQiZzO/WLHBPkcT6H906ZCkuz07I59q57orF1C3fvGn8Ois772OUA9FRtPCdNKUqt6oXbobdhuC9Xr7Ri+B0bMHX/f4Y8znqKjoGrj+lu/1Hl1xmf+aEIgFONt+ud+BHVUnI22MJSmfruzHWGBPnRy/t6fjyz3poNSUvHk1OQ3+eQ/E3cUr2N5ko30UUf/ffM7NPnL7+r5VQ0Xake/vOvzCuMK/Kev/bI69E6ZaFvEUsAHT69nvWbLjv4Mw62mqfcmv5TgVFrUW0qd9t/nlzoJm/qD7++T1a77fuGTH6s5P84Yn8rhZNyRz3CTIBMVKdjPb/2bqiPfLp0KGhJ9wL3ZSpPEu9ahDy6lHlKnOb9L/CuKhkfW0V/2NsY61pv6AZelbMdBLHT0N23ulyC7+T6wtErMw4HQWX88sXBfb2524zGRNDTo+d39b4fCBf3sCTh3YS2cX+LYbvdvnAPtoko9rGA7mO6k4UHuyJ8+foFxjUUu4a2xUpHoDjr9O2NVc4RsHKcYvwzKjbtiq3RovDDWvH2vQq897WP7VJwx3+9fVm9RODkxmwr3crofVi9+J0NSBVsPP7VYtx1f7Iw/uIdqrQYKnmIVHP0sOFqd8Y94KinCjFY/EEzFtDTQFuhFY1sU9NTU/1qP8QmPN2iOiJ3TzJME+Ku3eSeBlF6VJlB91zAR/Osl21TPodDx39/5o/HTAfu9f9nbwr4qnfgpWvrqGC0J+AfqIF1b9SjpxE/O/UQnRFzV4P9UtJbkiHT4+85fptox4J/38YblqLrW+HTrfmHyr36Uwf+5bBTNUqSHfdONMyMoDAyXf+tza9D/8QFRDi/vHfnxPvWFa5Dv9VO5MRhJB//WT9g29T/f74MW44586vFTkzSjeZ/1zR877dDjiy08YX8053tJPaj4c9Pxr5sS5TuqiC/vk//BqQ4d//2bf7x8Vi3/mh622zHeDq+DSPn1rz/fJ/Ua6L0XIcV+5+M4CiCExcfhtsJIjgaRuF9D/BC/BIQul3O/HR/vDdu3Q1nTfaLTZ1qMKUKROGa0T7gQ00/+l97tp6NfvvVrmvPz18T2SjqqOvbFOPRpQhZ0ivAkuiqpXBJDJfceY8waZlYcegF+gX/2gvhZ2F8rQbh0+Pc9HzWAf7l/7knP/aPr39+58aJxPpWwrq5qaTiedtYnYi91pXlD8N+zyb53fo7Fjv75tp+B/umlh4mMe7MOvfupn9jkNxsoamS7S9p9f7MPhUAbXWB8JcksjvuLDq7ztEmqrzT1W973wy/Prv8oYRVppVwjnFp7BUll3W1fCNBFy/Umft94Q3B1tI7+//on8yb/0fv+HF91/HdLd4UU9d0mf8gUxo/PvNN/mFaoh/xKpHiRZIGMedLp/5u/AkH8cFvccOYXy679aO4HC3kI9uVT33H76qzftz7DpYn/ybmPBj9Bh/8R9wVJC+ZNfkLuR4W12nbwd34CIdw1+W2HdoL1xO/KR7DVd2RkN/ktTMMtiBt08euaYEovTf7gu8XZ8Op27UtTn1VYNePfIet+Hqh3//bNj6tiMXZHsRqh1ZGuv/lRfebf9NWiEIu1k8vxN//KebrGw0H1w/pIa7WP4nDV2PdBNp3h3TnqSb2S/bd+TX14/yTD/B1nP8ZLd1qxgcF9ldDX44n4zlf/5J9H9eL7ff02BfkXD+jOLj+3Z+wFV0PHuwuM7/v9O/hvfZr69NZ5jl80mE3Hn/xESlK01u8RE/9Hu2jhA/DMyaaxFa38Dr7cGxv9daYLsCVlZIOHGLbb/94PX+8dDAxz4mhUxj7eyYKCnLHRi7/5Ea+THg4CT4J4uYh9IkYFLNUth/FPJ9IVaR7gn/yOd6mVf/Lxyf+va7Y++OavmT9a5++POFivdZEaKiVYBe8s5eapJf+PeGSphkAPvanzyc9eb9ZNfig/vjT3fQax7jT1ibcvvYePbm5lpvz7/rtZH2OpE50489rBc1TqMV1NIxU7U/xT9I5YjZ1asm39unhpOP+RHhFY+6i9/m/7gAx3b+JnID0s4ScN27jJbDyn2ykN8IwzoeLRA6v0fIyeTDbtfWwJurJHfBg9UOTLlmyFqemTnlCJ6CL7u5jsFk2hsl5RYyKA/kAmG/n6UKx6zFLlXUzHKvKEhfq8tuyH/rhwp6j7chG3zmfmu4IUhhZhn97Maoey6BDE5PqjBepPDy2RMm/iYa9p/5JFUyY8Dkbs3M/kBw+XW+tbH+K0Mn19yvhPMRnZRoznS1XSpn1et+1XdooKlge+1+7/9pBj2Q2vVMXLI8TPvCjd2PBdusGWF6/wvQfBWf8+Mm+67ryzr+TjODimOsSbfozw/ZrpJaFXE/yXQWwXj8xexvQ+RHc0vsUKFiZX0RrGiN70vY5kVMf5LA7KBGnq2SvS9vlVLhdmcToV8/b4SikbyVblgn2VbnxeuIo/jv1QBP8keI0r/FhWA0vT76aqW73oyF7XYhUHuEZrhFTAV2EN8fnrghQUsOqG3Gm8/FM/wwX+/uokzJRqjRY/ZdK+H/+L67yMreLVg/Vr4WHV1C8Jb02+7KT52rAVl784/Ib2uDDoHF01No/PhbT2wzb+Ax6kjAsC/PlJC69Ybfg61q+ummpjDPzRVtcqRX6Ic8p1JqLDEOSvRT8yUlkaZAfwLxiJhuxqHbZg30MEAZMy+dav6e1xU59QCnI0e9rX+H3/Qzsskike+dmotB/Tpr4fQ1ckqpISaaKjHbXzGPA5yJuti1V/r23Fpv6JrK7jd/yjMbJvzm9L0/bLUj9gJ0ASmt2N9Z/89had4sBlB8Rt6og49TnsRxXG58xiQyClBPb3ez935x6w8ORS8bM4HD71//DOAfv/tFfDM5rEfqLH0nNeqEly+dQf0sOmvvLnfNK3AC8dPMQ78Aji7/cvGeJ76pQT25p5vgHGlAt4vVWt+Ht/vHmfLIn+LNZPlnegZ4d7+GKKbvzNv9Pk99151TrSYskz8MOATZ9KPIy/8WGT/3R4rB+W2F/7CZ0tJkd8iw/n2HgS/UE206Z+8xgHtpcB/+kyYgkjgX2Ov++/JIifrvUhin0xh/HzXThHPWYf40iskSLkKuCYIjV9udC+zvBWLm4sO8TGtYYW8LRbX6/4qWpWI/nYrn/3iU/nupvocxoXWBwdpvH3fpkI/odn2Ekcqmlz/+pRDVjpwv4LCNMnuh/A+rimQbhxKOyDHhqRxtJ7tv5z/zbbQ/xepVrafxQjg24vMcRRobyOR/v9UBPqsN7jWMnAGs2fIF/nZewWg3E5iT0hJa4uN/WJ4uoQ8ki+wvycTSSxI8LT+Ht/RhD/5Ace06Z+5yqOMTjacexdEfjvL72pL/m4ObKr36F9rvMtHqJiFrtqiCzVmnfrL9bXaIBEVk479QF7niJpm6b/wSiaIB0sYRygBZlQMjt0+OsXTEBj5Ftt+o2R8mqQCp5B7EUFobicneJv/lYD5Md95+rBK08kJyVgTL+r59iD6LOvi2Jzv0dKfB72m/qL6SsOizwsdp/6UGjc5I/55ndQfYM81ejAltiG/fF5P9IH+d6/ooqhqQbyjZcVYoNlto2/92v6EL9/8r8NQX4I2AerYFpW/Mm/35Wf5tPeky2ZvG3Pb11HA0tdXoyc/pzjHM9TdR5/3yeMdQ/7pmoXfsywqq9LPMLziQi23o7tUM/pZI83E0k+q+4N5hdEVZ+tlXIdf8+/Z837U0VMMhPc2ISsfSSz2YZv4m/+y+b9vCuyZ6VqtKl/WVYPNpDt1Z/6Yk199M/7FBfki16fcfM9PVvEjrUiEN/Nu+t3ybhRyNVt1Z5fTvOksNYb4O/Q3RzYNBLLP/fDlrD/uFw69qiSfEOXx9s+LtbxJbabj5Lopwf895kdyPZuA+MLetUWDbTCiMk81vYanoL+fES0j1CSwPw/9vtmOLH1GIJ80mGTv5vwxDZ4wx85j1M8rMQ09k5EP+n3Rv7dB97Z0fQE+qncRHN0PBaHP/VlOMRPV1ROZPdSwPhe82iGPGQc43f+cM1cAv9QVIxlS38Crj9Yzoobj2Pjk/+ghPbpI11YfB25Bt1sGWfnlwH8aeqfY9Tcr9rY05ulbC2Qr30W2/iZZ7vYn4yEiybOm/xWz0pC2njrGzidFLQQh5zFXs9BRF029cvKQlxxb7X2RH0VFlYx6MmT+Pv+cgT8++R37xP3oI+u0YvdLX8Tg9UQGPgHTX22OPYzPOEw/pKC/OrYX33qI9NHCfNLf9AiVejSM6haM5n9iE191+1Qz3SJJN73/en54ML+M9mJxcJt/ke/XyH+cJ7WNuVTxUvI8IcN2OaaJLH7yT+xAv7OT2eY4DBs5KPARXEugF6vOKLacgfzu25uI67LJuzvqCxcfFD84k99r1eTf+Z+W8ijUQHzJ0mloAlLFp/6g+oSA32l2mkWDZbN/UWluqLJiefx9/y+uR/64X8xbuofVShk2tmT/uSnsCD+OqxonSqpGCU0TeM72Esb/OUqFtYqhG0Ua7fqzlDd1L/Tcj4tyNB2Y2cw0pBak+b7q0v7khQ19efS1zYp8OPwE9vxBtXCHXx8vE+VF+vTYZToP2NthwgxzvH3fS1N/ss/CDgJa+2Fdkwt40gS8YkOaZN/ypRNHNI+jE8+IRHNdod9/H6fLPgQo+DJOXFKqwJ6LKg7vVi9kmPsDsYEtlrT/sf+eSegfzjxtJDIbRMbq5sh4ieaIlwlZ9UaXH+aXH0uDzF/JdtY9yIyp06TmvxGE8zNVUNfM+7isYAXsd/UnyFqQ2+U6eCsXM/Q/yCunmizTMB+3Cx6IuCsou/7AeUB9P41OqK4jMexnVLYX6Thn3CP0Hk4BDdE71Pwv6Ia9L+pUdCH6ZFfv/fDYsVOdF1+mkUxzg8xXdeGT/QiOqFPfJQvwL4OozjDdWmPY6u3gfGNb9zCZu2T2M9ndkI8K9qx8+jGYkddmgfdEKsNulepgGpnACH1YgWCMfgpt7G9VekIh/vijKMNFZgYKfbhW396Vy5j56GCfO6rYoV3T06yURrbBj2LlYoiT03jwKnojYYPBvZQT0aZzYIw0dcTBD61F09j5xmasb616ytmWQn2UqShQcyY75urQ2nse4HZfGXbM9AXaR89F0fgb+lENdLKZBd7sarc0XEMLpmdSo9UmbggP6Pjo48uM9BvlpoaE32z2SOcDY1YtrZP4D8RJyHeHPzTn/qZM8B3XhnFox8T6E8x+C/HLYZY+JPfPof1+3zfDaZA78hRgdKhaHzqI9Kd26zvOz9IUIN8OzVeFeEmDmKLWRrS4jnIh31K+5FgVaFIZT+as8ursP7oX6+Wvt+X6SA80JziZ3Ec+H78vr8pTERaYSk+91Mh3ziJPokLgm+aOI2N/VDoCe7maeEKy1EcKgPwjx8XprAbUSdxlNsC+Jfl8/z9fvraRQY5Dfm5AO+Wxka6EBxV8GoFy74R4JEyDkU8D5iPZv7tHH/vzxAq4cNlr0SC17x/Mp8v8Cd3Rhl/35fkU6Cf5GEZCE6YUP1RHZmxLoH/y0JVVMLrMx6WOZGJ54QHPfkJZuzl3E7Nm45hjdhuX+GrkluYeHGQkH0A8nog+eZT/5fOcvD/P/WRrVcg6j5nPSak+S6O7k3QrLMpw/enuoipW4L+nHh8Xcz8fB1HoBVH9PyasO/9ErYD/w389xW+MvA/qT/DQ7KNIf5YerdFGZWZK9KzG93QUsXz2FVOEMo8xzsL92BJY6oP3QM1xhB/ig/QD1GfQXwwrl4UU+mqImWSOwfMtQgxMwP9ZG2XaKbOqm361W+LOciPN67OTAyb9dlm6lHQPJCfyeHal5RZAniTLa44SwVsps/7Ng/k5zSpH1HtTED+6T0eFb1KXMXREYP//eM277ve9U9mY8AfbiQwf68WsXfUaYG9Bt+QxolbvEA+L7tHyM5r+RJ/84PNoP/avWFsvRCsrz0A/eYKSRAHn/yFc6rg3jKtz3X/HB4IzWKzQElzfjFaqyshmMP6qQdPthR3AvKtWc+s4CY/xPZRIiM6/mnuJ7/ru65soN+FUYlmQrmKTfchOBrbTStsDGtN4oeGnr/A/uc6+N8RFZWBOlXrCoum6tj2sw4TbP3grNA3oL+dXKQGZiXIVzmzxLNy6kcG9VTw/8uVuI2DyVgv6HYC8q04WYBtYQ3zW/T4FB+Juom/90cdwN2YG7Ie6bA/pJTPiuRSLGLDPqqW+khh/tvHFbGnXkbGd/+hQwLxv2m86DPYK/hFwa3AU9cR9ZHJZzhTi1VsT16wf+XR9vzn/skd+hcHD8KcJcSn3jwkGzo8wf751qc4w/6LA7wsXiSbxO/6OvjgwP4rClRbiunD/NyUbZGUx8f4nZ+IvO6A59r0xZ6y5CT47jKIMJYQP2EN/H9B5MTCl7nqy55JoiaXf4HxvMf3MXkN9JcuXIDe6otJ7Csm8H9fRgM2GN6KOOjVJKORWtff8znr3qyPjDN8l8D+ves/I88F/eUJ4OriV9y6H/3g3++L0c786tey/f7kwZ1rgg3St8j6D/+PHfp3fRKUZFuCH4kdwv9yW/ezH9xUd2aOZa6e0DgQLdtLl0Ebp8pKO6ujpHC+9a/8R+t9A+CaQSe4NGINp5UB8aqwdTv9Sz+CgubDrYaF43QvieDJHfA6LYoiORxq/v3+QZ+z1vi+9S0wFzvje+fXOS6DhI5ctGG7kD95tF0OTM19oQytN5FwHlxWXrt/PFlLlXD6may/9VtK2uEPDt+POiL9iSNbeqD+5gnxuT59aOAh3V48OoEjr02SSYCVcTziQTAIDbpymIR8Hz85Pd100H81P+KbX/Fzfyi2+Ie4UWdqrWplbP6L/6g9v3tPnpXmNG+ND/FoXWObYIm0109/HZHFkgwP2vQf+4E2IB/6hdXo8EqG3C8tlAoPzNf4PspJ6d4t8B/SnO+KeCOq3L+Zuoy326L39S+xEbT7N00LSeo5eK6/578ZyB9dmJXF7k7c46N5JUB87OIA03nFpXq/B/98sIqmaOBhhUNraipMx8UM63fliqQ1A/mJ9ScpFEeUeIB0UmJxiZ9YfsQ6NzK9JV+I+zWB+FF/jMn3/Zjid/iDxw7wZyvC/ihEcVuMDivt94I9jP/zPmCfBHiyTxLuOCVatfDIM1AP3XeiiUdZpFTIGYBLYf1sNFav+JBHCxHinxETne/5yzEftfu3yhm2aZXRwff70VOnbVyf1OiqIWaYWLduJPOWZ7s9v298MaFHjNc24WE20Nv0X/uN6wveGhXE/9vtYNoa//d8gUP/6g68KjMhTlu+rKY+hD7D9IlrP5ItET3RXqPTaIIYk4d/8j/t6+f3fomSGQl9KU+78NFhyEe1TlTd8fZbvItKwzbDvtkeH1V1QdFmFxji9qAMUl5M5at6oXha2EI+5O50hEf6OU8Itm1Lk16l01lfXQj6tUDkyRE//YNZ2KLhttv/2lcyMTGyZZ3b+76TtPDgTHUB956v45/8rqnfxn1d0EPd6lPy5/xAdts4dQ2lVn8aHLZUdn4KkmvgZCD8oPsG1v9b/wnvZjjIlTLquamX4EpuruJRX+GUMN2mhj0+gn7Zq5IclZ31NdRAfxF9TE08PysqkwYrW6TpblMjVVSH3HjehwMhnOwGML4qtbRE9jr643O/cl2PcSKcj4xX+874o3tETuSU0e33/mZy6fDHv4NggysC9ORSkMJfSSORbm4Q/6vrcsjDraythHndfH/JpY2kWh7E55bDjUIaw/4cnXytJwjzsYbrF8SminQzclJNwcOY7AzxT/2BHuwvxclHIH8TiFesCpeY+0afv88nqR8ArspUQVyamgktWGEXvY3Y5/4VtrSQracLPFyt5DOy15ZIbiPGEVNioL9M1bNAVrXzzZ96+JFrxNNKQIJw63N7iRRPc6V6gPtSJaOe5ukGfgjoDBq6gPaPW8JJctlfsN03JrG/6YE98sYxKfQb0EdZDy20wxr2Z5LkP9iOU/A/ek60RMYt6/P3/SHhLu7WeLpS9dINIojvLjLDLK3sHg94r/dU0/Q1APsraalwfRoHghS2YueL4bev33/qO8g1Tr71KTZq/M/0PJjWLvgX0sCY/g8cnBiBPTd438ZHSmmUdlxDrP/J73YqO7i1iqltmw+cEH0TzNB1cTvy8LyVA221ZDskcotbku5DLD4cAisfT1606b3NQY8JVg2DFGaloDG4/G0c3LmtbBQq+NMOZQq6reTs3+PX6x7EB4O+sW7jUeX1rGc4Q1PhOuYBzlZ2wY1tDPI3uFcTNDmqtKAzpu2FH4sv8eSFF9xBC2Rq8iwU0DJM7MyBeOJAJ/PCKKZaNob9u5cdYd+879gN1RHXD31D1EHlH5E9j6d8dOyrU00e8CteImxi952/wvBhf8z0YsujlyRE2sHE51Z+D/1eoQsqj8Wynd9jc/RpZtyxCfbtBdI3ysGHd39EtBbyJcQ36yAaoN66r4N9PHKGf7bAPwrab9VUu7e+9e0Htyb/5NtXFssf/n3f6jbffzzsxFhJ/RyPvMm4WHv5z6d+iJCvAa9VpVf1JmPAxWo8Ly4pUirp836v+T6j5OkDIVm8rFAgoj46LIoNt6iou3SDXgr2h1XNpNOc3Ej1iDaI1tmGu039LjzZTCPszu2fzFUnzk23GMT3J7HYcbtaaCm4QnXz/XGVWsrEdyFMna+PTD3JB04/+d2b/O9WBEwNqQ7j4xm7oAQmyH1voK3UetF5X4X1x2bO1Ei+tPOrScdbkEWc+Dk1+oizNIVA0ahhy2l9KYmwdIJJ9WC6Pv7RIJpPjMTk3/tZiRhhfQT+hXsyvBtBuJhg65g73LFqtEfhuXmf/84fvwg8H5dU0Ni6ViNOm/pi6lAULbweHWaZ/5Jh/NlplxZz3tznPQdExiQzpnjo3XCpa46f69FjrTGqc5hf8z6WhEaT/+5dXxfGlxO1LMbFDYsnbvkpOqpSk9/1c39C6AOe719JMcDZkX/vx6eHTv7BEZ78FBsmH9v8qY7neSQTCfg/7bGaXR/FhNvOAB/wosk/b41Vn+to4OTU0WD9LrM85cGih/t6akN8e0/3qFLGop3T0KhKdif2huObqVJkDSB+nMq1mopS37x966vrMchPMlSfQlzWDK/lvXJ+DQfAn3LABNYj/p5bK4+UxGr48znfSpr8dpc7U5kXiXvu3IfaVYub+n+3C3tKPTME+qACU2Ua9o4H8VnQkGzA/Ai1iWxOesDf/M5xsdhlWx5+6relSYc/3i1SkRqJ205+yk1eyNE69nwayfcBu8XZiXvDCnmC19TnmA9zADcxLOPn/Mb0z9x39mSDV+XBwzSUJAtN7jC+p8oXxVSC/f++X0No833rodRSpJ1g/+rCCCxAMeLAv6Y+Hhk031e+7wNKwDUtOjF/jXOOxSa+o0JzP/Raa0wRgX90dMWzgsXyAuKjA76REUn+y58I9DgP+LTAZT7netTXlzibdfIz4pMC7Z+rctWefyt/Y+IUTuFXh2kbB3sWcTd9UQOfe+A0vGp7zo3pmrz03u4F+g2vxFTyL76vT0ZFiM9ZWf65fxg39RXrwpRpnfs+eYjjqCCL24WPmvoVus4BX5zEsW2+8iY/b1hEmDgZyGd+QYHwavJjywKtIw0365/uMPBjgGecHK94qLMB0H/rdxqwP2gQvdjP/jD+r/5p833DmSLWczNo/7FgJ/TccJ9H8xi7NJ5081eyGOxdJKhWe/5TDMOiL9Cv+n3JNJSrB+NP/d6GPvLrn1QuYf/qY796sNzgzqc+lfZovh/LGLuZA468iME/iopi6heg330bU+G5Y9/6pUYF48+2EXgnmVh8/Gc0Q6C/Uo9J6UC6uqrOX2zI5JkB9udxEu7a6gbyeVxGsiTkd5DPPIx67DWD/WVbip7RhIF8erssKN3kx8314gfJLNXkNf/m13i//8qAiA9AWZPJCOJRejNCbloQeFG5qV/7OV9bDgC//Wh9ZhMD9NvVESLBbe7nL7NaShXF9n3qPfmmeG6KAzfcCA2E+b35Pv7Jf7oA/LgF+3Fm2YL7w0iYqa8DtE8WPMa05wN+hkCluM2LhH/zpzTf/7O+nRTmEv4BOWKwiGsH73gkECLqygXWH6JvV6ZiAvrdP23tYh37x0/7wstv6r+9838Mtt7tv/OjhAf6hmT4cQD9PnzyA8Q7uqfi5QzH2OA5+F/N/VStoM33nxh8VmuzBPn+fP91fcbpJ395M/7pDeWVfK5d9Vv/q0oy/s1/eAP7kP14G0mwe9C/obIj6t/L9R//sWjqHwdKKfF56alktgf/he9gf7u3lYZQQoC/n/rR14Wn0ihkA4ZlWH8fz9BM08xmfdaKcha4DuN7wMLh+SVZcx+F2kpLnGZ8v/WNRsNKQwYG/8n8V/0mSlO0YJfYPvwbx4728NmE+2Ub/9wPUPpRriO+XReoaOpTnjN0F3bN96P1zlOQAlFCri+aZPmrSP356Cc9I839ytIaVsq+jnI6yx47dCFg397+g+brIJ+5lcWyc5aB/jViB0bHyZl7oxUeUbv5/vWpn0IvUY5tp0JsukkK/s2P1Hxf+uRfiCrAvTF3ixNTd/ybX6L5PjR5lqOyuQWc6ynhG4iHQT5xbyp42rFp/xztH+yZ3mB8ZciObO3C/gkOOowtA5/yU/9JU5r2MwXVbCGA/rHWDqoFv3m/jlbJCAf7IdCjE14VYBZn/P19g+ya72ef+5MRB/r1uiDYWR90Hjm6QIRXQ//9vndqxveWP+Pmce80U5HgNN/HtNp6WH05gvVLqshGk1skVVqTf0adWU39vIVvxaElWyodzGJWLFNLroR4hJCW7cLf+1U2+F87lqOFcB38K3+qdSOsqe53ITZuw77sadGgn1kqntvxT6G98JVbei4gMGehi5ZXW7eN9QTa34WPAI0E48KtpassBGXLftChf4WtshvZN3063DpYA7cB4sstwVhw4umnfhcKCcz/Yj8TzLe3kuNwq6TqerVHOBfqnzMyYf3JXXxYbIWSy5/zzQn4n2tku5wsD0FOXkqRF32hWPORMjYEbPr7KX6puVX66SZQCblAfGOLOfivEcMP0NtThkcbmWaueYXxnUw0ZqdFc9Hrk19yB/YqA/NX+PbJ8bFmAX/OSlPvqXioY8FZxRL+WRoBxys/8r/5x5+wfwJYrZgEy72C+69UQzUdhypYoVBi9cg+8zBZGi88ab4P9dfZqdCLFPxrccFHxQ8/BNz+cSDSLWIyxXvfAlf7tHN9Op3B/oBQY8K/9ze22wof/P2VyTvq3whvQo3nEIP+YT/2g1zXE+BP4B8Kbwr6j+xfSGCjHt6CfU1HBaUgedjUFKHqyTvbx6QCC7nogf9t3+8I/OChcEK/8kHnJcmKdJz9/DP9bg78jHzkv4x/4kCvl4WJoy2s/7/pP/klD3kH18FalEE2BP1PM7ZjQYDnnGIX/Ktcee3x/YFzGatDz9enXlRCBO6nHJ/2aIt8+eXh8J4QsB8j2yfZ/BGiYgf8N16ewLTxMtygdaaoVu0NbV+XfO4V+4ofuaMu1L22PaIlNGIYPFhVlkoOLxIXL6weublsbrMG9maJDvgqSL1ya+f61d8ZRVSAf2SeDWtOrVm1a/EPC0QrULC1T/+eP9VkcsbnGf4fOEnBV0PCzD/8m7+EXYt7Md7iDv7NL9vIv/UDoVh6aupjPiKq40XzvnBzlT0c/QRhToesEtl4n4B/mByoStcvev7mz66b9+WaDPIVP3nM/ela2aKfO8QHoH1mtjHdg3xPRhFC7HFz+Pf7rjWVsJVUd9YT9DDXZ8LjCc7O7cADQTeWxHtA+5/4V7HCm06nkxFeTnyYf34xN1TbQvv20MaltWKgf7w+17GD5T0fLQPyQ8XFZo5GP4dRYVULwK2fptTFs5FvbwfxTWED3uLPPCssvOLyrs2fbHRr8rktYP2FK3ohnfMdeHh70P0rG81RP/E0S7Qetk83KhORGfE9D7UAL+mLVst2+6LBJHbj3fOT1vpdwOajlXn7HzgOQ64Xh2PeGd8knPYicZJEPp6ucIHtGOTRX/yAffgZgX75+L+ODfpTy6IHupx9k4dRodYobvK3TAp2Rc9X31WxLlQDhMJk9+f814H9gYbglNiji+vjV3+b4juD9fEDnxxwdBpXGKmWag2nP2BfGI6jYrYrNjzIVsTXL4Muf8tNvIaNmeXt8dfrCMJOi8H+y2vWQ/JTLnhQLGGrXxfAX7qScUbi5hlWk00Pb8xbzp1ejTx1NAD+uvuYlPSAgX5HwZXc1HgJ8etBOKK59GjzH3/On5/+P8+fgP9gTn7Ydmgv/sf++3yfk+3O+dRphAaWel+B/S6uRC/U6BZxrzrrhc6a+5mf++0X2/H1JqkjWuug/+mnfpCPle/9q4Xp3IhSPxImB+qJm5uXUAur53jaZJ6hpX5wQL4qjc8L/hLn3LRP5AfHP8KmNT/9FsceTsc4aY8vFadq1JODJu2EVW1ZMYH4333mJMYXXdh98wepB9BPix7ER5FpJODPGYMBkhjop/OlxNjMYuAP6H+JeX3gH3ke9CWZHaNNy3+gocMZ9rWmvsO/5XsfrVn1aOKzv38gH+ek8HE/Fjvnn9/84Y1/uKzQk1W1mnD/YcD635r7H9dgf7XqV5Nf4FP/1C2a5w6ZMcFKk1/ge7+4qf/nWjwtivrGuC/sTIyPzff/KDnM7BFMJSeeXw2RXBiwHk3+UzIbA/4QkXYeiD7wv15WKXvWGMzAwcAGlYTNBrm3PWJqbIF+mFzRlSlb2H+WyIiLH7vO+pBBUZUMWG937FeAqUzkHPivgLePCcosbr4C3aXDEfD/U//d3gNeOdgtpkkWc8+l4H/28pb9AP0gnSE+Hawy43/w/zTCQqFKt875szLZV2lNwP8EpX7fo8kuA/+/7quKgGYUff3bwQZwTcNOITzyLcelaJSYRoCb14xg45DA+q8uYwenPQ9VSjRXpprI2Qalt4wW5PiE9SGXTYReZn7iOtrjHPvN/aD+o4xse9bknyoNEhSnnQ3xWy4YB9gP4P+Ms2xaekISqmTkweLKzm3Pv/krrtP6T37Cu+N/vy/6MP7QkUH/jkNCsTlJFvZoaMP+0uxIZNoK/H8D9DPG1y1JwT+OMXc3pn2j+yASUX6B/RFSZITUsYoptu4cy07m2TcMk6jZbuT7nB51ZGmDRWzhIFZ121RuwP/ZpXoycrchPq09sJ+bGzgiTeK02OGNf1scIw0ld/XA7fGTqtieAP03f+0ubM43uV30z+KWm8+DccKbGa0wBStcRopkN/WJ1gNmBsC/aB6Rl+5qMcXK9apEL/kI45PAES34UJ5zPaHCVLhq3MLTu72OnWXp+sS+sDOz5/6GO8ZLGGj8CP4hvYqWbPRPka+Pb/xYLGYQz+l5qcvkHjT3Mwa+h8ltAf5nbfK8KEwj5e59IdxVPt5OcTamGhONla3qjwHsH3WV+dycD7SpdlzHDOeDtG+hZwz+MRqxC8vusP/f928RTgsFbyrRykhdQ/+9fZEWwuGQ/pl/Cfbre//7DP7zJz6+ZStuhE26naK5HzLrcQyGTIP9sUpAqLybuuG2s8ND3TexheljpVmvUrJvRBgX+4ItkiV38Bal2jktPHzV5Unps2XTfo3u7Ef0p/z7PoDVCh7vbnFphq/I/9aPWZYFJ5t6iIRsPFW+55sK0OtWxG28mYL/4S1d7SgYDMb3OZ8cszAnOwGPi1Vx23A3dqhB8HZ/xraSB3G0FMIbfa1A5ZLRDdx8TyYj8mCw/rep9YyEJgWUbjz5FQdSAfFxPCIvsvyB9ifazYlDUYfxf96PyqB/v/l3JrWEhV2h2wRYkuPxCQkIE77l7uwxDITwzobI9xJaRP7BVslZfFq4nsawPyH2jal9xY1JV65gHxRo/znnHjaPh93n+7h2P8P+9Ae5K5N6FKrf+kObbMPDe6XnGGm0xgtjj6TB6QLyETKsY1HJU06nml7qYVlcsXaHQMWbJYBfQbujy1KF+HqskFBfVvEen7m9sb0RBvsZ2zjGZVJu368jt5q94uhP/tE77G9YzbjYqdA/rVQy0QP2hPjujlA1KPq2SmUPcSZnPuiPaoH2wsyA9tV1JSDpPIH9+fHvXtC+4Sq6oO96cQpObZ6U0UmA/t1JnBUPA/yP7/3A5ZhiwTLCAoILXf3mv3BjI/63/j0fyaz4eddPsR3hjHIrFFv6++v/kaLzfqhapVrEBd9Q9awP/ukmy7f/bl/fjIQYKWfQn1S/C7XWXwq81b5+PGG72J9U8I9HBnngevRo949vqypF1rk4cysIBCbM9o82PSGDymdgeC7cjybkQMfPR9FuvxfGQXF4iBs+mq3xkmy1TYf++eRRsesftjy8OKgS+mIH18X95oX2L0orYdfHsv5TCHKbPhuDbzjJ0ldVf9Z3uGnj+GLzEPtEJtxjHhnRbAnzOz6wHlu9w8inw15UsHXe5NP7/Z11EKzgPh6pZLcpXoXLpP6/86PRw2usFra/ktr4rLwKTE43FvjXPlqhRAJ99M/1IaCf62I3MP6HfNCFFzEkXHIcB3sqm2ihQbzcokeLeFpM6/09QsuCJPr0gnAb5xreFVKV2Jwu7sJZm9DO+pKTC/t/Nwb9rY89nFAn6/I/z6ohQ/Ftxd1tgRThVQO+vdk6j64zy6cTE2XoDtrtf8zv2q8QS7E9buOluVLPaGWZN7LWQf9uaBG3cSPO7MxFh5FK8wf4F2Cfk/8h3/OgktE1OCTxKOqNNnhps7K9/tuqec+4Er3Yshx7RHqjKGvPfyUWc2w7ePE/xr88gn/1HOGYO6sL5pTY3f0J9lEvzhBncY/XeIM9UOoo2++HUS8/jVRcm3FYZMssb7dPcSRE9WVp+tTnoD/47pb9j/mhgg2Qesy2cTDbU5+CPXm2cXeHXdw/qXkczIfY0LWacaT+iJiPmmzz9DoCf+O8yDv8/7wvknNDpac4ClhU2lYbX1uSgIbbaqyShBXb4hFnvfhb3wBNL7iqbKvUJ/exihe8ypm5vvXj0Xyh3gXP3x/b+OfXvH9u4WFdOjg88A7uDxTDpzNx+mzhugFGCy1ku9fG3/dzwvsJ8JUD9inJCyk2Lq52F3rR/v53/8375Fb/7jyS0+c5n/h6ErECra++FJuzk2HQU48eP/ldvMcJcKZwF1dF3oupR4cDzX8AvvRVPTbXm0neGr++O2FRf432l/b8goirhT4t5H/PrzW+Fk7HUzUVI3kM7fdgv4WnTIrpGBk34rj7J04XCEXqjzbOW/T2qY8hHtEBd6xYzwJp3sHd5dzQMUnpAMsrSWjCtvGthQfVCUQpXOw1PLjnVhydfzrjo4pFN/rFqTW8cRGSpD6etN/nRyqFoKWfQ/+f++f2enz71lfbHMTYzC10VWkEuI0ypyRbp8M/86gPB0Ll1wO8VpmEevq6Ix92TdAMDWZU+5Of3Ry36YP9CnPs0PqJkx9FPmvq/L/5vd/331TiY2EI7e9tm+BgnU3a/MHqXrd1ZNYXrHtVPxqgepITnbItm/fiXvw9f1/C+g42CKUiv05u5GcdqWgI4UBsRD1UC/aOXnB0SEblaOBPVOJkDwXt9Lgfu5/65XZ9b+Gt8bXwN3+R5E9uVJDwBTuvpBc7I672hF5/P/ib/r2+v/QWm8qofx5MbvpBHfvFihnSn/wH+7qHK0GRraFiTNr8ofFFoYIwAv4mewzxzZV1+PO9H14Bf3/EzOXOdTRpyw9sOeWubXWQH2JZWoTW0077QUSEvWr5idnCyfUqcHaUyn4bN/LCKIKwAPpvfrmbFDs3RTiqD4gB8eCYgBIdlJOcBi47IYhteiDfP8IKrdXkz/3Pwc8k10e42jFZEKXYRwNY36UK9H+N7y3/v/2/4+uea/wn3+/1+eQ3uYOP/pEvbdrhD00HAlJTCH3+pn+vzy/9L/6VL8Xvt3HFlU175IyAfjyuRHTS1V78zS91Ek0clwidn5ndGV94sUkGjrzh4LEVyUjlZmf/OLuHlmp3Ceb/F30zvhb9t34I9E/cHbNRPwL9GgoDfCPns2F+86snckc/hE3+U5UNjXb75OeGIGRZwvq22v+8b7GXoL+JwE94RsG+RMMm/8N2DDieZ7i0DLmzf9/5K1VR/xf+5v8vPj8mo9i1c7BfH/lCHOTnk59lnLTpSVXHEAGqar9N/66/Mnrp4zZ/g/CCd7pYA/49X7U7+Pt9In4lID8m8QSGHo+OfjLAplaaeQf5vN1so3SYMs71oNooDFygXhxqfU3TwqHoYDYUCaZLtUNvBXMIRhY9McD7KepbtXLs6Pfv+wMG63vxM5zpbDJur+87Pw7Kg2b9mu+btjDv4N/6IZfDP/pv8Fb/zgHT0qDN+D/1byPYX6O+IFBhqhgd+odT9IvLyu636d/5XbQfryOf7/zoeDYzxn/yg04788elgxRVux1mf+oTM7AvegjR8/pHFuPReENiWphAb99UM/PP57jjX7hDYaaO18kYZ2jakyRWxR39+clPuTqM8fCu9FK+x535v/PD0zQ0Zn+Pv8Fb4//FifMgE2zaMP8W/rEvagT0VEd9RjIM8tfcHxOGtrho4631+T/w9/74xT/yOWWw/4azqGZG0/77fT7tnzt4W3/84nkKW1UPT137me1Av6ksWf9N/97/v/Tv+jDcZR3+mUOLvIgkHxZ4vqyH1TOfdP2fmgoEReVhjS3RJgXe7jvt6wMNT/TVSty28O/3FUvu/xtvy9cv/vl+I77AvsoFT4qisT/f+hzDDt7qv4Wnggj6YVt02h8JIbhXd+1wxJhX2pmn0w7/vu/HJsnx7/YbvNX+UrsiqVezjn773m8aA/2BZq4drrcd/thhQUpSaoD/GKhfSaM+2L/dHcXIlWH9I7JBiqY8xEsLb4/v/8Df9v8XH1r7XvVcjiYqlVJsFX7T/vt+oiAF4r2Ft+XnF//Uz8jFrvwNhuREzbNxx+V5L0vyTu6MLxgttUqVxuIT10eqIa6KnfkbgQROJz0B/Yc/m15n/M661l1K4sPz7/G99dvv+D75I29OB/cCjGZaTsReC6eKgUuwt438/Atvr+8v/v7ZdDFtz//tPwhp0cWHPbwt1hLEVy388/5tEnf4864vRlTt0MOFpuoyLmed/t/3X1H/fhjgJ8MOD15Whz++JkHEyAbQ/vt+Yu/gdv3Lpy7U6uEI9H+N/z//5zM+dshJZozXnfl99Uciai2cDl1sF+Zbfv6Ft9fnF6/OGGfh4TZt7w9dFAiEHXUHJ8dxIRXUhvZb+Gf82O7wZ7TQ0RHN0yP5u/23/vil/+Tv3Tw683vXb9L3S5N8308sJp3xv78P66sfaF8vzqhSpFVHv+DIxwbdOw39Me2fh30+ba+Pl9f4oYd1r41Tw3/Oi3Uq9v+Nt8f3i48lpXfuuXiqUnvDVOY0/DeljTAQbnRmtvAWfQtfrnLXxvGwM//3+3xdnZomVofcislV6vY/PuMlveY9E0djWc+Itu/M7+vfFv/q/20/fvvPpJVm1YEO+MFna/Q0VTmmuxEO9ayhf3+faW5aq1gRozPDzfq/69dpSOviv+P7v/C3/vvF3++jVE2ddv2vHQnpdtFzPvqL71BHPsMz4FggZlNG/aye5dsgacvHOz8LrQdAXyA2RFrv0sGDE/yHvvYB/96Pv07V7/u8mSx/8vvovmm26Wl/HZ0ROTfx1S/9933KsbM+7/odmuvO/tH/W//+0n/9J7mzP77xbx/o3/ezFH+d+N/z0ywB/vs/ELSxaS/ArpvR2LLrTvvu6k5cvY+ODlbO5Sjz5xLM7/O+poT46M0/Ioxn4y9/t6yzft/6NcPe+Kv/rlUH/+YHlI4Bvt4QsvrpvbO+3/u58iz4u/33/vttv4XXqyhnMyXvt/F3/mOxnExvdHjYmhjJMP7g6eNEx9VxjD/vZ5NZh3+kqX9GVBHkY6QZNHZM2lkf3QnQFoUl0LPoLEuvFv1bPzbnG0QYAv39mji2cTE78vnOz4edEsb3Pn9xitPU140dHhRmykH/7h9CLRTMHOPF7NpnwjHu2o+mvgZCKdAfxX1PQtVj8g/+XoB/MquH0vPMO/YpVMbCXRj60P4vTqYR5/jY2LcWvv9J+9VQiLr2t94LklYuAdcV242N4jG56aKLwR8flxA/NvV7hVcF81dBTYCFBJzMa0KLmZBIsS2VoH/sBv9rfO/9+dv/+3wDnKmO/v7W9+Ywv9O4MEtzduv6h834UDkx/4G/5fNfOD0VJMKFBPFnC5+Hqll6et49f2jqL1BXB/ktFtYwFXjW4S9u8stQ2W72D9oLFr+U3fWJBfxDRgvQD97+2o9k15j8yd8/5k0ZNYb7dOHC/Fo4TOFZFKEvtfF3/C+n3fWxI0mohPUD+n+JCYYIW+rwx11PSYLLA+iHv+b3xn/n94vrP1rkom0K/Gnh/di242C/BPqDtB3h8fjWi7FxJgaNjtD/X/x57+9f/lBXUSrNAnqSKXxe+GEmxfjq4hNdden1iffgTDhD/y36d/1Tce1049cmvxBaDsD+8RcdItnrnr/Y9xVaqRaagX1e0cH5eXhC/2DtnwUhwP/Q3qMnumDQr+/3AQRvO/Lzzn+pb5OjiR0vEipJ3XX5b0zxDz4/wD79uf/fle9pk19ZW8D4/hr/23/6Hf87P8+zhPHRc8XV4vJozseb+laf8f3Sg70rSgwucL9N/74f0htaY1WPdxChLbawPvpQBf2h5YA7EkKo7wJOFl5h40Ro+N+cXyAx/xf/3vP75d8vrrNrtGFOE9+28P6psGX/vIb46cygq2wL/P3W35UAf5jlyA6UXud84V3/mf5U4J+NzFpiw2jUXd9FJihoGgG9uaD9SCRGV785O0ESvAPQv/NTk7ve5f+n/QPQxzdFQcqedubnXjZgv+/h8R/ja9E347s+mBQp++Z8/bM/NrA+xmyFQzr4/+a37I09TBr90qJ/7irpzAtxfCP2IErQmNz+k78J4OHWNzk5vjrxqxnNUKA+rgftb/ztn/3ik9FKY0itYXzVnefYeMD66qMS9s+w2z59En7HpJGfFv37fMea7Lrnbx//0E80bPQSJ3PG/9/4LjNy0HcuxCef9+uCO86pdEMz5jb67X0+BS6boWFOUi1Fktz9/vR5XygZAyzvIvAPjs/O/EbKEVlo5ySDv8fX8l+b8b3zPxu7pn+CYrAnzf75nj81/SNcK0yUXp31f8cHZCV22ieGynT0Pr9ptW/L9ZApeNOR3/f7RC3MIP4LNZADmRZA39eLqBg29lFfw07QdhPgz0DiBthDwHG0qWp0D8E+fs8/G/yv9t/j+23/FycuESpkWRB/tPCPfT2sO+N755dXZSmB+P82RanQL7rnS2MNVWq5hfhePnkK4/eoc36HZQW7eDKA+P2TnyqTYPxxGYM+fcvv536JY/Q+9W+9n+75CeV98O9eRfLEpJYE1iu783MnFkRmZu9w/7v/t/347d9bpINIkPvQv7wtaNEPjf/41/Tfor8pYR9lzflSi/4T306CWKVKJiDEt7A+b/+JrhDw53SWzdhgXvf8sqn/Se7m4R/4O37/xT/vB/SmfYzHzWs1WF+yzTVJ3aMOvU4qLBZ+s/9a9LfSt5t8d/ENc+shsEdjn771NfvG5Xu+7ilx53z7ucAFfp0OF4zF6wC92LQ7/mII8bGxNY5YS6ReVYP96Pi305ewVXdxcsGSL9uFVzmd+QX5S7A0YQP0f/X/9m9/+y+DSJGkKYxfPxLWR69GP470HxRoUTN+ZGVu6c3czvrr6RKDM+Z15qdbLqvZmz+t9t/+9zAZAH+GP2zObs3+8m4n0qfkdjhiCYumHPSkuC3f7/x7evA6bP/G3/L1i1eD3Ci9AtrXXY1xZj5g/UZyqY+I0m2fJOKmx8Lm/KlFbwjVIHo9s47+/I6/NNbY2Mmm7c/DZn4zLBQCEXuxebrB/kz3xvZjn+pdGbfpTT8Rptp4Cu1fhHPPksmzMz/zDkElfXri+m/6t334pf+eT0TQ/+f7z1s+7+C/a7Om/0/9aXPU4Y/+eOIQS26y/taHvd67+/OTX/FsdPpHHA2YL4N+avX/zk8sxYeu/Db1pfQbOyzwYKKolaCcgF4fRFt23zXfpw4E3TVrAe3/Rf+Wv196qccESU6B/nv+zmzpz/n2ImnT66NKeKHJD8Q/Lfr3+YgjXKIbzmlksGgRw/773M/EXfx3/C3c3fu2bUVuZ/0s4Y5jva+LMxwmTayu5Z31cy4CSYi1TWaf9eXE7vB/1MPYJuEScManfTasos76vuv36ldVHP89vjf+r/HrxbK532VyuY2bo/MLSYQC7twLitVa7sU0TPUHznmy+OqXzTPqnA9/3reJhzUuZp6AxAOLOudzn/eHSxH6D/2kiIJpB//m5zMOM3yvfV22lUWHvxEtSIGl9WH8d/9v/fTb/y/+zZ+yauz3Ly6uvIfFb8eoY/8/79tXyRg/m0snvn6P2vyNlhIJdcah/0/9tz7q5N8Htxo5mufA/H626qgwqkOokqkXmeyiN/7Pp77xEeT3ez9gF6q6TpHPbo18vvO7qPMG//iP8jhsz9/dDciGLmbJP/C3/fwn7o9wVTwWoJ9aOCtXWtXPFmHHv/2c7zjJsYXTXg1BR946/2nwo8ye0WA4D/Nv/txhIcbBtERnNA/F7ff98lAM2vLxzU92S7Yf+6Pkv/U33vYpNbVKnQ+Af+NXTuygvwk7/n2TPwBbPdg/f43/jf+Ozz+ktcSZHnT0Q9jHAj3eQP/0weHN9Nss6OyvFda2sALQP38kvh2wn079i6/+8Y0F1vsIpUP1FNxoCf+6CO+N/Vl4QqVtOejP2wGseeAt/fyb36sH8vfNr+0lHby1vv8H/l7fX3xSQeDs6xv/9q2/MGrir9FYOGq3Csb/yc9g5X57fu/7ObozhfEXB6ViWjTzO+frbqzH+nkO+Kd+37OpD3c/sgNa3Xwxjial4Kn7Rj/p0fUFEWpTH86pt1ZxeN8/85m+1LU97J8W/tt+C8/XPC7w/dqp//GuP0IHerf91vr8H/Rv+f2lP+6s5/lVL2H9fYXlTPMLKbYGFp4To2eMv/WbwgbXp8UOn4ui96d+x0vstC/PBZEZ8qHXbj8eG5YcGOvO/iTBTJ/rSQrj2wvTl6XZPOycz4euPmnqywff8wF2CVSih/hW2OlNjL3MRxcVWZ350XDzpLiXZHK7/yuOkMSte6Dqy4ifC8e35djbc63SeiaMfzThVhyJ/fAf3yeb/Gqf/BfnsLP/R/nP/2Psy5qW5Z0+v8pb7ylThQsqzFkCKCgouOvJlBu474o6Nd99ko5Xmvi/p2qeg+ux7+SXdLo73Z1AAt05zpDNr+/82Cr+Bb4fT70e83/uYG5FlXTYCZ1aIS6lPn+/5Pt9xzd/v6Cf+sQ2Jyy+Tg7pJ93VTTN29Yo/cfZXm19jYDYyp7nLfT9Fj8NdyXK0Tt+ukLERGceMFGT84+WuWam1rZfXO+fK6bjcuerRIqzmy+/lQIs+dVfmJxzf1u+1q7Z89imZvk+NOIxYfud0mWGkhSCrxZ3hXaNad/m2yOgeaXppdpX5BcdH/Pvf1H059Vz/dqep1/TZc1DK9w/760HA4jclLM7ph+vOYLnIQJtrif/Oj4++R+meDKL4/e/xyf4f+fLjyimNzWYzN75H3PiMzLp+KDiUxCnLfoqPQY7/R+w1Z/aAxtdPXXy/pnXrsvXHNOuSlC1VuX2Wqndt5mzp937WwUz5vo3DQtfBriX9Jnn4cTppFwOzb+nzdJTu3n7t7/2c0aBOWCwwk89r499ocRrP0+GS5X+tkWONzc6r/yLdcEFJQ/Nck4yPGf+iL5ufwWOnv8xGvLVIEszvevY6hHn9++uaq1Fv6bD8bRA9n8X7Tfk+TaO/0Ofm7rJdkruVtSfN40r5vlG79tL75mD32ZOSO+j7kTeM8vZn163aXitstkMi7qc8RYp91hdvd+I0k377qx+Hrw96NU3Ti1WWHwbjivG0wsXG+sufSsr3faLFkk5Id+cw/3y/svz2kinfByJ1TQss9+R0yT54Znrt+gkWNDxElWQYDlh+qN2sirmfb/fEd2pvveKdWguH7PRBku2Z/TV1l2XdxsFh66dBcD1WrWqY19/3/pDth+X3u8Uua+qtwCTWPfL1+9ssxfZsbL3MUmW7Fvsz5fJa+b6S52Va1zqdWfuNz60/8fZ3pf3v/CBOkVjX8XFcm58sR6/TqJ10Ziw/gOezdDvb1clo9Sx5tZP6fafGvq3p2pzzd1j3S17RLIQhXTiPT7K7svkZkFYt0eKHsyb7zsTh144ELD91koFeXRhGDPebmKMJk8+rXFscs+WmFVJt/Szp0xvzD8Egdnos/+6zNJwORhN33Qjy9kF31PLM8snZk9NNv411w2vm9f/dX+l9XqTXn7Tj+nEb5Mu/+w8aG39k+12DDkzFfsNxZi+cxYb1/+z4Nmk0t96NvMarp156Dqox3cxNS6/fGL5c8IznR9vX8/jv9zk/2wqZjozWyW59WHufK2HrsfWp9nd/tedSciGGP3FbKws/cMj816CjDbXhZUdJu9bXPN1vNvL8f7+vcWP6uZa8dWLMXWX8HbdmfUw2gSixaUqJP1hU56Z+6DyS+Sgrx+5Ss6Z671OgpEB2Hb9e6mu5+zvj7/nlSaEtG/UXtOQ/n/qztTtl8P1M2+6x/DdXbvZfVhp2I/P5maf2gS1Xn2b+fMSwEJWSzv5WzzppZF+cbqrnz084kzWLpKXUTLKvf3iy9U0On9bThDjLHYuYK1+raI9AKSfrShqT4pHfnyy+n7t38+X0+OyskmnL3MWd94P26KZUUPBp9Az0XX9yiL17jdjOOi408/hKFpX19ZXMYjcs6E3z0izUc+XO+/rc6U1jMY2j6tJ58KujX8S7pePYOZVbef/xfb4wdvPt58q/79+udnn529Na4iVOVmhngX+r9rVtI8rL1/FXz01Sm076mVsaOQ3Hu0XK+aGQWQN5L2+z2JmVTGrpHUfpv2eSOhvcaRo3KKnN9SP337n2xfcFyv4k60xpvUTXaZI/32Efh1FVDw5umpFnw7S03Vwpd0Z+ck6sebbIGtWTNyPnha6cD/neb31axs1R1U9p9/U+5/krVLJu2vNPSezeMzIj2mOT598+ZJGenMrxJnMfHnFpsIsU/jT6dHUyNXdZp6gblrmPo/z5p69/vriHzPW6buyc38ktfz6mEccFFujdc0a6K6fnrN96Hm+zaNNMq+f54fmqN1j8moQs/8uVi/PVDb8Xt+iQvEk2LeTLqWaST9p/TE6Z6xv2m6xrWX78zmO6LpMqZe4yLJyI61RH67x9OMvx65Mu9pNdRtOG7lmF3iZfTqz365X6ncE+I58by1/vo27+fMz3/M2c2Wvn+TTLZneRVfLtb63YSfu1NI7bp56zsmcmUebP8p68k+4rTrP2ZqJRK9uy/CQ3vufkySTWOG2yRnnoH6iZ2Pt8+xs/naWni7nI2pZTH5Bz85OXD1mcsgFZRdk8g+8D0V7vk5ePvd9bRjIrFo4xeT+0mt4ds/w6hzcaT02f6It1HGZ32yXlhavIf52w9UeyWiz/vg+zZ/n/x/Ve5Ur71VTyO34/Gx3vd/n2v+e7j6d6zNwqvTgscCj+p74gJbKKk2KULc/2zTm8SN5+ndMjXaSz2WCVuROiL7W297Hy/IvzeUG8zoLVSztb/eMg73/YeNZLkrjhIQuGkT1xJn1l/PZokzlshse7zL0UaGyvOq5iH283vqaj82cQWdtnrWnt64lyPvA6ysbpJqjtnrVbrTrWd7ri35lFP7b6/HBi6dZsQw17M1D8K01IUk9e4/iQOU5gz0ilt1P0O3prYTL32fwkswmZ0IZdyPsfUo91tpZP3GXs8e8smOMzXefbb/lkkbrZbZz558Cv2mv/fc+Xu+Non2ROuszg+1eUHnuKfGpuctHjibHIorjHFnvBTuHv+37Q2h1kZFOztlqyGyj2NQn0lj5gq5XYGxzsE/n4PWX+7OdJmuziXZflH3Y1sh4zW7G/ARNmqqf+9u9+i6pin47/SRvp9sXP105HWlszK698+9/4NTfk/QW2qt/u+ukn6Th1Yn950hxrWBwo/rPjJtuk6eq1yLA6ZGdX3b4yvmPC/F/x+KlE2njC1sk6pcr8PtBuLz2vtm5UDu7OhQyuaV4/xNulhGRVssrq2Zbpr8fvM8mNb2zHTeLvB+usWVo5hhPSTLGf7aR7Y2z1C8/XquBkthmQvP9g+k2CZH1c1DOvvGTrncVG6f8bX+5xnPmnpjtwooJS7rSrz1dyXJ+2mZ89tMgsrF/5/p1p637W3b6xy+pdzW7Yldk6P36HVu4sNg0nh8wbdmiBNt+pYr/i/LibrbNGRqlt3zY7Vb5n/a2vgnCWtYINzZzXj/62BumQwiHeZnYzMqk2P5F8+/ZRj/eks3LMSLeL5kd/NR0lfnjNh5b0qoMw9jtrXdceS6r4n6WXhmRajEcZvP/LtavIx3vGHbI+x4y/Ss1aW46XKvkZc1pbfTgOR3HLMLWrmZrrvP9y4vLznOzNsJ+1krPVNUlrV1fwi6iV7PiLEC2z4hSc9mubx1NrSSbpvrYIMnj/m474+j6HP2+TQ9JfuSy/pP1a0YxSp5gvL4+jNJlV00Fcv1hs/qSXtaKfwZCy+LZk9tOuPK2nNVl8lPw26rD10aVmBBlZ77WPlbW6yvypnSMzYXFjkDUOG31suvt1nj9anaU+GXm3bkYLaemqTU3F/5B0Fo/J8JUx0/Yr9Yn9OtlK/rNKGm/yeXbOkc73N3Vv+1bkO67y/ZFxcmeupeppzmrTU/R32j6fSTnyZ5kfFuiIflaK/dK0/vbJzNdZ/j4rWhXNIFTJ/yvXdJrea7sxy/+udEPcpqJf+6Rpb71v1T5R8dNm659tZCv5pePHEenVCq24UauRi32avfL6cWxH/ySrLotv9ofSiVOdKPwRp50d013f60fV0VSrWIPZS5HvI4vbqW32d0+r39PqWtzvKuOLzlFX9x2fxuTksyVk+UoV/+KGWZhW/O0uKrvMmzmFwVrJb7QefadH5oGfL5+tH5y6p+T/pKMnb729NVfZd39l/FL8W1KLBnqxZjD/tH7pkbmevhT92FYWkfMl7bJ1RlGzdDLvKv5rXlkf0lL/Wn5+NrPq2CySTd5+qDHi59vvLP61ZyFJ7d1F8V/2fJcMk3L3U4gqdEU1x/Sokv+9bklfT+phKwuYdVWsY4Uq9jUNMj819U/6NOmVyffmUCV+bxIWeCqPz5Wth++ao99jll/qr8TwrE65lc+fvu9XP1h8GwTR0Cs4k6ZJJt3ISgot8xXTVl2balWfre/a86t+LI+6XWV/hK1mA6vvs/W/eP/ycFD21+D8o/bosPlbfqV22gjTbn59ZTPrG5FiwMqt68I1qKUpeDh/52TmZ0/a/a0x/lxOSv/wfiT1+/27OF9h6Ael/e/3Qcv9PRmtg9rYYJnC4u/9AP8lnr8So8D8M+IdkmRvMl3cXnm8eD/3/O4uaGHWHaafgOH9+UUvm3FvuyZpcmum7d5I4f/7ftPGeZFV7WomRvjphnT+yOapqxmZ+D4raRed+9/7iyVl/9B3BnRA6ll/SJI4rZNWq6fsb9Lqq9bVu49t93u++jpn/Yvvz5wnTH+6a4eO8942STZ+WnqpUlfk16p3raZW6Tjd7/u3166yP9VhucWNvIs7ShqbrfE0Zi+Fvw6/iU7fHz7F7/vx2k4p/64/TMcii4DFu+BVjPLyCZ9z0zE3136FbCrXive+jtTvg79v9oGEeyaf7Z0l9dHoouzPspW0a1PmUF+k9wm0Z6m1Ucr9t01iZ/zeVr7n6/ZPpX+3VXUPzuLD2g8bXjWxPBKz9ZWdLch+m75iu9A3n9r7/KmQpOW7k4D4rH3L1KpJaWVmf/vDCRvf6sy/H9EbKvr5fn/81i+Sx3viTcJ6N75R/Rq7TN63LHbaN+tljYlT+d4PcBuw8d/qWYO0Vsw+vs/fekz+B8u7ROakrPAP+bnT2LlMP9V5lpiPraK/7/6hWWiSs5v6p0YwU/YnYX9H25VYfiPez9tE6v4k//6Gc+DPd6Zk0U07p2GgzP9szdYXddftkmuiP8fGc6i0767OLD+btFj/9ll/HovDYpuvP/WBfi4br7hp3bWP6Ux2rP/NvHC0zufwRk+G9kxuhZ18vhez/qudSX8SjYy2sj98OjH/PqaM/95t+zjq12XAv3/eeSVeFr7jRrukd81Pl/m3uWH4pFNqKvr5no+PPndiUd83yGOq2A+8H68N+Pl4cb+ueVXwflEzj1ba76/F83vzyN+vWXrZhwQlP4uDI6E3GkXbItn3BsRvtc3YpEmqb5LUjV/i+8TEOH9e5MUChdHSH4r8gndqNrVozeyjcbnqeqGhjt8uDbW+/tiy9efkVCtGxmTVyfPvUsrsyxgw+Uf7svY065t2Xn9uNrJe5vTF7OfWIP2UfqZK+6Q8ZPlpynJo0k6ONf21WCrtU21qJZbFz6dXnWNlXO47ncX3+3dPN4upNdOm+txn/Yv71aNJ23RaZZZ/H7j/hfv77emNrX8+HSMwaFztKPYd7Fh8K91ZfG+Pb05c7zD/T/VsdUnc3eId28WRvrSC7Wco/JtWmSr47/eV54x/xnjbp/WNwn9ns7V9uvBYflu8fcpl49NU8PD+iNOZMv90aNXYYrdoKM8fvvdrVBj+aPafTz2tKOWe+bQHzstn/FeGO5YHx7PoZpNhWiIZcV9x/VklO1IyGH+X4vUz1pfV6O/8vBdncXMWsPXdYMTwcP/B2+DyGRQyNx0NBsw/mRt9rT25fC7Brm609w3l+UkrXlpLbeEw+70/vEu5fHwr/EXmWKN6P/ms/76v1lLKv/xx/wXns1vLtvL8gawG5tOK1v2XiH/13lbx3027WXtZhy7LD6huUN/ZbCLFP2Udtr54ZCx+Z9vt2ytO1Oc/ZEqd2OlmbH7A+f4wNLts/VAmxfSwyj5xY3ZzeNDpL/PxOwk6tyRrhIV8/H5M3NbELk5Y/G+VH08madeMSffFEuWy6eTx9JPGJXJ8Dcw8/nv/n4Xvj56qsX1cm9RaLZz1v/IPPY+3d9uapxHK+JvGcS9dHfxq7Nytesemr/6U1BrPamQedt3w+/7INjPj+qmnFc1myuwbvu9mnqZK+6621XRr2mD8w/Ohz2XSzT9/cKNWzdPtMfNv/cuilbYdjbVfL9FGas9urP3Blq0/2tX+mczqbiulraGCb/l7V7ObHuO/fD41M1oJWP/7LvXTu+lW/76Pu+sr+ZP4/uAwq+THX6z19Wft0GD+r9F62enAMIy4cV/QN5mc2foxYQu5sbWdxaYdOSw/2ltuLfY2T92yrNenSfqu2zLaNV95vu3pN32oTw4sfxHnv8Oqwv/3+0t8/0Scn51fWX4UmPEsnaX8fhTxfVCdta9dTs1JvWkz/QbjboMlpgsjJtuqedbpmcn3bHmWXn1dmP3tQ2qTrXUqxnTboBc7CJn+Z9uBY4Rbj/Vfqb+6xA181n7/aFGrofNPnEn5fO8H0vj7Hygfr3itHIv3C8MP3GdFX9UKRtx+B6zi5sHGB/e/1Bclhr/NY4NUL/z93VFUa5vPC5O/NzR8v+3PmfyXVvwhLF2riPdDnej1YfPfTusx2VXY+MpL6pPCmfHXuXjMMff496PE+ZS0yNpPgqeesNXRJw7tvtXVbd7+fVGgcbPsKO8H0OvQvRHPZ/NvWA9M781YUuy/3rcbzkwvDElcmzhGY3Cs3+wwzkbpvZUy/bofGttsAi/JLODnNxp1T3l+TENqOLu1u/yev195Sv/f+1tM5l9anbF+tLollb+poa/1+5X5p+/3HXj5ki8iqsbJjL/7nw1+PxHcL1tZKu8vwPkJs/9m8++zGV+iwmXUVJ5/Hm0WP4dzFt/2Nd8lja4f5O2zrjlaUyMBi8+f8oLGdVNTnr+HxzIz72uF5Z/VpnMvl4595fm6PyNm3TwV2Ponu7D1clC5K/YP52ucNWX+cxPWjLI59RX+O4ue1TX3EcN/88+JUk6Dpx3am5iN/7zJKGkeHKX97/eZCLPvrKiXxu/hRyl3+j2rpvslFh+2blg/Of1VvPieT3JuVtx4j61Id9YsflZ3aT31nA3Dz+rETFsPw/ybHyOGn2cZzYL6U+WvyBZtVkL7FnHnLFnKylYj379d1u0GHVVY/hjG83JSGsbK+wfeo6p7mnNi6xNxvyr/ZnSu3O29rbr+fDH7b97nn6S4rkaKfPn5Du2xZOs3YmYk7rSnCp609mzR1fdZ/LZYFhzb1bqC93qmtreCGhv/fRY8kuLyGJnUeyaebrkDJh9yY64kSBke/FNl7sehM+av0jy6sRW774m+twaw/3YnUVY/uEr78P0qu8fzt+28/CgbzYpiP42Bw+Z/gd/RCevz0l7rKPr7hNW91nqy/NLdBY/nu75Syml9ZQ3163FAiTZwqpF2DpX22/6kVrPMmMn3oH+Yf7ubSnnzzbITLRntmP1PQ99orcud/9CfM6qx/OVQmrR9r9frmE7IL9ZPKLMfOF9MPkf+/gMXijZ9RAuaxp2SXvkw+bFk1qpo57pbJ411HPn2uaO8P9Bo9GjomP2PRc7FsM7sWX2/Bc5fO5MRy89X7VPv5IbTzj/4b/H7lZxwePJGDQVPZ2XtaEZDlv+K9yvsqVLeMctaWbsVGf7ufB5sKVFQ2v/m90OmX7PC+A+XkVLeyW763TxsmX+5HINrYl5bSvvhsqdZ1rg3aBP7dmLr79uKv38XZK/UeIdm7EU6HdBdhX/f08r6J680Zvl5mz/0XLPFTByddeushaHbJGnr+E4+WkuRH3yfXI9Xuybx2RQhrYWr+Dc65e8Xz7qsf7hfqqgPFXzztdFZFz5fv31Ie0LLVaUc9j/sdoPLl36uSfa+Ku07pz5d2NPmbkg8Z+EaxN+EC3vZS2eklfpmDPer29fToEvCU/8Zvc+NduiM2umCLEdsfN/vZz0Yf/wjoHpxqTeV8VkPOiP9GX//rzuhfpBQLx8/gubEGmvPE4tf+tvYxM6rrOLF+w/DwZTMKjcndc5Vn2Wkt4iVlQa1uLM0qUvaVVZe8sjBCGaT1o3oo5Wp915h7W9/4zkYklWvbBzNYBzl+3eOtDbX3NVnSS7zcWlcCoex6QRsBpCqXyjE7dteT8wsZfPXOxfc1Ovya5xLy7RMmoaZy39fufJv6/B+KZYftmbTsLuu8n49pS0nJB2XtY/l9qOiL/RHe1HIlyN/OXyOPyy3O4O1R8J6WsqXw/e1gg/P7yYvlp1tTPJh/mlb953Pks3PxuNYG5f6/P1A4T+bkyJbH8aOSadL5n9y4/t+3+xUyo/v3uuXnq9gzPCPKPJ42vgS+yt0P2Xtr0tbI7LGmcL/935vn+GH9ah41KO3Uu7XYjbpipTf/3fwyuOi+WLj+77/n1bY/N+6DxpdVf7Ef+J+pn/oxz639WribWMjX57T/2D6XOiNj2v8W7659nPl5cW1ohe6W9b+oq09k7ZBan/x8cXi2z39aMePHvDzOc1XP80+bHC0nDol0l46zD9+Mjdzas345kwvr4hMNoVqXD+O2fpryfVzWx8rXlY+q/2L+w35/Y9w/9NLbzH85bbupSU6qMTtYGrurdmSxf/FK9HGn+St4L/3w1MWP5v7be35inj/D52UUtLwWbJ5vmh9LeL95+x3dnkypzUrlPL2uXfKRlSePRlef7H1y9Bl+mm3L/Rmd3v9vH2Tfus5S/rHgfFv+8/xlys3+s9yVHsdlPKQudYROdxY/CkMn9VjZbBRxhe9O+Rm+zx+lEr9yrgYNZRytx1agWXtWHzoXI7FY63eVObnd//5wvIjqxYVx9WDptgnnP+wyyvW/7W28EjTH6jzU9wf2GL9w/lUGu/Z+sHaPEPdvfiF+Pt9ogfLL8e266VkFCvns1qfSfVlmjO1vGyTNN03d4V/lzuTBuOqVd6V8uXf/IStv0gw163kWmZLkkanqI314dv5lmvHqdL/9/3MBZtf2L6dvDosVajfjP8HfyjfXDmcX3O2LaW8cSzRk30YsPa/+/c8/348o6L+nLH1S3vEVicka20rpJDGDd92msr5qnb3YH3M+ZGXc/2/hpZyfiuoZKThnC1mf9/vy9SU8z2+cdSf+qXC8p/v96MnkeJ/Crq11rQF/753+/qMtK2mnP/53j/F9/+wfZvuknMy90+FfPtawWxMGtNr9Pd+Ci//5i/1Qb48136uHO4n0YY3pRze79QK2aD5l99MOnn+v+drrrvv/YPlp6+U+5WDttfaW5afzFe7gLT3ayaf3jo5JI8zP3/Avy9nDSYMn5bHn+e7uY1Cpx/pkf423U9MXba+dYoTxh/49+Lgw7/v1og/qVkyirE/vVGTBok6/pQf6u8W+fkdHN/npFfGn5bH+qf8eyLdqPCK2/PQsrRwyOS/2ZthHFV6qn6EfDcs/24fk8KzmPH+D8NXn5S3cSV2+dcBicX7z+l/0li9E3vD7Denn/+wDzif8C/95cr/qT+6LD8fSc3eGfnyLs3ctL0wmf0Et/RMegHz/87Soz5zTfx+0krmnTozfj//PliPSWdo1mLSa7L1QWvE8u+//RFWzjct9M2eje97f8mYycdbkWhCyoFyvo6ke3og3p7vj47Khlfxhur5O55/m8mV9S++j/ti+qWHuvZICg2j/OffuH5z8mm1aYuQYlzKywftzzFKz0OyahVKefvDcnruJ0/9UGb+P1f+vR84Y/ZlLtNLeh9MKuJ8qv1+F+r/ad+582UcX6u6rVOzt1HPv/Hz/2Sz3n3vpzCXmjJ++D6q0xizcutshlmY1RT9hv6O5R+VciE/v6jOQkFS4vlZrv/TJQxOYYWtP5zPnq2/X1WWP3qvrU1Ip8HWz8tT1vJb4z5bf9zTrp26EyYfstLpggxnbP5iORPDs5ssqpPCv8tz9p8rn3wWNGsSfj7HoHExjfYsv2vbJX2qUYPxX/Ci91NL/bb5PR/M87tO0tcCza4xvFaKnrrpn5TzQ9/7nSiTj/h+8StSysPZkN6czGP5/7ni05N/LnX+9DcyWX41dunM6dbV8efs85/ja1w7p8QvsfmZK0/Wn8exbEzY+mtkpEVSHC4qLP6nzH7tKiv/zq+9cj4oup7pghYoG/+rXOicmgW1vL6/s/V/0eXrK9Ptx/Uma9/efLRXoh/jcuxfizrVRkU2/pXjen6we6v3k2VturKXQb39dz9RXYlvXrlptxydulPyKA2crNHRlfsHQtNgeNMonL/7+92jej8Iv/9V72xci2ysYzEpZH3lfhz4Pi6x227xm/9pE+V+najw0WvmorqnxBlGxrM0vCjn2+H9RbJJC2vim89SudhcK/mR0/D1q5Y2GP9w/47DluFK+fFGfKflsfWb5sbNrMP+TZlf/H4R+1IrsPxnsvN9p2Gq8Vt8v8tj/kdPWKofXSxFfjD/nMrVsb73F1BHOV9Mw4t11jssdJOsGRW9gm8o5fD+unYZMP0Zp0KH5TNvFj9oM+uSfo3532abUtO5jVh+tgw+1XHhVlbwcH6etNuM/23sVJ+vZ6KM371+yMgh/Pyaf+m/j1lYZ+VtQiNSOd1Y+4XA3hD/xfzX9/taqTL+7/2FFxa/YP+sceqp58cPRt0ngwXfn+PyC+rneOGkhJxTFq1ZfKhaVKNth8lnR57l8bvxikP7pFOHLA6nWlzfuubduhgMX+vGjazdvin3V4WuSWYkdItNYV9mpurH3e6sPktVWfzZ7zJ34jXL6v244Zo2SH/Dxle6LNy48fLV9cmwo78sv8bzI3JqkHo2UuyjWX9ZutZ7u21xP3XhPVLkD/fnk/eeyfdiDBq+U2yp5//F+jFi+YvYX9wMFf/t7B92SOov5n/E+U23rZyv9gtEu2rzDmv/+31DTV0/nopEc3z+/P/qBrXo3fUV+UB+4wQP5n+c8tXUa/FKuZ+tfdH1OhvhkPmvoV5JXkldWR+0hq7WtW51fr79yj/arGnK/SdBydc806zuvvfHdyoV9X4vhz8YXp53lrhfyz9vlfszvs/X+f0PusXWdx8yVu4P86Zrq6gnnUKRzAblmv66F5T8+au/CZuf7zX/vuV9oKyPOteVNTT9O5sfcL9x8VJQ1w/z0O3QcYHZJ9z/2Lx4yv0D8H670+P+oVA3m77/bijlgf7QqPaoMPsavvRSmS1llfJOmZ9vfVls/cU/Ij5h61klv4f7n2l6KbRZGvGsPvVzRRnfd/95zPc3xfs3B6V9uJ/KtO7MfsC/mH5fGf93f7A+6P69X6Luz9RrDWLY0za3b35+vF50lXI6rtIRmxjMfmv1RffU+NyV9QX8sEmf9W+NUz/1WFar7C895qz96pLZ53I0aBjtoWpfTqVOL/Th8PNT8P7J+qjw/80/96z8UL6WnkVblY9rWFpRPx2Yfd9X48q4TLeKfOD+S01/8fVDq/Y5WrbnmPYtWLfSV4X54u/57oW7Jt1wW00+450X2oXnc5CcJnz9f+LntxvJbvn9fkPKv98t7udjIf5v/Vlh8h0tF+20XvDbC3JtvAg5OWz99H3/ImXzN8uy7sSetEOTzvS1x+YrP//I389xtm6hS7rudh9ly0MztO972iSd2CyI87Vm98TmX+G8O5GwNmgtnCRdN9Jeja3P2/edNrT6JX7/RZhUyqVyvRHS8ZvUU2PC7bO+oIQc3oz/WntiG95i6Iff+ysof743eNIN1ePB8pt/rVvNxfd+wumJxRpbszvESwdTUnuMt0llNWnJ+9P4/Uupq03N5cEdkqAP71PWw5A8Ki/K35cz4u/3Bw0mn/nb94xoMbdNJ4wTL2Grj2JMPwbLJtPDYE36w/Enqd2WoUkeF9pPJ4FbiZuHkT40Zw6Tz8ojTlq/r9uL7/7du8Di0zygJ8ebsvnTDYLCWDNHbfn80izHpDBg/s1JmPxftZrJ/Lfj3my31/WJ+eHz4+nRqlOPWP/3i2Mm5nnims71oJ31uc7yU7tbIAe6DJh/ih8x9T3L9UPHLa+MpHoxi+L9RbvY4c8vKx9Tz2i/caOfOnOl9wLT/ze/u/L7JbpJLSoMN+HNGS+SfuK7jL/v/TBdJp/BZF4rFw7r+s2eBh1DDze70t/9+CbDv9NTP61X6pFJq3XWcS2L33/nC7J6QFZHMzq1V8vIJS/6XLLFapjFufLp49Y0mGLjkNbjbEua19M7Xz6+X29eebJpu/b5nkyTiTHI8u23ouycOYVHsLM7TChkOQ2V8kn3Wn4WHu7V0R47EpHspJYHx8w/tft39+9+J99UyvtJjaUaQ78ZfvMHX+U/IjXrWXy79fB7/n9KlPKqMfEn7it1CzSpxQmZ+SelvF8vNE4s7cnmWrmr3fVqRW3fz66fqDzk95us93RDvPi0y/MXLc06iYoZk1+r/NqSSWlwy5c/bU8fG73UL9glJ6omUdlV2hffn6yOgoHtWPpVL/d3SjnEv5rdDQt0X2L6v+4XSnnAVgOTzrnTce1pg4zS4kgdP30F12cl3rVD2/88t8nrrMq/FgaPZ6167Szs8Mrkf2yo8hfrm2EWmXb25qF+POnny0f6yY6dKc9PzjdaSCfDavHv+2G8vL4rX8fvRTe42QEle7I7u0r7urPoxM3QbYbf+1MrRCk3dkbPsI0pa78XpIP0NXAH+fHNdsdb8h6OI9N5lfSavlq423z5wlkMUm/pdHaOXmQLzer9NFL0y+9/+9A3K39uH7p+WqSHfHnWzygzWVZOKmZSSj6F7SI/vmGWaM8svHV29slJ12n8OPXy/A/mvue3J22GT1jHaT2ZbPPl9oc4xC/NOgMSjF5zMtgXnsr8MQrHmL6WTfd7/31RnX/bZur5tFisu+SoJyv9XMqU8u/3w2ftkBR2+j05HzPFPratwiBrflZs/bp+di568RIr5eL97oHL4uf70N4m68fkli+/vbNBFlktpt/dmiHX41TBi/2LZBL93b959ZXywSQpjF8k7pj2IUvWyeyW2sr4dzqLX9Gic3N6paSZjO43J4+3FrqplwO/PXB2HrPPaXxr5sub63FWLl8b7QGZ7h/PZBOO9WdOfyJ+b+6dG70n+icxyeSoyLdg2HFwNll+3uwvN2y1t1Pmd3BJB0aDlNssozZihzBXd8qXFxLvkrwLN7Z+LxbImHQ+iyTP330Uvb3POG0P7MYlC9Pama21cuWv/aQ1cSsVuvi+PxRmp3x5ve5Vy5Wy7d3oml9bHc8KSnn5Nr8khdqofXPsTuQnw0OqlIv9/X4jXDjvujZMaq6KN8OdN2ldXt6Obs5dK629Jsr45iSwjuVmhbrOY5VO0+7YUMr32bGSFI9nJv9K2munWmN3zrffMuZ3T2+WWf5S7Ccj/V4y1PHB/u/9xu/vqVGWYdQGSvuR2S+X9eOG31c/YVOpPfeVcrj/Lxq0Wrvv/XYTVb+NgZOVi/s+s79aXy8lx667yJfPFs/PU7OXHZOKSyt9U+Ff3N+y7TH9fYZph5w2CwXfTq6FxKpQsvu+v3ebKOM7lsq1KOvMmXzE/a5PX+GvefNbRnTPwoHTeVinZHLILvny081YTZqx01rYvnY/JNZloeqnvjWOVbfh3Zzy+tVLtXmmlDtaHPjN4oK1P+hoXX24IIr/E/sbZ7flkgZh+eV15yr8296nWi5/dp7rvEudrf6ehqr9kCOTT9T2C9/3N8hgle9fe7kssF+bboE00jhIH4tTovgv+D6MVWXxq1TWt0mtflLmTzFwDuOs4n5qevMR3fXeJFXmj/7Qq+Na2a+HJH1mDmErCaW8sN4+n+XXg42/uHqedXvjj/Pl14Xz0UvpKRzY9Q1LysaD7Sbv/5P986JX7Tfzf41r9E7u9k7hr+I/auNiFF8C/djMAv6+farYr1gfP1l+X8kSU69vicKfeD9+RMMBLTSzkGg3/L44+I/jpJ3Zq0Or4Jy0uEM2b1P1H4HbngRn/n74pJj4ySQ71vP+j6Z+99SqFZl/iCbJLWkMfCW+F1f9p17USWjas9Yz08/DncJ/eWpM4uZgENzI9UaWqbkiiv6e51vfb+lO26R+X68l5qmwzpczLPHpaeEXSKX4PCe0kynyS9niK6kZQTMkr1faSPX6ROn/5j9rT2P0cXfk2c+iNB3dlPHPzYI78fU6G99zG5XZjzDOl2uW2z7ZjUk4ICwJbpGZl26U+RsYHb+RzQL361+GvjK/iy/TnzRStsBx5o/kmTxKJ4U/3XC9OHjOWy4NXs93Mu+SIN9/Y7iYEbZ4bA2ou2H5W7++c/P4jTkIjYa+Z/7vMU1bZLu9NfPl7jBzJu1Khc1v8X3MwUAZ32QY+pP25cDWG5NDGqbvplp+MjNqtK5nzyXveVZI6fvWVuQ7dxspqayZ/6KFJ1vBNAdRvvyYJrVjxasx/o4VvZFMYvz+JtgH3H/pVpl/OuyzQ/oyCx1l/m686lgfHsiALo/pnDl5V+HPK0RV3awtaOg0LT1JZh8jVtYHfmBEWWXkudR8sCTlOUwVvPj+oqO1QmfrPRdJ0J4o/PtT104bhbl3s4ertJXaLJXPl1utRI+KJcsf2M0PmaedldPLz/9OaX55vjbTIKT7onnSN9mhnJ9f5VLNSiq+z+yz6a+faWjM63n87LajWT1q+Kath71eOnt3Nnn8ouXox89rVQ/t93l8S6t0pvTfdK5s/KlZCMwmYdq4TS+FfPl//5//8V//vShXksW8bNVWtXnJssq16rJaNWYFq1BbVq1k8b+MQqlqBP/9P//rf//3enZbsx//3xjW/P19XnHIYHO8l0vkep29+T8/7zv+r+x/9mq/l/+8OB3vq+OdFxH80LA4CZryP/imW4528B9BveJkJ+LrWJTDQ/nkBw+0i+U+/+PxPzaReBvpHeLTHxrxwD/NVH7t9Kd/KIedrBbSUB9O4tpIi0ZgPIbEi0ZMOVKBzyTtxioeaOqreEG3f/AdKMf+RXucpq6Ewi8KRUOJF5obyvo5PLQn6jvID8ijh3hodcz/1FHfXex/IfEN6B/kP0M8gOZQjuOHTkCptPCDB3kufvDQnpf+4IHfm8R7iE8Qn0naw/7hZLHHi4QRObLchvFuEA/8Qc/+D95P1f59aA8q7SXehvr8ief3uhKgt0BDefqDT2X9HP4s6+fxwC/ae5ND7RP/uUM8iOrK/7RQftB+wP/Ytx88VLohHsZzgfo4fmg/gPoDxEN7IK8H4s2/XyRE/BN+pX9I8TfgtRwof//godEwU/Ft3p4T/+BBf0WJd2A+faA+jv8taQftV/ADlSo/+DL/0/nBQ6TM8S/wIH8D8US210H+M0mLSe3IEkG/EA9D1/ifCPFwslyMHP1PBPxweX1vFpF4ClYe/+I57RIV77qyPuBdPn7hBBAvyuFL3y7KP04lvvGDb8j6Ag/1hRNB+Qt+YFIRxEN9mNq9HzzQ7ukHz2nhRAWemzKFQfcRD6bfAPtC/ws7Q64h6yNe3ETUyFQ8tEd3Kh7aox3EF2R7EZH4tqRdU+KhPREppz94qDqQeFEOO20Ux9+QeNqVeLAPCv48Zz9gTzCfcvMnAv0B8qPixfwbSPsX+hHzB+OpCEpQqSTxNugX/NcA+z/yPxCUcv4P/Fsd2h9IfB0GCVVbKD8oH3JoHf0PVAI8Gal4QQ9x/oLQhuA/cf5BKKwDvzh/hNRdbBTwdUnXdz94TtMx9s/bozMiBRTKctjprKP/HUL9DOsjHuLnGPsH/kYwHpw/4LrqYC8r5N+QdC5/EPlE/Fdf4MeAB3uMsH/AQ09jtH9ob8LxYqbn8ND/GvsHf5RIoQk8xNcJL2+g/U04vsHlTTH+NXxJd1MVLyblQMW7PN7l/J/AU9mfwEN7U+ga5880/aPpEfHQ3umnf4GHcrRfKAeaYv7bAHuA+DnD/mE+iKQI+59JfdDbDx7i9zxW8ZMf/QG+8SN/QQs88n+XdAP9D7QPtEiacvhM9ifw0D5YXk7/C2nPFP2XB/EA4uUIxw/xDVbqXqziRVJX/MFPZf0cfgn10X8v+Hg80Ncc8b5sL8DxAz/L7K9+Dm+DvZclXowH/BnOP5FkQj7YwPgLk0LEE5Q/JK0U8qGc/gHUT4kSfwDvgb47P3jQ3wrzJ2h/lar9Az8QmWlV4qFc0HOc/6A1oSSUP8X5h/mjSLXB9U6xf6DBdTbQ/4jQDfLvSzyEYkGvsP8e0mi/sL6A9QRF/y3yS5DfEvuH/BqcSj7/BXsA/k3Eg3zA3pcof/AHEA8bGL8gPxWLIoz/kE+Km3za2D/YHwzKQ/7BaTpgL+g/xSIJ9Jng/AF9zsBekX+xswnzTZP4OtLCqAEPqgMhecj/EucPjr+O64ec/NuS9tB+WoAHfms4fmAK5k+C+IKk62i/kaRF+ijwpqRTlJ8u6Zz8YXw+2MtF4kWSBuUpzl/wjwmnfcSDUn1cxOLSW9jzGuW3lf37ufiTSTzaP/hnGwawRv1dJJ3T3wj7x/zJQ3qN/BckneNfLCqhHPUH7dsQT9ZovxVJu6g/sC9xE27Of4L9dH7wYE+J7O+LB3u8qf07fD7ZkH+j/r/jATzGP/DPQNuY/4M9UND3BuXXk7TI1B3Jn3+S9QEP4xHj36D8dEn7KH+wD/8m6ws82KOjyv+rT1n/2z+Mh893G9cP8EvcxAZGI/BE0rnxp5K2Mf/wJ7K9HL6B+Fz/seQf959gfILeSPkLfoD2MX+FQftgWrn9H7A/UPUW89+BpP2c/43/aBv9F6Tagt5J/kX7QFO0nx3HN0He6P+bIE/oby/1b3cl3fR/8CCv8Q8e6D1R8fCmRxPj956PB27ytnH+i/aAPmD/MFUPUH/xgwd5zxAP9jf/6R/4gSSxifrbQ33wF7h/1QR5Qmg/ov6WkhaaBvyR89dyZf0cXmSmqYqHJ4Ut9wcP8t9KvGgP6DPyv5Z0C/NneDLYmqj9CzwM/Yz9Q/kZ+MP88ZhKPObP4ErEptQF/b/Yj4P6OH8g9LTAqlLEg38DfVyQf/gJT1pbaP8XaA/khftPLdAH7BddYxUPQTggKl5sij1/8A/Zn8DDL3jTooXjB0sIQP7o/0V7H1k/h7/K+gJ/hfkM8rpj/0DDJN1i/0/ZXoDx6x7/yU/IW/QP87ekyt8uSnkGCxUPtG384CHe3FMVD0IJ0P+K9kBemD+3cP/2gXgof0D7qL97JvGYfwh+TNmfwEM+9gR9ofyfMfl7PID5UwD2APEii1V8lv7Vz+O5vTuOihd0hvzrsv8Q5Q8PhkQSifEH+BP06wcPdIjzF/iDLyHl+hf8gJG8pP4dinicP/BmYMjl5wSIB3sAJZ0QD/ED3kRsxSq+BfxtVPx3UzZV8eCPQtQftCf69xB/k/RHyl/wB3Ro/OANyS+R/DmQv5zRfwAnYM8B+n8QEtD59Y8p6Q/mL09JiyctIv+UdH79y3/Y0H9u/wP6L0C8RP7xoYaD+29tzpUD8VAkZTD+nqTb6H8LEH8gf+j/4CHeHn7wEP/aExUPtJPD8/YdiFclxEN7pfivP4Evclpsqo9/8BNZn2B8FXic/yXoH/SN8a8N9gDxqoT2N+O/YP60Cz94Lk/H/cFDe+VUxcMiLED5QzncdJbHGxJv4PhXku64Kh5oB58fifkM9AvHD/K7QbxB+xf5DCzC8flFE/wnhIYdzn9QugH+C/0/BFnIJxycf1Au6BvKD+I52E8H568B4wX/gfuncDLOgaaLP/gKjHeh4sVDjcMPHuJ5BecvtAeTqo14KO+Av8D1W2cg8dVfPPSfs7/sj3Ywf4OTdbCo5ieT/vAQOmuAR/9fhfrgr9MfPNAiKCFePNQxfvCm7I9geyA5E/uH+AxBKkL9AX9AO9kPHkw1Z3+pbC9nf2Ym8dg/nDwRD4FMtH/IJyzob/KDh/lf/sEDbREVL/hH/wPl8BDAQfsVD5Ug/muIFw+leNVo94MH+0P/K8YDQzclXuSzFSjH/BmSFqBz8QfyY3ETeyVT8ZA/d7B/kU9D/7h+hfzUAdbQ/myYzxCEI/Q/UA50zn4jQ47HwvkDotChHPdvdWF1LDY7uopn/yYejih40Z5LJR5on6ry+9o3x6cS//1whKvkT3o+n4r/8MCfzWkNxw9RDvJhH+fPVsazXP7pY/6J6z8Rn3Yy3nyfcsL4YDyu7F9sywCN+Rshks7xb0n7/coLxpMSiUf+wWggH8+tH98yH3Hw+aXIR4DOUH8tSYfov54yH/x+uUeWfx8i4/wHEMSznP+A+ST8R27/BYrFzh7iYdIVpL/9+k+gYf5i/uuB/up8/Ln8BexD5OMDaT+Q1ATf+fQnP7EegvzlivHnivRE4sX6hp894h+w+sOD/wR694OnYI8LiYd8EOavg/un4pfP+Snj+OEf7ZjjU4kXwwNRNyX/Qp5gKjba/xPpm8TXxKqMKvIXN+OGvL0a+k9Yzwt+MokHJ9f+7o/K/qFSh9MVxAunA/wbEm/B+EG1Ec6/iaRdnP+Qirk4X0T+Bls1QPckvg35iPAescSLR+d8/Py7VAqe0zY+PxD5aZ+3h/oX+qSZ+zdewX/8J78c/8K+QX4ofzE/gX8ay/5JLGmc/yK/A/07OH6YjxCEKNovrK8EjfpvIf8U9Q/5iQPjR3xF4nPzR+T3I+AX5QcjhflE0f6Ff+F4G59fi/UtjIciHtqvczq3/inI+ZOzHwLyGPzgYT+Nxqr8BD9AjxB/4vQY5J9J+bekPCnOH9CPoMeIB3qqyl/oowH1d4iHcqBniDc5PVftV9gH8ENx/jtIzyVe2GdP1Z+wp0b8wz/Op1z/wM8Q+Ed8zOl6qspP2OPtR37AT4PTHvLvIV2QeNEe4LuIL0j5NbD/tsTn5Af+gIK+Ojh+V8rDk/oX7QNNfYkH+Qh6gfidpBvIfw/x6L+gXNBLxKeSrqP9jBGP/hP282D/jqxw/kGoSzjty/7F/h7QEdo/4CnoL5F4G8a/ATz2v5a0jfrzOT82zOfDD37H6Was4ptcXjbKr8n5scHejoiPJd1C+e0kbe9+8EDvEQ/8nKE+6h/KW8A/+g/gzwb9XyUe9oPJjdOB5F/sLwPdRPkd5P6zqP99fsnbe3I6RP4fknYwfgScPwfk8fnBF6D/7AfPaSf+wUN7b4kX5UVOt3H80F4b8Oh/28APyL/8gy/99P+U7Tk4/6HcAflnyD/4H4PTHdR/Vdqjg/bbSaU9ptg/6MPkdPSD70B/hop3+HzPrR8EXgM8yh/ajzK1f+CHAr869s/LKeS7MfZfAzr96R/aM2X9HJ7K+iL/g/yuy/tzUf4xx7vcHinGX5frg4K/65EfPOfH3f3guT5o6wcPdPen/x7g0f+L9oDfEPEDSffl+Cnks/1U7V/gYfzBD74t6+fwYvymxAM/dSLHK/C8fQr+eID9NyUN9b/rP/6nDuuv3P4DrIcvnBxI+xUveQJdR/8D8qnH0t5E/xO0P+S/IWk3VvEutzc6QP1z+6BDOV5hP5q0hzrqH8qBppi/gX+kEA+HOP/AH4/QXwr7Tf/8GR394MeyvuB/AnSs4qG8DvxPJb4O9gTxb5SqeOCnnps/QO9U/92G92Eg/o0xf4L3HyBJq2P8g/3IOp+/Nr5/VAf5QTwayfFTiG8Tzm8D/ec4/aMpxi+Bn6vy++KhPlHxcHcD3SAe7HnL6SnKL5F0bvxj6f9E/Rx+rfo/wc9Uyvu7/ucY8F8U4xfsZwi6ivk/7IfAJoKD+U8I4wH9o/whntATp2fov96SdkIVD/GDHn7w0N4M7feDePQfEA8bYD8YP+2CpMVDRcDfIZ6Qv/oCP8skjfjGTdJzlD/SjcIPHuwn9/wWkhro74Drb4if0+xPXt/nByA/U5VfA+wH4tkc7UfgeX3PVfFA0/cPHugF8g/xc8Hb89B/zCWd7x/4Kcr6eTxvz0P/MUX8SeI9sAeI513EQzwf/OCX6V88oPEPHuL38ge/5Pr2iIoHWtQX9g90RdYX+Fj6bw/jh2gP7AfzH+BP4FeYv4B9rsDf5PI38H8Qvy5ofxNJr9B/XmU+2ED/c5D+J5e/OUTO3wTtP5O0l5t/RM7/9Q/egnwNxw/4BcgL8yfQjwfy91H/ML4X9If4g6Rz9jeU8sj5rw68jwP+A+Of4A/8p5fzv/wPxEOK6xcxH28/8gN9dGD+of+A/MzJVP9lA738wUM8HQIe7U/Iw1DtxwN+IB9LMP6I+QTjx/xhRf7wNuZfIF9B5+wX5Zkb/0LSFPM/kKdNZbwQ+JEcj4/yh/wM9Jfr38X+U8T7knbR/4E9QTyycf8P+BF0gvzDfsqaqPkL6NeH/Q/MH+uh1Mca7Qf0u05V/sfkj6a4/oT4THuyvsDvpf581F8P2uP82Ln87STpIfo/aD8FeWP8FPEc8Dn7J5JOcfw9OX4f57/gB+RfR7wv9bfB/jXZno/+B+wL6Lz9GNIesH9RvuH8+6i/lPzRti3xIE+7ofYv9LPO/uQl8GvENxAfy/GsMxUP9pPrH9oX/KP9+Cn2L/Un5LlJ1fE3gR/QB8YPeyHzwQ3OXyjfQn/o/1pInxEP/QeyvsBf+J8t+Gt8fgOvmsCjATuX/54kvUX/D/GnDetvjD+wHgXaxv0fZyLpDvYP8XSX/uBlPmPj/i28JW/DfNvn95/I9/xGE/0fvHXQhHiO7x82YT6Cv9ij/oaSbqL/38N4drJ+Dg/7aYdYxR8Af/rBg7xx/07QMN+PiJ9Iuonz78DH14Txr37wK5G/Sfwc8eh/gR8/k/wKPG/fTlT927A+OnG6hf4H5AvytHH9D/K0IV6d0h88p1uhigfa3v3ggc6dPwb9nMV+qbS/Mx9PayL7E/tnIH/Ix87Y/x75R/0JPMjr/INfy/o5/AXqY/4M7bdg/mP+K/iB+HtC/UH8v3B5two/eNDf5QcP+e8V+19LuoX+Zyn26yn5npcQ/g9SaXieeEX/W5Z0C/c/bkTyj/lrAPMR4u0F5Qf5z43TgaviA9Df+wcP7d2Jir/L+l88l08wUMcP7dvgL+4ovxf2v/jBL2R9IT8YT1HKW+ANxKP/fBDpf3D/LAB7gHzpkar43Y//AnxwUv2XwJdlfwIP+fMjU/nfQf8Q73D/QvBjyvoCX0Y8xk94aSiA9ZOWi//kjx7h+9tgFMv0r77Ab8EfQf6Fzy988A/wvPGI/EfS//loP/AqTmCq/kc8KoY/T+QfyoFuYv7WkfLLrb9hf1LIE+VPwR9MOD5E+cN6HGgHn183Yknn9j8gHmapjJdi/wT2o3j/Ti7+36Q/zPm/QOJDtF+Ir0Dn/Kfwp8J/Yv42A3mkrhJ/4FVSkKf9RP0DP85P/AD97FNV/sKeQ2mv3+cH0p/h/BP+4Qr1Uf/g3wLoH/OHFtgfxM9nmuOfjx+ev6H/AX2A/hzMv8R4IB6i/7Fhffgiqv5ugAd9Yf4L4xHtPXD8MJ4L4DF/BX8MtIP5F/9Kx5fG8Qt7EP3j/BPjIWr/Ifc/jif1LfoH/byJ6j9hfE0+Hx3Mf4U8LcmvwIN+MmnvX/7Jnz4czH+FPJqSX4GH/f8X2B/6L2GPC2kvgv9Q8p+zH9DHG+rn8pf0L39xcP9Z0J6sL/AwHrCfnPyvsr0c/+FE0m+Uf0PSOf5fknZw/SHG01T7F/J9/4wfXmoNYb7i+g9e9Rbnl9+Y/57lfAzR/7SQxvgD5ysc2P+uy/0ncfQMMo8Q5w/sT8H+lYPPH8X7hEAb+P4GtHfM1P5FPsZpB/PnZkHSBdT/UtK5/A3eR2+DvWL+G7hivhH+fkIufnIa5j+v+N2/gv1omL/4/AD2VwRdwPzhJunc/h3IB+SROz8I58MFjfIX71N+hL+S/YM827D/j/vv8KazoD/IPzB9l/UFHuJJeyDzZSLjkQP+uoj+9y75D3H+gj7aMP9z+bsp6Q/K/yP5b+f2b+B9rIXs77v/IO2niP5vIfkJUX+gT6CdicQLfiBeFdH+IX8o8fpttH+Qr+h/iPMnk/yj/gRd4v23Mf6AfNvgbzD+C36GKv/CHkswfvQfH+wf4x/I14H4gfYn7FPwj/6vIOWZH78v2yui/+gj//n3d/7kkccvpD2VMH7xH9/7M/D9M7CqFowf119glYLG+4e+z8OAf5y/8HwNaIrz34Xxw3zNPf+C8jLgcf7A89w2xAucv7CepeCvyuh/Ib8tZ3/5ssDfeXkH7AWfn0B+aMPzTgPlB+szA/hF+4PyDsgb10+iva3wXyoe8s8O2g/w04llvi3kD/YD66UK9p/I/ju5+AHxFPwdPr9oZZLOrR9h/lagP8x/r7Aeg/fPcP0o2jvJ+nk8jBfttwLyA3vB9R+071zU/gU/VeAf7Rf29zuwf12QeA/27+B5dw3zr4+kO5h/LoEG/5nb/wd7hPVkDf0f6PNJVPnD+kjIP/f8Bd6fhOcdNfTf8CgH6CiXP8PzKph/DxUvQmvpBw905P7gieCf/OHh+S2s90ycf1AOtIvvP68g/3alvIT/BH5AXhbKrytpD+UP8wvmk5N7/gDxrKDK3wZ7rqYq/yc5ntz8F/sRG1k/h4fxt/D5D5R3wP+g/YN9CNpE/wfrVwv0hfEH9Anz38H1a5BJ2kD7hfUg7H+18+8/cv4Xcr6K548TaU8azr+S9CeN9AcP+Ruuf8G+BG3k9fdnjxHGn5nkn+L8gfaditq/uJ9D6D93foH8+QMH7R9e9XS+74uQL/57nxP/E6H+4XykOE+J6094n0O8D6Vh/qdL2kX7J+L9Fd6/hf7/m1/EHCTxsD7Uxfgl/3AzaATjj6X9w/1CDvSno/zg/UMYT4T+V9z8Il5ihxNWYj4hHft/+gPOgI5c2b8H7fs20H94eB9MnN8i6R9eyAfOc+XOfwl8aJP8+2P0y1+al58Db3WKQwqx/YcX72cDXZf9h7A/DPQHn38DPxTG40u8wfFiPA2J7yBNMzl+OD8LdBvfnxfn+1LeXhP7h1dJgBb8ftcf5O88USr7F+U7TrsSL9r3OG1L+YnzSECH6L9EeyeO9yUezlOK85e25N+uCpCP74uTv/OZNxsqSf2D/YM9Oqh/sH+gIzy/I86HFL6XPfz1/33/OuVRW/ZfA5Cg0f5Bv4bNJ03O//KSiOMbuH8k3n+GbVhTyg/uw/q7aVLa30nicfxifsB8oETixXwAf4nrN2EPFPSP9tvltMtpGkq8y+VBwf6G2L/L6RGn69kPntN08oMfcLr3gx8Dnkg8lDc4TXeITyV+gniw7xnUz1S8B/jTDx7aW/zg55Lfv/XnX3u0gHikV4gPJV1H+SWc9nn/tivxHsfb0F+KeNDvGupnKr5JZP0cHsa/+8Fvob60X7IBmvNjo/59oBecPki8aP8E9bMfPPSP81eMZyf5FXgi22th/+D0Wry/XPwQl3KJo/ISD6+iifvsWth/SdK5+wsD6B/k/8D+M04/OR1g/zcpDwfHD3hBP3/w0F74gwdayFvg+XgckNcH8Xw+s6Uyr4/6F+0B//EPHugXjh/so8DpNvb/krSN+BDpPfYP9l2C+ig/kK94tQ/1B/oQdOkHX4b4g88Pge6A/8P4Ce0D7WD+6Cyk/XeQf8C3Yb4ZOH6QB/RXw/5NSef0B/oJiaz/9V+cBn1ZKD/w59oPHtqLQP/GDx7aM7H/gsTn9DeQ9kxR/3Wcz2ecf7H0Xz72D+UR789F+4P2BI3+U8yng6wv8FAeg/9C/cWxHH9V4l3g5wp46T8pFfrn/fkq3g2FvkkeT23oL1PxbfF8AfmH8cAhFIzfUC5o7F/Itwv6Q/8J/sQZSH/ztR/eniPtVeAhnnRB/guUP9gvjycU8x8RX1bS3v7yL+7/QV4YP3xsb4v9gz1kMH7Ew/zocH5d1D/4EzuU9b945B/l78j2cvMP/Du0RzH/Eu2N5XhF/1vEkx/8ROrr+/xG0l3k35B0jn+4uT+C94WaqH8uDwr5VE/2TyEfg/VDbv3ahf65PB18/gh4B/bre6mKB9pNbQUP7Tn4/KVjyvVwDt/i+BqsX9D+RHuZ5Ff0z/VH25zu/+CBds0fPKdp+IMPoD7mfzA+kIeL648B128d5gvmL3WuHwr5wgDlB/nZEOpj/iTwfD7S4Q9+KOv/5X+cTv/q/+V/nAZ9Yf4j+IH+h5mKH0F/mH8N0j+aThHvS3qE8oPxjXh79cEPHuQ1RzzoY8npMeIhvxpzfAPtd0z+aFE/h1/L+nk8b6/h/+B9WV+sf4GG+TJF+W0Qj/KfAM39Nd3/4IGeoP6g/SmMF+0Hyhsgf8yfGq7ET5F/8G8zqI/xawb8g7/E+NGA+Qv5xuwHPwd89oMH+T9+8A9Z/+/5gcQj/3OO90D+V8SD/CHeLlB+UL4APPpP4M8DeWH+IsYD/nCB+of8aAn9of0sAA/2V5B4j+uHQr6wIj943r+3+MHDeCs/eKCX2D/4vyXUR/lD+0Dn8Xx8FPKFBPuH8hVvz8P4tYr/aFr7wZtq/2I9Bus3D/MPJ5N0gHiuHxvWkynqTweat+fj/Ek43uf2Zjs/eKDXRMWveXu+/4Pn9m9j/BR0Q9YX61eI5ynUR/lD+z6Xv938wYO/36QqHmg//cHvZH8Cz+3DDuR4BR74WwMe7V+MpyDr5/Dgz7fIfwdozn8T5bfl7TVBfui/fa4Puy/r5/A7zm8z/sH7sn4OD/niDvsH/7vndBP9L5Q3uTxt9N+CH6APP/iD7C+PB/nNfvAD2V++f8DffvCctseIh/GAv93h+EE+R6iP8t9Be3z+2Oi/mzB+WK+epP3ZkH+dAI/+58jxLa4Pe/ODB/qUqfgzb6/l/uD5fLdx/StowJ9x/BAPzlAf7Rfab4G9HH7wR05fiIoHuoX6F/yA/DH+QLkN/vqC9ruTdAv95wX65/K074gHfYD/vmL/4H+vMt7n8EDbzx88+N9r+oPn9QO0f0GDvbwRb0r6hv0/ZT6Ry1+ukrbR/0P79uenf+DnDvtviIf2A7A39P8B6APy7Tvqv8jpB9RH+d25PAIYv/GDB3/9SH/wnA5uP/ib7O+7fyfj8QLtpybpAO3/kf3RtqXiBX1PVTz0n4ufUB6A/9IQz/2Drf+MH/h7Qn2cP2POT0hkvBH5U0HSufwL5ueE/NX/+n+guf4dXD94maRzeGgvk/E6j+ftOe4P3pX1c/hV9tffl3/Yz8V8TfDP7cMBf3/D+CfyWegP8wdYz1EubwfjB+zHUZDnC9fPS0nn1n+ADyey/nf/mrcH64k35v/Qvtj/w/zhlf7Rjv+Dh3iYoPw0Gf9DnL9QHp5+4r8h8W/Eg/2+QX5of5APAS3yJYEfyHzqjfv3EA8/UB/zjw/ww+3JaSP/oD/g5/OLT9X8C/KpNtgf7j9AuQPxsiD9h9OV8SQXPwqcn/ZP/GyDPQJdSFU88BPeVDzQzg9exC/kX9BFOd5v/IB4zu3FGeD4TUl/UP+wHoP1Uxvtvwj+GOwH43eby9+B/YpipuKBbqc/eMgXRz94aG+E/U8kPhc/SjL+OLh+g/YFXUpVPNB1xEP7bfB3mD9AuQN0CeUH69cyjB/z352kbZQf5Fc25Lvl9AfP6Tbqvwz9g7xx/1u0D/w30H6Wkm6bKr5D1P4B74C+G+i/odwAfaP/gHLgx8H4Dc8DBO3h/hW0Z8j5/vUfvLwD/grzF4rtGah/iP+w/upg/xXAg/1g/O/w/MGB/KNKVHwF8IsfPOgb8xfR3lP2J/AH2V4H9V9J/2jnouIdyBfm2Q8e6uP8E+tJ8Fe4fu7A+GE8NbS/m6Q7qL8a2K8v6+fwwL9JVDzkcy1fxUegf+wf6C8+//yW0/D8AfMPaB/o/8BDPmMRFQ90hP0DPwKP8o9g/kK8tlB+RUlHOP+t+E8eTukHD/mMFqt4TTx/VvFAO5j/RaBP8Mca9l+RdITzT7SXyvo5vPUjP8DrMH6c/1AOtIP5WwT2cP6xX03SEepfTyUtsBJPKP9djVW8+O07Cl7QVOKJK8oz/o/h3/ylks7ZP4l52UDWz+FtqB//4cV4BB7nP0152YL/9hE/cf70RzPZf4OXaamqf4Hf8d8tFS9oDfcPAG8TWR/wtsTn1r/kxMuCHzy0twF7yH7wQLex/5Okbcm/sA+go1tOf+7f86BKTv/ifeK/fOdPf/H3eVAu/3Ggf5P/jrF/Q8rfQfl1OM2/+k0o6h/wFH53f/A9VX8CL2jEu4AHffclXrQPdB3tB9qr5+1F4mP+e4j9D3K0lB/EjzrUX0g8xFOgc/FHxKOVrC/6H/OyBtgfzv86b5+CvUyR/4WkG7946D+V/RuQP3Pawfxb7CcRke/+4W0q4iHHFyQe9qdgPyi3/wR4Mue/vfQHD/1nKh7aE/tFgn9T6tNH+Seg/0zqS8RfTtu/+gN8CvhUxftYP4cHfW8lXpTv+O8m2s9a0jSUeJ/T9kTWz+GhvSb230d8LPFNGA/Y6xzxoL8T/93C/o+Stk8qXtCrHzy018p+8FAf9d/i/NmgjzviT5JG/ZEL9m/84IG+ofwNxKP+npyGfD7A+R/A+MGfjbB/rj8b1jNPXL8BHuaDQxwFD7SD+3cCr4v8T9qfLtfPDuof2hd0bv4AP6+f+fOW43dQ/yHwA/osSrzjS7r9gw8zWT+HB/t5/OAfP/ovQXuZKn9o3wF9VhA/kXQ7+8HHsr6QH+D/L1tnttXGroThB+ICBwjDZQ+eZ4IBcxcgmGDABCd0wtOfra/c9au1zsXeK7Vav6pUs6R2c9e0X4n9XzxeDH8c6Gnl/g5+Ch7/OUvwez4+ws/gf9TEF+jzVPhtoPfDv+fyn5NAb7HXqfBVPV+h9y/A51kSfy8+XyH9z4M87aDvXPW/HfwhbzfzR5473e438abPLwme+aZZE4/+2xH/IH871Iu8K/zY6QjPfOc+PsYjf0/6Wwnv/pPTn3yDv+rPN/SRNetvG3zRzL+GP6+a6wffDvbOB028zfdN+uP5tyrhjzzBf3L1H+0Qfzn9ykXWxF8wfut4kwd7d4THv2aMd//Lp05H93cXq1p+Gy98Pk7kB39j981lA8988f0f+695Ij/PuQ/sKH/xHDpaP/erOfUvuv/l/GABP+WvS84P8JdvCZ772IXi77vvX8fqP7mP7AR/zLX/43yyOLbzNpef/dBl0H90/sl5aG93f13z537J+tFC+bcQrfxj9zuBLvT+ZJ/zU86jSvFnf3QZ1t/T+Tv3a+OxnZ/4+rEH9lxq/15Ybxb+rfxh+2HOq/Z1/kE/89vPe0x+zuMt/yh/cb4NnV87/2HYvxit83vbn7H/nen8aOP3H9H+l/uNfBn+/arzl0c//+lIf9yn2PmP7m/sPuKXnR+5/t+cnmj/Y+dRS+fHf7YfPEz2L3uevzuK3776J+Vv68/mSf4gntuJ/ucrx6+E5z4XfzjU+nUeGNV/zhOh7bwJPOeBdv555fFr55nQE+3/OV+380fdH9BPW/89Vv2hn2L/VSj/0B/bfaz2f8Xa+7ex9Gf9QNbM//jTCH/ed/wI/dPPtLT+I6c76v+4D4EutP/qrNx/v+j8jXj+4/Fu+KXvx+28yeI/8/jZ1/k953NfOX/V/cG9vU/S5E98Gi39W375m9XnRbv8s6rlKbV/4H0Go/8qfp6djvh/1fmT7h84Xyszl9fwxLfVA/lP6XSu/D+7s/xZxf5v8XCGvLL/Cfqkft07fsp5KPq6dv+x+L4O8TPV+s8z759+qv5gn1b497X013a6VP3BPydHRcP/R2vPh8rfdr4E/47iz9YT6Fz7D/JT+cfHm/+wniX1Svy53+U+N1f8ch5i8y3Vv/ZEK38RD/TTudZPf2y01m/+wHo66j+5D+2C1/5riP45L1xq/4r+b9CX8i/7oW7b49XiF/v2m/LbffZNoLvyn1fPx/mz5G95PpT81h9DdyU/+RQ6qh+Wj1nPlfIn+Rn5u+r/LivHv6r+3Tmt+pN9BnoIXvonP0FH+uc+2vDSn+nn+7yJt/nod98cb/Stjzf5iY/vq6b/mT9W1n84nn6Y/fN39W/PWr/2X2YP+j/5n823dX6Gv/P5uvJf4hN75u/CM99DIj/762Vivxto+m/tn80e0DeSH/1+h5/OT9Bv967J3+htsn7scTtvys98Fr8R/5Xb41r4B9dHxN/m2zg/i1/u04bWf0X9U7gPAC/78fummvbzR87HOz7e+Nv7YOHfPfWvvF/WQ3+V87f30dh/R++PVX4f0dP+466iHwx47b965AP2u/da/6fTvXmCX/n4CM/++UeW4IO+ejp/tfnQ34nwd04/CH/odMTf8PjLsfCsh/zxIP+jHjzQ/yr+75kv2DPfE/7U6ZX470t+9a8P9C/tRH+cn/Dv1aqJh+6PE3ygC52/M3/RTvjv+Xr6Wj/P+2E9ReH4fub4R50f8uwRfqsEz/l3J8GTv3+meOS/S/Ah3otBgt+dl3v+y+3+IZx3Kv4ye/8s/FvvH2Scn7J/fFL9mLo/Rf7zhDzoW/vv/pH731PVxK/DvwftJh66+NbEGy3/Lc6Fl/3W85ouFo63+aCf50089EDxt165/x4JH54X9B/30v834ZU/9+37aWF8tP/g9/28P/Cs/ovfx72Ef8+i738wH/2v+pfB2ulXrf9G61f/bPhgz+I+wV/4+Aj/Om/q71V4nb8OWk6/yn73Tg+zJh660Pm12YN69qz44fxzY/bQ/Svzoe9H5X/in/PDjfoP8jP4mX7/vgEf4rFQ/zKEP/XyTeunHr+u6vXG+GVz/YanXr2tmvg31qv44zl0of7L5oP+Jf/j/O4X/I8SPPZS/8BzoyP9U1/fw7+Hqn+/qpq2emP8ty7/e9bE35E/swS/8vHCWz37JftVVs/CeMlPPYSO1898f5L1Y/9t+PdI8f8e+I+wf9S/nTqt+mt46NE4wRPv/xL8p/MzPM9/w1/1Z7uq6UL10+Q5aPqf4becHyn/83yEvQ/Fv+/0H/H/6fRQ6+f3yKPd/ann3zs7vwrj4/1HOM/g/kHxT39h9tf5Vf0+e7C/9E89/2D98p8/VU0XLa0f/9nz8RHe1n+a4Im/vwmeevsh/Z35fGP538e8pkvVX+Qxukrw0JH+secYfX+J8Lb/rsJ+O8KvdvRI+9cPfx+y1Pk59ykl9fiv8s9fW0/Yv8t/xshPPfjuePt9OPb8q/rbd3qs+l9wHgAd/f48+EOZNfVfUt//BXnG2r//g3/IZ6Xu3w3Peexniq+a+v9n56E+3vBh/pJ6XQnPffwneMW/zUf96jTxRn+q/vHsE/nl/9wHT7C/7r/tPhda7x9l1FfusyaSn/Nge39J/cO073RL/H/a+dO4cX7M7+EnnN9E99/4j9HaP3Ceu2/fO4r0x/ljwF9H+g/4vp1fRfrn/BN96f0J5me8+ge+h2D0geKf8yGj9f4V/ckg6b95Xt4082c2dv5Z9PsN/G9TNOSnP7d++IfyB/0d/VzUf1g+yDzerX4H/zD+W+m/7/qfqH+ivxngLzr/MHti/5bi/9TzyVj56436hbza/9FfWT/2xf034zztC/276j/x1O8n/hvWVxLP2j9YfBFPE63/kfmIN52/ZUs7/w/5W/of2vllkF/9QzGv4z+y/2h3Hhjyj+z/3fNR5P8fnF+yfu2fR7v38UP8xu+f1PYfRPuHVb2eQvnP/Jl+7kD2ox8+ZP3C498T8sWd9Md6OC87nEf2DzTjlf/+MR/5Puq/Wm5PyW/6OUzq/0FW06XuvyfQD4n8F+5PE9Uv/HlK/lH/yX7G6Bf538zjYSr9089PyJ9R/75yWv5n/sh+YCL/+4B/8L9S729QX42O6ue+9zNT7V/wL/ZvpeKH/sDor4rfY6dH2r8RD5b/XqS/hdNfpb9Lp6P4wT+nrFf3v9THkvObY9WPjtfjqfivwCOvzr/Yz5s/Hsfv34R6kOw/P1kP+UbnT+QHo0/Ef+L0WPJj3yn1XvFDfjP6RetfuD9Nlb+eWM9dU//ox+ho//zV9T9V/fzjdKn7b/JD+acZPwX5+UviP+SjKfw+hBd9IP1VHj+R/2wVP4o/+pmSfv5U+us6Hecf5hs39T/pe/0+Vfx/czqKvxXv4zFe+x/OYyz/nir/tj0fzBT/+BN0qfNb9oMl/eyb9Ic9Ttg/qn6/ef2J7D8ee/4R3vpD6Ij/m89Xfmr9G9d/JP/c9TdT/9hyOup/LB+x/zgS/5XHw0z+15o7Xv235WPy31fxJ54P0Z/yN8+hS+3/LB7Z7xyL/y+nI/7mT/iv9m8TaM4LTsSf+c/gr/z/1ekofqboU/FieJ7voS/FP/NDR/xNHs4D9oT/8PifyX9PKs9f2j9Oyb9Vkr82Wr/i5wj5N03/t3hgv7Sn9T+5PLNtE2/5X+8/mT8fJPrHv86QX/F/WtV0qf2r5TPofcn/6PRU/RP6mOIv2j9ZPvmSxP+Dx2/kPxZPlceb4ZnvOIn/d+Hl/0ajP+2fzR+P3d6GP3J9Rvozf9gm+iP/s3/dV/6297vCIdxM+Xcf+dq7D0bF+FBwwvB5E18Fut9u4GeWzxxvf1Q7z5mzxtv8OfMtHW8fveYjf50E3w30vvyH9eSrMP5O/HnOH/FS/23rGwR84fx3eORfO75gvi0fyRH/TaAnHLKtXP4hNPhWgj8K9CjBM187a+KNPnV8GfSRo/9vwrecbleOn4g+auJtvnPhec5HQgvhp463P+oLnu+x5ougP33/t833WPkeb8fXb38PEZrxu/wnvL4fyfdcjT7U31+7hv+8uf4O8vCRohuXP8e+3zVe+K7GC2/z3SZ45uvKfszHR7Jz2Y/nOf7wQ/iN070swcte4JEvbzXtZ3/f8CH870Lf/+R7wHyEO9f6L/n7kXwvceV4+/uQj+F/34Tn+8G9sN5C/Pu2vqb/F32n5f/ZT4+HYtzE2x8xfnb+4LOnQA8S/CCst1gmeKOFh34N9FD4F+EVvwPw6/+H5yNjQ9m/FK38w0fRC+z1LvutnO4Kv3T/sfHgh9BV0/8K8sHvQI/kP8w3RN5WgifetuK/dron/KPwsn9/7vP9En/s+9G0v+HN/uIPbX8k+7f4Mz/+NJb+fztdKH+M5+4P/xxfwv8z0Kfi/9fpKP7BG91K8Mw3Vv4BP0n8j+cl9hwIjz9vm9+vNXmKOR81zRv42bz5/Vr7KOOr+9vu/MfzYeR/fKS0QP658ufW8+dE+JHTsf8i/8L91fArX39f6++7/KX8F5p6Vurv75k+r1xfhp95/ci38r+V0x/yH/B8ZHYi/3t2Os8kv+xxKPzcaeGtHozIv4p/5CmXzfxbCh+tv2WXgmG89Mf6bL4j4Ze+nq7wB8hTNeOno3gS3uhD52f4r9BhfCn9TbEH/nIs/sTvSaBn8yZ+tvLxER5+ewn+jPGSn+d8hD7CM1+7zUc9hQ/xmdN/zVN8VY+P8PC3P9oe4aHnsj9F5Rx5lf8oKvZH6NV/9Xj/hv79XPY/dbqn/vmHvQ8e8F3huT/D389dfpvvB+9rq37b97nBK/75nrd9vzt3fPnbvt81b3w/+Rv6C/bM1b+1w/ryieVP50//dcF4+Y/hSWrTBE+8Xbj9c+Kfj+K3ZT/m72A/5Q+TB/4L4ZFvAT/lXz7K30H/Uf8wJskG+lL4C6c7ir9FVdP5dYKn3l1mCZ7x6wS/9vGGZz76nSvpj3zEHznoKH4vw3o6Cx8f4W99vOGvhVf9MnnwV9Vf5s/vGS//o5/ijxR05f/XVU3nP4U/dXpZNfH8UYhuluDR19rxRoO/kf6fnO5K/8zfvft/eOrBTdXEfwe/SvDo6034EBT5L1+v4dc+X1f5y9ZT+fgIT79y63h7H+c28O/r/OKR80TuT/84nvd7jL7V+onP2yqJP9/P5ao/bfyrF+hc9vsQrf6B+aDzSvKfOn03b+Lvkvjfs78H22Z/XNfPXqivOf3CvfT3z+me+N+tajo/UP4CT/24qxI84+X/POcj4Ln6nx72p178EH+Th/GbBL/x8YbHftSfB+FbPl9P9rf1YP+zBA99L/1RPx4Cv778/yGspx/0VxTCh3gsqEerqonnj1z0ThN80FfRTvD06yvnb/M/4n/af67AB/8pVH9sPs4PHqsEX9Xja/8NNPrfj/w34PHXn5H/i7/y30/4B30Wqh/9jdNPkp/68cT40yZ+wB8BGiV46sc6S/DwV/6HHqB/5f9+y/mvxZ96sobfOMEHulD9Yv6CfP8s/jx/njflZz0D9HXp+AH2IF+/CH/l8vRV/55XNV3cJHjol1UTz3yDdhM/2Dg/w/NHUqkfr+K/dHqg+mHz3fn4CH+f6I/zkVf0pf77Ff5BH4X23wP095j4H+cB/JGFYYKHtvERHv99TfDmv1r/JsgzxH49xw/xB5LcRnjm38BvkeAXPt7sjz6oN4/SP/vvtzDfQPnjjfnQ16v4Yz/q0a8E/1LV+o7x2G+T4LHnL+mf+X8F/FD+gzzGX/vXIfJvnV+Ef2e9kv/F5+OP9u7w6J96sZX/UM+24OX/70H+Efb7m+Dtj4Cvmnjjv0rwWVN+6Bx7byU/9ezd+536/ingsX+riTf6XfpjfprgaP3291nYP+rv14zwB+rZb/H/Emg+yhvVn9/zup4Vqn+Gp/79mTfxP5L6B34U8mmh/dcIex77eMPz/E+QZyT7I4/hTxI8+5U/6h+One4pf3/MPf7U/4xaTkf+Rz188/ERfoS9nxM89eRj1cQz30j+w/NxMEKZC3/k+Er+R/2sAn7cT/D9Jn/iuaTevan+sx+ogv7Gqp+Xdigbxuv8rMMfdabeaf9g9F/4q37yR3XGnLeo/jJ/2W3ic+rDX/p9+c9f5IG/9q/jO1//P/HvuT4i/Rk+2LMcNvEl9fRf1sT/Q1/yf56Pq4Q/8lAvP91+JfvRf/BrJfhgr1L13+w5dnsZfub6m6h/+gzzTeg/Vb/Hp05r/2x46PZdgoffeROf95yf6R+aP3I2Vv7nOfvp8kL4hdN/xR/78keVIvnNH7D/ZYK/9PGGp35/QV7lvy9h/kkSv5Ol08ofhrc/Yr5p4on/8rqJL9lPHghPP3EAP9mf59Cl8j/ylPeebyI8f5RpIvvzHNryjeGP3P8OhSefs8mYqn4frmq6/JngJ+5vMX7V9D/wE/xF/ceU83vq91fpn/m/cv6p/u9I/J8TPP3Ap/Q38fnGqj/cz03JB9H9G/FPvf2q8yPyh/1RqXUTz/1huUnw9A9fdX7V8fl68r9j5Mff1D9NN04fS3/k86mPj/H4w0kTb/RU8lM/OP+K8KbPyvVtePaDyHsi/VN/2Q+PlD9PfD+dq/5P8SfeZ9HvXwz/m/UneOjyTxNv9KPub6FP6B+j++cw34z8of33FP+z83rJD57960z+y/xT+l/9/tn2w9S7U9Vf6v/pvCk/+8tZ3/mBh97hZb9/Ts9Uv5h/tvg/+JL+50z++9fpmfznDDz1Qv3HDH3eer4wPP3NHvhNgsffDhM88x1UTTzzzeT/fBQL/tH53Wzl9J7wzMcfaYryl+HJX1H+EX0o+6HPffirfu6jn/AXpEqdP89arv+HBG80f3EqwrcD/rOJN/phnvCv6vGGz+aLWp4ir/vP3fNAy/5ZHug8C3/7a9zEZ/1Atx0/s/wW6DPJb/nF7v8cTz6Cf7T+6crl2a+aePQX5a9M94mR/MxP/7WTF1chn9h5lfO3+wHoruNL8jt0dP4PnbPeO8fnK6f74r8M9OD/4QvkWYu/vc/QaZz/Z5vwfBTGl5J/KLrl+AL+Cx8f4SeMXzXxeeXjI/xRoHvCHwlfOX7qdC7/Y36jzxP8ufiBZ/42/FbSH/Phb9/kP9S3i0Afy3/NP8L687n8n/sw6AvHm39AR/XrMtAd5JX9OnPX55Xjc/RzHeiu9H8pfbSa+Jz13CT4m0R/Nz5fvnF8F/w20DPh8Y/vOaW2iYe28ab/yul76f/U6bbwP8CH8YXs11s5/Sj+2G/p4yN8P8hb9Jt4W88ywf9kvfI/6H7VXH8f/tjv2fE2P/IMsiZ+AH/lH+YviLc78Wf+J8aL/2ugh2G+QvE3QB+Mfxf/O6d1f7TDw79K8NC/mni7PxpKfuYbBXw7fv8g4NHXb+G3Pt/I5bf5RmF8R/X/wt4/COM/HM/8dv8V8a/C83HgX8p+48zpT+U/+QPjIzz2KNoJHnu0EnwrsR/0BP5Lx0/Ao++18PjDAeOrJn4c6FL5ayD8kfQ3d3og+b8Gehr0WSp+psiD/Y7Ff+36mGVNvMk/TvDMd5bgz3x8XX/m4ff/ISkcRfUn4EO85llUf5xO8bNVPT7GB/7R/RH62eHlP/Qjc+ZT/D/4fUSeK3+E50Z3fP154f5YKH7ngW6jjz/yv77Vs3m4727iz/H/eRPPfHk3wXd9vOHpJ84VL4av6vmKvq8feYz+ljXx0G3lf9bTXifxF+bPqVffxN/e52K8/GfJ/j34Tz50vN1nUo+X6r/BL7N6fH3/TD7oNO4/mT+fWv5x/szH+X/7KMEH/UXn/136d+p3dP/J/cEZ/bv6Z+7TO/1m/8z9dk49uqia+D27f3f+3Id36F+1f2M+u09fSP8r288tGutHHxY/ij/ud82fp/IfaO5Do/jhPGZi+xXf/9h9OP3Hlc7fOD+w81vlryvu43XebHjWz/mDzn/tfvF3cn56HtbXs/2X9Bf88b/953x3X2fxa/kc/1P+436tz/nxg+OZz/ALxS/ncdDR/R/3Y9yH5eo/7Txhley/v/v5TbT/4TyyE+IlPj/S+wcL13/B/Sbn0ROt387j2H9Jfusv8YdC+Xvi/Wuu9T9zH8H9g+7P7T6K85sX1V/qUZ98L/tZP0U8P/j6uR+zePjm+rP7POiO8s8T6yd/6P0PO49Gf7o/sXowXnm9sPNf7i84r9L7L3YfAj66f9j4fMPo/pbfk+C/Oj/gfsPuMy49/s0/oSP//ebxlC98/QPO/zlvvlD/8zc8v2T9yn/Ud6P/qf4w/8rHG3/Ww33YSOff7Kfs/Eb7D86z6/hz/8WfoDuqn9izw/5H/bf1o9jzSvVv4/moo/pDf2P0m+oH/rUFr/xBPbkm/hZR/gh48q36R+6Tc/pn+Z/5I/fBHeWfn1VN5+q/8YeCeIvOz/GP6yDPWPmX5/h/Lv/lPDFH/0tfv8UX5+dd1e9De3+mk8Xnj5zv5vTLe+KP/peBf1f9n53ncv7x5PxHuk/S+yN2nwTdVfyQD6Cj81+7j0Perfh/E3/hW6saH/k/8WDn6UvlD/yLfNaN9q/MBz2W/jj/Yv934/5r+Q16Er8/X8dzFD9t9YPq/3bvk1WLhv+xP+rS70f7v1PfP95IfuLrkvHa/5JPjD5V/Wt5PrhR/4k/f5/X/rrrX3w/k0f+v3B/Vv0we/A+yEj7hy9uv8j+1IecevXd5S/J/0vk1frxr26Qp9T7lxn6ZD93K/nHTkf5n/cLBuum/xtNPF2L/9DjJ/J/zvOxf6n3x6f0D4/W//j65+a/i0b8WjyzfvV/6Cenn43y71/XX1f4FvyDPqL7H7sPIv/eSv6507H+7Dy9U/dbpn/yAfvFO9efvc+DPXvK/6uslqfQ/SH9QU6+v5X/I8/dqum/3A9B55Xih/ePoCP5Fx4/PeWPRdBPL+TzXPt/6lPOecmd+tdzp3vK/52q9od8q/i5czqKH+Lje9as3y38r9/0X+7zzH+X6p84X7qrmvpDnx38Vftf+ltb/5Xq55vT0fo5D4CO4s/8iXp1q/WTj+6D/F35P/1Vj3jV/rkjfd4LT328h7/q96XT+bXwS89H91r/reePiD/1ETrmv3X6Ou7f63js6PxrSf8b8leu8yPi0+L3h/DPXs+66p+IL/zX/HXXvwf6ayL/jftDT+c3yGf6k/3Mnq1Ef+jnnvVK/kunzV67/ZvzV/6y9bGeiD/x0EVe9U/Ed/7RzJ/5D/eHyH7Xsp/6h678L8Lfy/6qH9c+X34gfOXyK37Mn+7c3wxv61n6eOtf+B4d9W/Pfz9i37fi+z+9KH+F59B5pt+f8fesc/+9VH1+GP5HvOv9EX5fw+93ctW//MjpH4r/O7vPCPjo9zN2fhH46/ylHYQx+ef++7V8z/Zj7J9c/gf2U9h73/E98innFSv5D/gV+H6Cn1v+beLZvz1mCT7Qfemf+fvLJn/kMf6P2n/lTvdXCT7Qhc5PesF/ioHzq/ePAY+88t+f0EF/hfqnPucJ7Nee1D8Mne5vE/zcx0f4srn+HZ71K///ZD2nCX/k4fxjLfzI6UG7iYcuVD/7lewn/TH/etW0n8kDf90/YJ+CfP0s/h3X50D2e5zXdHGR4BfJ+jmPe1418eYPwR6F9j82H/lqLfmppy/wV/54hn/wn0L1d8T3y8iXL7Ifvz/+zfdTZH/ieUD8Ruef7E/ZT7wo/iqnB8rf/B7NaPXvg5BPC/Ldq+Qnf22C/EPZ75X8tfXxEf7Bx8d4xrcSPPn7JMpfAc/+ZyP+j+Iv+zPfkPPCdYKHflD8k1/ewMt+PDf6Xv0X8nP++Sb9Ex9v+Lv6xyfw2O9V/IN9i5dA/9L6X50eyn7MN9x4vER4+pFf4j91eqD8N/LfE0b5d4g96L/e1f++S3+y/y/4H7m+I/zPxH7vPt/wNMETfzo/tvmof1vx5/l7GD+S/d5XNV1UCZ5+YqP1//T5hso/W+Yjf6n+j/CHL4H+Lfyn06N5E2/2WyT4TWL/T88nI/nPb2jwh8LPnf4j/dHP/EH+VYIn/0f1W/Qv6Y/4/l3V/Hbxz3q2CX/8CX/4UyV4xrea+GHLx0f4s8R/iE++nzZS/mL+UfCnUt+fRR77ft6nvv8Cvkq+v8Z6+J5bofuf0ZHyt+Tfczryn49VbY8ofxue/u1j3sRDR/b7kP/p/o38bPn4Q/yvnY74b8GfNv13nOF/4d/6fmBJ/XgP9h4rf1ZOl0UTb/TveRP/kcSv4fl+WGQ/vsdieOm/UP2U/X6QT6gfuX6/Qz/GfK/aP1EfXuk3I/6sn++P6vsf4z72x97afxZOj/T+lK2n5fnK5F96/Eb2e/F6PFD8kp8Gp0285aPfCf7C9NnEU0/HxLvOfwr23+hD9XOnD/Qt/IPTUf1rh1dBCu7/hS9uvZ5H9Zf6Ogj+Wqr/ZD1GV5L/wenI/tgH/jGe/gn+f5V/TJ55U37sYfJr/WPOY+hH/8p+9E//WK/yz1/mC/Ws7Cd4+sV/8wRv56cJPvhjqfPncch/Jf3eX51/9H2+sfKXyXPk4yP8xPKV41nPZ1Xz2/HnPJF4U//J+my+luuv5PyjxXjVn1aQZ4L+Lx0/aTv9ZZXgq3p8jIef+tcJ+qMefZH+me8gq8fvzn/Ao7+bBH/j4w1/JXx0fsR6tgl/5MFfDsSf88hD+Kn/OcxquozOv6kHnDcczZt46EkrwZ/6eMMzH/X+UPyJr6NAT6W/w1U9X/mU4On/jqT/B6enyv/MD12+CH/q9JH0R/92HOip+revVU2Xen9kij3ol05SPPxbCb7l4yP81vkZnn7kBLz6L5MHfav/muL/1LNj6Z9+8pTxsj/PZ/ir6peth/OQ0wR/EuSdRe//BXlm3D/q/In5bb5T2Q/9nGXN9Z/An/j5InzL6TPZ77fTs7sEf9fU34z10z/tCX/k9Ez7372spsvTBA+9P2/ioaftJh66VP82wx4nnm8Mf+r0TPGzn9V0uZ/g9xP+Zx5/EX97nnWz8L6941uaL1vu8P8VtPB93xV0t8Zn80DPA93J9f39QHej8Y7Pw/hJ/P6o090EXzJe/NvQVaBXzp/n+F/WEx55+s4vwmeVjzc8/PEf9X/ZIuAHYfwX3V+wvgJ51s6/YH3bQI/Ff+N0Kf5DaMafJnjoUYKfa3yED/PlmeNL9HEU6HPhT51uCz9zOh838UZH/FnPRaA70j/PO6ynkvzg0fel4/Nl1+NP+rsCz3jZr7Ny+qaJz74H+mzexHdZ/6aJJ39k1wn/VjN/2Hxd7K/83YU/67kVfuPy9GS/707nWv+Zvb8Z+On8NcceD2F8X/r7gf7nbq/d+ecyHBU07Wd47N+rmnjms/HCZxpv/SfPf4of+EfHT1X/++F5Mfbxwlv96os/8vXRV9/5/6N/JB+uHW/92XOgo/6Nfm6A/AvHD+CP/7yI/8Lpgfgz3zDgx9H7m+DvwviN+PMc+lP+8wYefW+d/xA89vwt/munB4of8Cb/JsHjr+sE/x7okezPfCP4K/5H4l8J33J6tErwlfOz9Wu+V8eX2P9foMfS31+ny7njx3OnvyT4LeNXTfyE8VmCz3y84bFfi/HCf3G6vHO8zbdqrt/wh4GeSn+V04XiZ6p8pPxTov9j8qXwXxW/6ybe6JMEDz1dNfHkv7yl/IP88D9T/CL/ItAz8Ue+WYJHnhL6TvxZ336g58LvBZp+upT9Z0G+CfvlW88/hkf/s6qJN/3Pm/g29T/q37fev889f9j80BF/5mu33V6Gp7+2+qn+5d77ianqP/3xjH5R94fTzPtn5U/r76FnUf+sfvxJ8c99WEH+EX/e59zjfUnlL/an41PvtwwPPad/Uv+HfrBH1L/QD+/6Cec/4/4TOupfd/1x0JfqL/2x9cPqX8wfl/if7DeWP8p/0Ece4j/qH8mnth8eyn9biv8o/2SeD/9J/t37HGG9wpfez0Xysx/Ff6L+jfyY02+dq/78cjrOv2E+6kfeFv+x66/j67f1IE87yl/oc+nxYv4f5MvR57nk//R81lb+wZ7tVVN+Ww/zfVP8YY9v+L/k76L/MF8+lP1WTn/T+skn39C/6gf2bQd75+q/sE/eTfhjn4usKf/Y61mu/tPojo83PP1IG3yUf6qazqeS/9TpPdVvuw/m/W3lX/ZD2MPizezHeSD4c/GfIE+V9K/zWh/R+vFvoy/k/4Xroy392f4i2D/vC993/c+Fv3Y6wps+WO9E9p/7+uW/O3us3F/A419mP9kffzT/k/1tvotAt9X/nFfOX+vHvkZH+J7sr/hFP+0qkb/l/hDJT3+4CHRH+W+R1XR+4fhOsE9O/bpM8JdhvZ12gkfeqwTPfJdZgp/X4w1v8xEv6n876A97XYk/81/5+BiP/r8LH+TLidcrt7/NDx2t/5P3iYL+LN9b/mf/zH3Zterf2OmO+n/OBzlPzH+o/vA+C/EW4W0+5JX9jux9tsBf949WH8Nf1MyWwnM+Bd1V/CzDfF3ynfrPLvakX77x/Jf/dLp7l+Dx902Ch76ZJ/iq5md4nnfR/y/hF47/LjzyfIffNsGTr9T/d7H/1vkZnuff4a/8Zetp+XjLP7w/8wda/QPnGbfglb/2/Twl/xB//Jd+82v8/tMqvL+2DC+dSH9h/i7+9tfxPDf6TvpnvrvAv6f6dZfVdGR/w//z8SY/z+/pn3R+do886Ev9Vw/9HwX6Xvzpv38wXvFjePLv1wRPvfqR4O+RX/b7AU3+Uf/Lc5PnQfHPfA+rml+Mx357wiPPvstrePr5FfpS/CBfL9izyGS/oM+C86aV5F873dX6b7Lan208+H7w/4L+47vLX1B/VkGevuzHfNBFJ8FDr+S/G6e72n88gg/xWKh+9ZdO//T1F9Sfnz4+xgf/K4YJnv77MWviofvK38zfD/Yq1H/1187/SfiB0/1Wgg90ofpl+oB+lPzUv6ew/oHi5ynIP0D+mfDBnvmp+1uEX/v4GJ/5+Ah/6OMNT/1Zw1/2W7Oe4E+F9o/MVyya/mv457CegfIfz5kv8v8B+qd+vQhP/XoBL/9/xn5V0/4D2f+5SvDwWzfxzFeo/zOa86sX4b87PVD9egHf+n949qOvst/Y6cj+r+DR30p44pHzplfx/+HrH7ab+CHxcpvgmW+zSvBVc/08H2Iv7f9sPug36f+n08NFgl8k/IkH6tWr6gf9wTX7T52/v5F/qJfK/0Ps99rM/wX16xf8JT/4IfreNPE2368Uj/4U/29BH0PkVf3jecF50S/p/1X4VoInf2v/x3psPtWfgnr6jv6lv/cg3wj9q34OjzyenhI89Kid4OFXJXjWv9X6mX8LXvH77nQUv0P88YuPj/FB/yPJTzwbXv3vaOn+91v4g0D/wX6K/9/IT748TvDHPj7Cb6raX2M89lL9Ha2EF/8jp0eKX+YftZr+b3jy4Yfi98npofT3AX/OD1Q/R0H/JfXwQ/ypzxXjtwl+4+OFL6j3f1YJnvNb9d/MNyZ/Pzie50ZX6n+ov3+zJn/DB3uUql88N/pD/ceF238s+y+qmrb9ju0fxvKfBL9YNf0HugM/nR+wvzD6t/TPfH/By3/+wn/l8bo7vwp46u0/5R/2f//svCTBb3288Lv4nzfx0GPVH+YfVwn/IE/JfvLT7VdSj/6BbyV4/EX1g/xitPJPTnyyHxyrf2M/CF3q/qIT9FuyX7tM8C3O35Q/Wtzf4S+6/+F5ib1akv9c+HmCn/t444/+vwVa+88S/l/I98rfX8AzXvvfycL19y/BW/992sSPw3zldRNv/e+n+l9o+t+J+teHqqZL7f+xT7lM7Hej9cv+B/OaLlX/Jsiz8PER/jbRH3j2k9H+y/DMF+3feH6Y4JmP/Vup82+zB3RL5zfkp1v6d9mf/fWE/YPwnZbns0Pp7z7Q11Wdb3Z4zgPwX53fsh6Tf6n8V3k9ivKH9bP0r9H+D32Q79V/2v7K/Ef2s3jaNu3fYz/5mNT/N+8fovhlP2L7l6j/J58Q71H/uPJ+bKT+wfpRxj8qf9KPIG8l/93z/qcr/yWfW/24l/04z6CfP5D/Id9hkr/IZxPw0fmJ+qFDyU89OMqa8rOeKfEe9Z+nvp4j2Z/6dxDG96U/O0+hXun8Ykg8/Uz4b9weU9Uv+oMp643q753Tf5T/z90fptH+IzyfLpr+gz+V7Fe/Sn786Yfd3zqe/T10qfu/nuivWRMPPZD8+POU9Wr/Sj9W4m/H6l/oD7fIq/x3ILz0Z/lk1sSX7D+Osbfs/+j2KN/lv3dOn4h/z+mB7I9/Ton3P/KfttPqX6w/+ePjd/kX+fE/9Z+TpdM/JD/5/UtVj9/VL+8nSu1fWZ/p46fiH3lO6b/kf5bP4C/70x+X7D+OZX/6v9PE/sSj5b+o/974fEfKH+SX01Ud77v+l/Vw/qn+3+yB/Mfyf/LBUdXU3ybIN6P/Uv5gf1dQf06Fp36duby7/pH5yL8t2W/r+eBM+Wfk9ET2//T+rdT+yeox/daJ6s+H85+pfnAeiDwRf/Rj+pD8Fg9n7u+GP/b4LXX+RnwYfab898vjYSb7EQ/Qkf9bPGPvr+L/4vafiT/xPLtzfzH83ON/T/pbOz2T/g7dnlH+tXyMv54I/+D+NNX5qfkj/vrp+Bn58KOZfy2e0GckP/PNFK/GH39YJfb/4fJM1T9TT6Cj/D+b+3ynwq9cnpnqt8nTd32b/ogH/H1P9qN/OWO88h/5aLpN7A/+2OPN8B++nqn8D/vONs7P8HcuT8T/n9OR/ohP8x/x5z6kZP91pfxj/R947R/pb6FLvf/Q2Ti9r/zz3emZ7M/80Hbfsjt/D8+zPPx7flfLb/ezq0BnvRq/b/4d6Dbjhe9Ar5r4PAv0IsG3oR1v83eb/E2evAr0yvFZ5nQ3wRcaDz4PdGHzCQ+9CfRA+LbPV7j82SjQJfxaji+Y/yjQM+G3gZ4Huj1P8IHOsyY+h980wc/EDzzP28hz6vgy0DnrWQiPPOeMr5r4Tpgv7wsPf+wxFp75rxgv+WfOP186nvuc/C7QS8fb/RD0rfyP/Mj9kY03PPWTeLwRnvr6Hf4uv91PddHfxvFd5K+a8ufo7z7QPdnvFlrjI/zCx0f4cbL+W58vl/55XmQJfuH668t+904Xbcf3wGOPH8LjX4+MV/ywv92n/qr/Y39VBPuXOj+fkE/ZT/Vl/3WYbwA/2W+QOf3q/It5oDc+PsIPwa8SPPZ4S/DMN5T+n6GrhD/zYY934RfOfzRv4kcab/gwf4G9/gjP/B/Ir/W/gGe87DcO8pfY45/jS+z5Geix+FeBnjB+keDh10rwzDdZJfgwX6n8Mw7ylcTDkfBjp6fi/yn8XYJfB/qv8GE9JfcZY/Hn+TTQM/VvrM/wx8Kjz1Pyp/z3xPNnofw3rZzeJHjoWYLPsMe6ic/mSf7n+Vli/4Hn41L8eW70VvGD/veS/Dv3/FvK/u3M6T3JT/7cD/Rc8u853Vb8zoI87b7nW+Fz6s1c+j93Opf952H97cz5gW+H5zn19Nzlz9HPjPHzBB/8Me8m+F5TfsOfI6/85xx8iOdc9Y/nNt83l9/mg26vEnywV54Jn/l8c8lP/RvJ38F/Ax/iOZ8Iv3Va8Wt46Ch+v2m+L0280Rey34fHf/tI/lM5fSj7sX7q5VT6o/4tAt2R/S/AbxL9B/ly7L1YJXgfH+ND/sjnCf6bj6/Pr6uwXw38lX94Dp0PHd8ZO/5yleAD3ZH/YE/D94Vn/dTvK9nvWnj1D5fwJ16vm3ir3xH/a6/nUf02fN/5WfyizwRv81H/OxF+VdN51P8svB+N6n/H6ULy56q/heoH8tw2+9fsJ/UY/lv1jyune+pfWt7/HOr84cTzcZR/93ifcNmsPzP2I9Rz1Q/L55a/1b/TH1o/o/ihv8rpp7ry/y9ev9pR/cT/yJ+/tP6V13Plb/Nv8lFH/Sv5iH44V/9v9sT/r8T/h9eTjvhjD6MfHD+pXH9R//IU6Gv4K355Dp0LTz9k9L7eX3xyfXTWCZ78pf6N/Jqvkvzb9vrRVfyfZzVt483/0OddoJeqP23XZ7T+C+brN/WPPXL6z6X8j/Usqyb/nug72Z/8cefjDd/yfqSj/Ik/dOfOz/IfNPa6yZr466qpf+sHib9n6R99viT1H3+6Yb3q/7CPyXMg/1l7PriW/n65PrrKfxeS/6fkr5z/tfyX+L+pmv6LfbvUK/W/5Pec/uW77H/u+b+r+rcAL3kNL/7Svz1nvo76F5vvzvlZ/pD+tf587XRX/ot9jL/Wj37MH2+Uf5+lP9Vfs8dd03/Nn4mXpfTH/N+zJt7mWyfyZ44X/5LvJxSc1yt/f7Hv6fXYH3r88/4/9IHeX+b3zN/xd8XPgX2PLOB/C8/3vKD1++eMeniLvFH/Rz+GvrV/YH+c0y90FH/k9zudN1j9CPL00Fel+L/z+nGn8xN+j3sX5uup/+P3tFPeX1T+5/e9Of3+qX6/8Md/T9xT/eb3wD3sHeGZj3i9l/8QX/fIK/nvVzWdf3V8j36E/cCPqon/EebrVQmefu0wwbN/+CH/Y76HeT3e8Dxnvlz9d2/j9EOV4JFf8fPD/SHmH+Yv6Edv5b8nzr+v+F9BB3sX2n/0gz0L8vWj66+gn39c1eNjfNB/0UvwPR8f4VdB3r7sZ/MF/RfqP/pLx/8U/67T/U2CD3Sh/s3WA/3T9WfzPwV99OV/K/DoS/m/H/Rb0P8+CU9/sQav/P+EPCGeivME/83Hx/gw36DfxA/Q14XwYf5ikfBHnmfGS39PQf4B+rpM8PTTz9I//fdzVfOr738Djf7Vv9p64P8i+emnXuAn/32Z13Sh+jsI+bC4StYP/pXxmwRf+fgIP/fxhmf+V/grf72G+YfBnwudH9l85J9NluCrWl+7+yOfL9If51kF508b5b+V58Oh9Md51hB7Pjp+GPyroF69Sf4nlyfS3ybIM8R+qwSP/G9VEw89nCd44u9FeOZ7buY/ew49VP57Yz3rhD946tkv4VdOD+T/5GfyeaH+jd+DGZ3r/ox69o6+lL9+VTVdqP4M8Sf2z49av+HJH+sEj79/JPie8zM8z7dZE/8uvM6PhqdOb1cJPtAj5U/yEXSh/Se/789Zf6HfT/H+0ZZ8Lf+33+OH+5LiU/mb+ahfv1W/KtGyH/WY+lvo/G2EP1CvCq2f/c/vQI/UvzDfaOXjIzz15I/6V/Lpb/Sh+Pnj9bDQ+dkIfzrxfF/fv9b5t3eU4I+8Xkb40sdH+D/oX/HD81FSP/vIw3nJh+rfntM95Y8P1o/9df40arn932V/zuMq+LWbePOfvQTPfNU8wQd6LP9hvnHIH6XqL89L6u9W/RP1vAr6HM8TPOedqp/It8Or/6T//x3wI+H/Ik+wZ6n6PV44/S9L8PBbJ/hAl90E33d+hof+F+QZy37MPw7+WKr+joM/lqP/h/9kvOKH58xX6Px4HPRfTn284am/n2H8RPr/nDv/8wSPPH+rJr4F/6MmfoK+df/F85L61ZL+p05P1H98Qs+T9YOnH/gi+cdOR+u/9f49sn8XPP3WrfpH8mu1qv1ld38T5pssmnjmy4y//K9weiz5vyA/+tP+b7L09X+R/q60/izBY++bBA99sGrioSfqn6AH8L8VfuP0ofTH+dnBvB4f4SchX5TfhCce6Rda0t8/r+dR/bX9zMLrreXvvtf/O+HJv/dZs/52fD9WqH/osp+gftwL/+50tP+jv6efj/Z/nMeVnOdo/2X7Mc7vJqq/L1XdjxXa/w8y71+j/ov4OETfsv+a+Yj/qP9qez95IDz16bBq5o/fXr9KnV9ZPJJPWvK/ueI3st/c/SfiH54X+OOB6o/tR7Cf9PcA/3WzfrE/sPr1qPpD/Lx7vdj1f/O6/yt1fkZ8Wf5X/Nnv439Rv6S/e+8HcuUvyyf0W0da/7nTY9WvlvK3+jfWY/Mdaf9J/Twi/yt/sJ+dIv+T6sep17OvWv++01OdP31UNR3570j+rPWbPb8GeaaK/78rrx/qX5HP5Pkq+x07HdV//HOK/XX/OtD+61jyY5/jZP9BPz3deLxa/3fn8x2r/hMf7H+m8l/8A3lKnd+wvzX6RPzbTvelvzvxV//c0/5B/C0f0D9OFb/fVzUd+Q/7k5J8pP3Lbj9a1fra8fd8EMdfsF+J/U6Uf2dOR/H3D/2fNu1n9mS+E9nvxO03lf2Ixyn5V+dH6Mdo9e+2vhP3153/sX9BfvXvxKfR8l+LT/QR+e/hvKaj9U+OvJ6dav0/nJ4pfg+djvbvQ/wXe53J/qKj+Mce4EudH1o9pV4cSP5r1/9M8qOfGfs15f+h9Hkm+VnPWVjvTPo79PgttX9CvrLl+jb5f/t8M/UPxNPszsfb+dva13Om+H/z9U8Vf0fQ5C/FH/nB6FPlv5XT04h/5vqT/1s+eEr4I88e/KT/r+4PMf+l6+Or+D86/5n2P0dOl9q/Wj5tJfx/uj5n6h/Iz6Y/5V9bz6vLa/hP97+p4s/iKV0/89GvHIv/VvZX/iUfEY+l7o/xD6MjfCX/0/pPs9ofo/XPsD/5ek946s8+45W/9uY1XR4n+D0fH+OJl6MEj/zav82IP/Zb4RcnO/yx+e9iN36HJz7a/eDgRdbAHybfX9zJt2p8f9HwWcDnTXw9n/Mn/9n321S/0c+M75np9yvZPMzXCfh8VeOzdqDte3Z3/Rqfs75loPvO3/DQ0febwOfIs07wa+cX4bl/jb6f1wvP25znbIQP89n38/T7I5NvFMYX81UDX8Jv28RnrUCPxR/8kPHCD6DRx8LxNv9poKfCr51/6frP5sgfxs/U/7WDPHk/jL9wfI49F4xfNfH4Yz7vN/HIc5Xgma8zb+I7Yb687XijwV8Lv3S66/5r80NHeFsP8aPzE3t+g7y6PzwXXvbvwh973Ik/9r0PdE/r/w4NvpXgj5r+Y3js0a2a+Bx9HDkee+bY71b24/kMfsLfOl1k4g/dTuRnPatA96X/rq+n6Mv/5E8/xB/9/8R/pX/iqQ9+LP8Lz+37Z3r/MFuF50/En87/Fu4/Uf7qBHyBP32T/IG2/DcQf54Pwnpy8cc/C+R9Fp71rRkv+736+iP7DSrHrx1f3Pn6ewkeeSL9gbf5XsS/5fYYSv57pwv5X2/utPAmz5uvd3f/jf6rJv/hqtZfqfO3YuPyR/oDT/2I7Acee8T1g/xMPu7F31+pdnSER548+X6e1TfiT/XH9IE/FivxZz1VoH9r/VunR9L/O3QYX2ZNvNHbBP/Xx8f4MF+p/AFdYK9/wh85PRb+j9PlvIkviZ+DBN8K9GTexE+q/8O/xN6HjrfnR4n8f4WX/4znTh8Jj/1PrP45/tjiMYxX/pnCn/xz1sTnWaCnVYIP87XbCf7Ix0d4+oGZ442eh/Ft+c987vS+45k/p16fz5v4c/D9BB/0n3eb+OyU8Vo/858HedryP+SDf96T/EEfed/1ZfwH8j/hv8Gf9Y7EP9gjp55/WzXxF4yvmnjmyycJftS0vz2fon/Zz+Y7dX6GD/6cU38WWRMPzfgdPtAd9D0UPsiXU38W8t89aPSv+JsFuoP+FtIf/nDp4yP8JfwWTXyJvOo/OsG+OfX+Uusn/19lTf7M3wn5Ol8mePhfSv+Z40v1X1dhfR3sp/rbkf4j+5HPrrN6fIQ3+98leOb7JvmHrs+O6g/zQ8d49E+9uBb/O6c7sp/Jg/2/K/+Ap/6PZD/y4zLQXelvlNX5M1q/4aGXqwQf6G6UvzSf8mcXf6D+XGn9Tx5PUfwtK9f/RYLvN/kb/qpq6t/w42b+Yn6L5xv5f9/prvKHrSfk8/xR+od+wH8U//j3VaJ/8+dxU/9mD/qpG+EfnI78n/m7C/d3ix/085V8If1/uD9F9e/K6Sj/2N8D4Hv4N463vycAHb0/lNv7YGG+6P6W8xTuQ29kP34ftu/fy6j374vd98/yjfjz9zShv+rvb5Gfv4f1jvX7SfI5dK79ZzvUw/yXj4/w1IOu7G90iOdc9d/qAfR3+U/H60FX8f/M+2wh/grd3/B+ib0Pcet4ex8Euqv45X6Y+7f8w/lzn2z0nfuf3c9Bj3R+wPcM7fd3Wj/6Nfqvfv9H/b/Dfqqfd3PsGdb7xfE98vmBj4/xwZ69uwRP/mwleOa7F575fgT5e+o/eN7DnyV/D/t9Tfhbf8R4xb+th3x5LDz5+8Tl3d0/wZ/xsp+dL/Sb68+Cfsz/z/T9+JL14C/LJh46+vsRzGfnGT9kP34f+9d+r+b4bVXT+ansz/ccoX/r9++cDzygb9VvvmcGXej7NXyfrGj5eFs//csqyNNX/n3Q+YHqdy/kn6Lw8TE+zNcfJ/iNj4/w6EvnD0Y/wl/5a1XV8hRtxzN/0f2/ePhL/6Vo9S+8j2P+eO/2L97s/i+Ml//yPg509P6Tvc/Deee91s/+5Cfyy34PfD+D70dF+uN7TPRrD4o/wwf/68t/fyJPqJeF+rf+1ukn5Y+R9NdO8OhvluCnPj7CPzk/wzN/n/w1F/7I6bX0z3xrxs+b+AH8tf/mudGPwlOfn4M8g0Xkv4EO9it0fjPA/vRjz6smfg1+leAXTfkNf+38DE8/9xLkGSj/P0NvEzzzUY9fqibe5Jf9TR7w6r8GmdOR/pj/ad6Un/vVAfrX+cmE9zGgo/t37p95n3Cg+lGo/p7p/ofvafG9rVfJnzk9VP3ne0LQpX6/PcSe9F8b4R+lP9l/E+jh3MdHePqdt3kT/+bjYzz2uhEemvOMN/F/cjrSP/INVz4+wiPPL9n/RnjZ/xf8yV/qP4Zr4aP84fSwSvDY71eCZ77Nqol/z+rxO3x4PiTeVP9NnorxwjP/e+A3yhL8aSL/yud7U//G9zMP+H6O8senfX8v2F/f7xrb9/cCfiv+n1aPmvy3QR8j4kX1f4T+OX/5neIDPbpL8JmPj/CcZ/yW/zD/H/jL/r+dNn0ZHn889vERnvlGsv9W+D/CE8/0Ax/C0098gFf9/VPV8xVfEvypj4/xrP80wZ+6vLv7/2AP9puV8NTfin5X+v8I+HH7/+CLPR9v+GOfb6T8M6L/pN9R/eX30UYP9f4F91+zeT1+53/2/ZWA1/nJ0L6HZ/4evb+6Cu+T1eMN/xf5gzyl+ofxndMf8t+e0+N1gg/6L0cJnvr7L8H/c36G/xfsO64S/ivvHz9d/yX7v8+kfzQ89po28SbPZ9XEt5xfjA/5oFT9GVs8Yi/1H8g/Z7+m+99z0fr9RZv4go72r/Sf7/b9PPXPVU2Xqt89fv8Pfa/vR5G/ma/U+w/LeU3n+v4E+3ujlzo/o//m97Ol/GfMeRDn+br/LOnHOX+40PsXvF/QCuudqH7wPjp09P65vY/+w8fvzk8DjT9H/L8E+Sf07+o/JgunD3T/Sf3nPDY6vzU8/vSlibfz24N5E3/g/Hb1P8w/wX91fsJ8xv9Q/JdOTzYJftvkz3myzTeR//N+xSH8tX/n/Tx7fy/qP8ZOH0p+zh+OAr+p/OewqulS9X9CPDz5+Bgf5JlUTTx0rP9Tp48UP8x/FOSZSv/MB13q/mZK/Lwk+gP/Fbz0z3PoUucv/D0ZO3/Q378qub85Zrzyz9fK+av+T8k/1Puv4m945N0m+ECX2wS/dX6GZ74T5Ff9OYZGX6qfyFf+Sfi/SX7VH54zX6n6aet5dHkNz/3WKeOVv0+5P0Xfn46f4Q8fifz0E2dZPT7Gj318hP/i4yM8880i/rxPgP10/2HzQZ/If5BvL6vHx3jk1/2H6fPQ9W3548jzaRn9/pfvH6Fv1d+C70lBR39/76d9T6Ueb/g9+BPvOv+cbZ3e1/pPnJ61Ejz1Yy/BQ+9XCd75Gd6e/7djCecV/vcf8Q/oPfG3+5XVuh4v/Ax/LIRfOf5M548lzwN+Jv/NqjDfPMzXcXw2djqHn/C5xkf45aDBH7yt38bv7q/D70ezQK8db/OvEzzzDTVe+Hwe6I34C5853v6eIt+PLbT+UXheZk18UTkdrX8b6Anjtf6R6NMEDz1O8MxXzh3P83bgn7cdX4oeCl8F+puPj/Bl4Jf3xX/l+H60/kDPAt0R/gI6yJMvHd/WfLMEf8X4KsEj7yLB37m8hodeBrqr9V87nUv/zG/0bYK/Y3yW4JP1G37p4w3f9/mkv5Lz8V7gH/9+w3+/kP1wvP0+Abon+Xl/am7x1q3xvcC/yHy9xh9/eCz4e2mOf4AO9ipkf/D5KpEf/JOPj/C9MF8xdjzzF/Mmf+Sx8/OB5F+F59DFPMG3fbzxR5510352n8D5d1f7x3v7nlW/cX/A/URO/R+4/PZ7Zujo9wP79vfM+o3zc+tn6D8H7n9WD6Gn6r++VN4/PjneztPo34eufzvPg47Of+w8lf2vzu/sPPylaNy/7M7Tef9D8cP59ph8+ub653x/t38Rnvo3DPqMzu8n1DP64V+Ot/4WWv2rnQ9Tz2ZaP/ltlpz/5uSPd/xH8Yt/dfC/reyPPNwXqn8y//wZxj9o/4A/cx/TVf94q/uYZ5ef+x07P9f9j/0einjqqv/hfG1A/xP1v7x/vnt/y+3P+diG84Lo/CTz8xO9v8XfU7D9b0v6s3qGP7SUf9HPUaAXLj/na3Z+GZ2f7fl5QrT/tX6u8n7J6i/rOWvWP+snrP+S/mb2PbRQL0vtH3gfnn51pPzB+/h/5S/gX3T/da/zB86D6J+i8xP67zfOv9T/cp7FeVoRvf/C/QfxPFL+4HvK0FH/xPk65/HFg/hzn4j9df9h5/nEfy/aP/L7dfpt3R/b33PZs/2qxy/3K9D9+Py43n9mH7If75dD30bnbwX/Cv6v/oP45PwgqxS/3EceN88fdvUwrL9U/iaejP6n/L10eqj4I/6xX6H6x/nEGHt8qv6cOj1R/SI/QZfq/17ZD4d6HJ1f2/n0AXjlb/zjlvHKX5xHl9TbI+mP8yvObyYuv9l3GvhH59cn1o8PGv5v8cD7WlPF79bpUvr/x3kY8p5o/fjXaaCj8yPkmQZ5ykr9IzTx3Fb/xHr2Aj2T//YK/h57kPdI/P38KtsX/63TY19/zv7u1t6fcTz6NPpA/Tf142vB32v19aMf6Jn8384zK6t/NR59GD2V/gd2/rSu7WX3T9QvzstK5V/ug6tm/rB4btn7cto/IP/c9WXys5/ZvX/l/Dn/OA/yD5ZR/qHJHnC/7/6DPNDnWj/15Zz6rfzD/rYI68nVv1LfjT6X/smn1j+p/7H7WPLpT8Uv/kT/9KDzV87vuH+M4v/R6Sj/TNm/8j7HN8lPf/Et8J/K/zkfaQd8rv49R5/TQH9T/C+cbst/6aeNvnQ8+S1n/3Gh/Df0fNiW/X7a+V2If70/P1x4/bqQ/3A+syB+5X9v9v5ZkH8u/vjjeaAX4k8/BY29d/eP3Iee+njzH95nYP+5UP3jPA46qn/Up07QV+z/ldevS/nfu9evjvYf3AdB51eOp74Z/a76x3n+ZeDfV/9h9/H0r+qf6QeNvpT97um/w/o78h/6mU7I59H7I3mwT34Txl8p/9GfcJ/TUf/1l/eJqP86v+d8Pmf/cq38b++TwU/5y84TeV/v3uWfkD9+uLwWP+SDW/Sl/etd5vRWePop3rdfiv83p6P8QT0bJ/0r8ZHTL0b9+8rjp6v6yX14h/iX/9DP58RzFH/EI/1wN9r/zev4yZ8Ufwunx6p/xMMN8ab1P/v9d76W/+L/7Hej/Ic/3qB/7Z9+c38EXv1vHuxj+r9S/ZnafiLwl/3tPAF/eVH9YT769RvpD/+Aju4P8Cf64f/yu8dP3+krxf/a4z+Kn0P6efJX5D/ch/6w/t3xu/ex1rv17vpH/Cf0E7ns3929zxj8V/yx//dAR/37xu4zAv5d9Rv9ntG/qf9ti5b/PdjvGXy/Y/mf/Ri0+kfL7/R/pezXsvfBQ/zp/dfJ2PdzY/H/4/1clH9fV3X/9V9/4PWPeISW/iy+boM80f0d9Zn4y//I/+h/wN/K/l8tfsN45d898kego/NP8wf62e/y37+u/576l59ZXT+i/gH5TJ6hzh9+ufwT9f/sB7qZ5T+dn3j/NpP92Z/urVYN+dmfdYn/lezfsvOIOl525w/uf1357zH1F/xf5R/yP3TUf2LfO+qX4v9LVts/V//ePfL9xJ36D87zoaP+j/OE3rzZ/1g/xHnYfbR/w5+S+k1/WZ42+Zdjp9X/W368J/8o/y3YvxN/Xxzf4TyH87J75f+J84/2Lxe+n8mnwt+5PSM8811l7N8db/kY/1H/Zf0c+f+b/O/K+8ee+lfeL4KO8i/9bc5+ZCr9HdJP47+qvxOnc+1fyq33Ez/kv+wvfiT7B/rrHvVb+w/2R3lm5x+OP3C6J/tNVk5L/1aPRtZ/uv44v30I/LrqXy+YD/1p/9EO9iiyZv9k/dQq6K8v/2M/wX6q0P2B9aPYYyX+A2j8V/tP6ms/+FOh+Cc+inbT/3fxwP5b+RN7tFP5x07/8Pxn/rVE3/KfC/fHqH5jn6LTzB+WT7BfX/FPP93HXtq/UF+tnj5q/ejzEf6y/xz9B3mLnvB966cb/mP+RD/aV/6in+mDHwi/cXqp/I9//iR/qf7j370wX6H9A/Ft8fxT9v/mdE/6n2K/qml/218fB/pJ+YN+ZoX88l/8CzrX/tnOE7DXreRHngf4qf+kvuM/UfxbPfvp9cL4P3g/3Ff+Yn/SDespdP9Af1awH1lIfp4/hfED+T/91QD/+S7+a++/1uJ/4/RA+Y/6MMB+ur8pN15P1tI/9eiZ82P5H/0I5w+Fzg+72OOyWb9ynt/Y/tnx+BN0of2v1UP6v2fxfw30S1bXW8PTDw7C+OKmiTf6Rfqjfr8k9ZN6Sv9W6P6lu3H6RfJfuj0Gip/LeU0X6h/pL42+FJ75XtG34p/+tIv/6/6F/VGBv2j/Y/0p/dRQ62c/NCRfRv7Xcvp61cRvsnr87vyV+wjsH9WfI4+HjfIP+eXN7b3DV3U+jOv3qeevR8lPPfyJvNI/+WFI/orsz3rYT7xJfuS7t/2r8JnXf/Vf+EexTOo363ma1+vd+c+q9udC/Qv+URBPz8ITj+vU/uBbTf+xeFh7vBie+dbzOl/u7K/8qf0/+2Gzf+T/+McGfsof+EMXfq+Sf+30RvzfPf8Olb/ph6Fznf92Rf9S/do4PVD+O1/V+bjQ/qdNPMFP51/WH/6Cv/I/51tt/F/7b/pZo9+F7zndk//eej4utH8wfUC/SX/446+q2X/Rn+F/EX/mL34n+a8Ff/Sl/oH+tk+8yv+snuJvj5L/0+m++OOfg5XXO8Pjv6n+jQ78Rop/4gF9Fur/WZ/RT5L/i+fDgfpH+mnoYiQ8NPG8Ff6r0z35D/0N/Uyh+KcfzOlXfsv/zpweKf6ppyPV2939w4D9TlN/9Ke/2T+rfvzw/rU4dLzF07nnG+u/6R/+ZM38Qz2EjvoX4svy55+sif/p9bY+fwzywO+r+G+c/hOfX4Z+KqvHx3jG6/yCftj0+SD973k/N1L80w+P0Nep+Le9nv/R/pP+6AN/lf+Qz0bEi/pH+gvrRz6kP/Lfx6qZ/8iPA+RX/0s9L+k3f8b7n4AP8oyj+xvoIG+p/Ed9NFr5z/Ih9XMcnZ/ZeUIz/i0f4O+V9Hfs8ozVP9LfQsf+s/X+4V38yV9/eX9C/oc9oCP/px+3/uev9Df2fDJW/NOfQhfaf1Hfyn6if+yxhb/i7xX7hfWWkf9WTr8KT/15gb/yF/3NOLEf/mH+9E/rz5yO+mf2g2PqVUv+C02+/pT92T9XxFt8/ljTUf82JP7oFz4l/0+nR9H6mY/7C+UP6pPRlfDk/9+rZv599/xfqv8eVk63JP/W6aHWT30Zwk/nt8M7p1uK/1eno/6N/mC8cH/Z3f96/9CS/hdOj5W/sO+Y9Wv/RD9i9IvwT26/ifx/43TU/1k/OEnsz/7py7zpv/gz+iglv9FzH294/LlK4o/+ZCJ7m//def6P/Af5vjBe+ZP+EH+I7bf0/jHK3xvPxxPFL/UUulD/Qz0t8deD+P6lpkfKP7+8H7Dxu/PnQHeb9dP6I/LJRPrbBP1MsN9E/MmH1JsD6e+P57OJ4vd9VdOx/zEf/ein/I/z3EPWq/6L/oJ+otT7V9QDyz+H4k/9PlzV+aa+vw3zMV77l6Hy9xetn/pyWNX+usMjP/HzIP5j198f3X8gz1GQfyr9/3O61P6L/Gj9z5HsR3464v5S/vPb81ep/dOI83Di5bfWf+r1dCr/pZ5OQzyW6p9GzIe/fpX8mde/iD/xMMVfdP5AfTT+Rzq/zd2eU/kv+W1616yfVk85//kq/VPf/jq/+v7G+Wv/P7pz+rf859jtMVX+JZ6gS73/RT9j9Bfh/3r8TJX/qAcmv+LH8hn+8E/4yuebqP/APuiz1P6DftJo1X+rr8eJ/f54PS51f2L5hHj81P0D9j3JmvmT/Gj21/5hhP+zfzgS/31fzzS6PyT+1u7vu/vPQF8k/k89O0nsjz8Qz6X6H/Kp5YMTyU8+Oc3qfLO7f2A+5FX+m+A/9Aun4n/u9FT1m3o46zfz/yRz/Z3Kf+euz7HWTz43/7kQfu76PNb9K/3jMe+PKH7wB+gof9HPmP+cKH6/ev2M/Pcv+RR9q38xf2i5vxj/a4+nifDkR8s/2r9ZPjzwfFnfX8/D9xuDvLLfgfevpfpPy+dHif6xxx74VRM/Q17tP5DP4l/5r1y6/JH/UJ/NftH6kf8msR/5/Yz1y/6sj/VE8o8Vj2fSH/VoD3urfhxUdTyXx5J/6/Se5H9U/pf8R/OajvRv+YD4O5b8+Mce71+oflIPzX/Uf7M+k1/+Y/50Zu/fOv7rql5PzJ943ni+MPyb05H/fmU9rFf7N/KT0fviv3Z6qv7vxNcTyW/xbHit/0PrrxJ8u6l/w+95vjD8H7fHTPmDfDRbJ+vHnvRfp7L/s8sfrf/U/Tm2/9r9MfK/G5dnpvxLfEKX2r+aPqH3JX9LePkf8s1aTf1ZPB14vBn+QPGr9dt6qgRPfGRFePVmvqnxtr9aBfq/HUCNN/0EumC88Hmg86yJ39GOt/kXge46Pms7nVc13ubLMh8f4e8C3RZ+Hui+0Y5va761400e6GGChy5c/qwDDX4p/Nz1MRZ+4XQ5b+KN3kp+5u8Heip85nQp/jZf4J9L//b8KNAz4atAzxP+o4JXBZvyF5rvm/Bbp9sJnvki/nnwhxx7XQi/dDqyXy/QnSzRP/zxh4Xwa6eLleMvwcPvzvEd5FkF+sbxOfr/HuhuluDht0nwrPcuwTNft2rie2G+XPrrir/0l6/dHhGe+dqrpv660qfsZ/JA96T/W6fzI+ErpyP5Wd91sv6l1n8qfOZ0JD/++JDYn/l7q+b68Ufzv3vHF6znseDVVsevoMP4Yu74fuBfoO+XBL8O9GDexA/CfEU7wSPvk/DM9+rjDf8MzfiV45nf6FfhWd8b8oo/8g3hL/81efDHX8Jjv23B+/aOf4dmfOX4IfpA/1WC/8v4qokfI/9Rgm/5eLu/QX//GC985XSEt/kC/+j7K+CNHkt/fwJ+kjXlZz0l8ftF8h85PZH/8f75hPXr/duevb8exh/I/3i/096XryL7Z2Hrhf0d3+f9H+z1NfKffk1PnX/B+5CvvO8s/+f7MmWIl+j7O3yPJzsBv2risUep/M33pEv0oe8nZLz/yvt+M9l/7HQp/Vk84L97kh997ru/Gh7/nqFvyT8L+HawV57L/qdOR/h9x7f7CT7QeSb+c8fPpf+101H8nIf52yHectXv9tzXc+74nPr7LWvyN3ywX95v4nPqxfm8iZ+zfvmvzRfiMVf9bq9cnm/i33e6vU7wwf65+hfTB/NduP7sOXRb+fti7vKrfrdDPOazhP9E/JdNfCfz8RH+PNCLrIm/COvvKP9dhPk6yKv62z51OuLP/Jdhvs4iwcN/keCpdwv3/5z6v0j0d4k8IX7zpeM7iseJ8FdOd1I89vrexOfUy8uqib/C/sJDd0I85qp/nY3LM5T/fHe6s03wVTN/ML/Np/yR30t/sv818x019dfBftTPZYKH7rabeOj8R4Knf7vW+nm+DPJ21T9fQxMvz8Ijz6OPj/A3yDtP8GG+fC285rt0/RW8/34Txkffj+P7ZAPeV1b95Pt0Rt+I/wZ5WK/s9x199F1eu//GH34l8oP/HvTR3ST4YL/8PcFTv2+lf+a7hb/yx/dVTecfwm98vrsED91tJXji5afwfZ9vKfv9FV7+dxfk6TH+0/E9/KGV8P/r6+/1E/zCx0d45ruX//P8PsjbU/98n9V0fiT83OmIf8vn660TPPGi+t3LHH+r+kc9Lyqvl7v+0elD4dE/9fdB/I/FX/r/sappGx/hqT8/5k38D9dXjK98/O7+OtD7CX7P5ekr/h9WNV3kTXxBvXiomvhVmK8v+5k8p0390c8VWXP92W/6wYQ//SXyR/2f9WfYa6X6vXU6wq+Yb9yUf0D/cpv0f8TnVVbn+13/Mnda/m/9+ZuPN/yb989R/qUe0P/l2r+ZPbDno+x/6nSp/Gn+QP46U/zh/+wXvst+754PovihH6L/sn7D6h/1p+P11vDk4wXrVf/1yO8vqHfiTz7M8Lcb6Z98MMb+yr/0k0bLf9FHAf8rxQ/xMcNe8t++6q/k7+KP3WT9K68nffUf6KMP/p/wlefPn9L/1um+7I8+2vj7QPUj6L8YJvWLfuYn61f+Rj/037H97jx/PQr/6nR32cRb/Ef5c+zrifDo52dV96u7/rOq9VeMpP+W6++n/P/M6Uj/9PP9lY8XPn9p6s/wj0n/j3376yb/juio/7lxfF/51+y5afI3e4xc34anP6Wf7iv+8A/8oVD/bfnV8qX8F3qKvoW3fuCuiWd/VLSbePNn05/k/+T3e0Efpf5+gX1Pbve9zxpv33OD7kt/fF+0Tz2X/9r3RPke1ZP2b/S/a/yXn1KBfwryDfDXufoX9sP86Y51il81+YPv4y/nCZ7zOslvz9fwU/5dz2t89P065DH6OWvioQfq/2w94ae9Jq/hiX/6/0c+lYH9iA/yeT/a/yMP/qz9O/v5An95lvz038+M1/7veVXThfL3YOn0y6qJhx4sEvzC+UX4qfMzvM0H/8j+c+ev86fB2umXBP+K/o4SPPGi/ceAeKJffhWe55N5U35bz2lTf0O+x0u+3Uh/fE/l3b4f63i+LzrE/171+y++P0o9/aPvL/B9rU2QZ6j6xfc57fuVOv8ahnpSPCf86e9fwvqHkv8NetnUn+HvfXyEf6vq8TF+J7/WP+R9lVV4PyNaf6DRVytaf8BvfXyEf/PxEd74K/+8hvmH2OtW+OAfBf3Su/DUr1/gVb/ekZ94fU/w2O993sQb/yzB4z/aP9h8nJdtpb8Pp0fqX96rmi7+JfhPlzfGh/WMFP88h470N8J+XxL+9IO/wcv+v5GH/H2U4KtEf+D/MH7ZxNv61b8zf3Fg/uv4L06PVP9/O12cJPjTRH7Ds17Fv+kTe6n/te8B83vLP8Lz+7/f2E+/H+f7wKNVIj/5nH79Q/o/c3qk+vUxr/VRZk280ZtVE/9n3tQfeOK50P5jFOxf5on+2I98hPnGin/kgS7LBE/9rRJ8xXj1n8w/xv+OHT8O+i8L52f1l/r9N+H/l/Vg/6cET7/1L2viocfLJn449vGGR5/0E/9U/7tOj+U/Js/W5Y3w9J+fWRMPPVb+qISX/sYtr9+q/yXnb59J/f+0/u8/1yoHTbzR0fon6h9WRQM/Dv5Xqv7xvOBPlWn9Rd/7kah/+Wf9dOCv88Nx8E+j/6l//eL1rJT9W/793ELnV3wf2db/qfVn9j2sza7e1PVvFX6/lNRvvmdFPYvq957Hw1D5y/zhrrl+q+fcX71p/a9ez+L8y3ytJH6Xns+qOP96/Kv+WD1ueb43PN+jzDzfGZ58gvxj8ed70OOjxH/5/hn0porkz2r5o/oL/4WvF/wkzF/S77Wkf/rTVphv0o7sF2jif5Hgob/Mm3jozrhs4KHz26yBN7rl8pe78+BxA898E/bL38CCX4i//I/vz3xBfvWP9vcg+X6U1p/zPU/Ob7v6fpN9Txh+0f0t348LdIzn+2yXPt70Tz98UNX98q5/Rh72H+of6K8tHg7j+M12f/9k0oriv6aj+OHvuZb0j/r7Jfb3TA7hp/4zY338/YAHx0/xr0n495Hsh38eBX3Oti7/Ueb0xPUPvnzy8TE+zDdV/IOHLpW/ma+k/9zP6v1Dyaeiiir8u+X2L+eBrv77d6nz2yn2p1/7Kv+hHzX7y35fkYf43yT4jY+P8AdhPdN1gl87P/M//IF+/1jr/+50hD8Gv23ibT76vWPxfxNe+b9r368OtPavU/I/+jsR/99OT3V+dBL4z8JWrzz1+DM8/deZ9P/b7THtN/HMV+r+2OaDPvX9X0mq3w+f9plV7j+n8Kf/eHH+M/affFr9VP5Pf/UW5pv1Ezz+pvMXw3+a/E089Ezy7+Zj/+D8hyE+S44GIvmpX2f4v/r3M/hTL35J/oXPdyr9f7H9RD/0/0UTj/+p/wVf/nN+lj+Y/1fWxDMf/PMbjz/+nlLJfdIPfT/yq30/I/CT//3g+1fku+Mo/lyefenvxPy/H86HPP72gn/O8Je9Jt7k2UvwzDdT/jI89eu78j/9xJ7lS9c/zw/mTf7k05mddwi/dVrnD5Zfyacz+f9T0KfRY9dfvypq+mnu5xf/5Z6dPLMof/63A9jReVHjwzH5jm7p/BT8VcBPlD/BT8bDRv0Dv6u/On/j+dWqiac+U4/j/NN3Osof35yeKP9CWz4pXH7ykdFfZD+rL6vtrt7W8tf5J6ofA/L5fVK/qI/HWbP+Eh8zxuv+weKZ/eap5Mcfz7C38t/+yv1J+p9afxLor+JPfdi3+UY13uob9WNf+bfv9SjKn+iz5fViFz+sH/9V/PT4fk078D+M73+Cv0PPnT/y7Oq5y48/ltz/Cm/9yLG9f+j4A6cj/Vt/hj6i+sf+OQ/2m8l+lg/ph7vSH/w5P8irbY3HHgX+rv75hPnvgjx9+X87yHOW1F/0afbQ+o/sfchRzc/4Mz/6K+bOn3pcBPmj9aMPs8dQ+mN9o0Cfif+Brz/bOt78azVqrp94HgQ6Wv+Z84/svz93fxT/XX8DPnM88bCjnT/9WFaN6n7N7Ec+6gR8KTznEQXybOQ/mdejkdZPf9NP5D92e0b5n3pg/aDsZ/QY/Yv/V/nD2vmbP0O3ZX/0Cd70Tf5jPUWi/3zu9Fj4pdOFy5/x/eYyjI/+fnTf/n4J/arj7e/JT8nXyr/0422+l3/k/G1/cBrouda/9PxXSn+cH7eDPjp9rz8DvY907nh7H+9boIfaf7B/bAf5877zH/L+I/4Q4annnAe0tf5FeN4Bv3R8J3P6WusnvpaB7s4TfJgvXyV47Pc9wX93fvX+J8yX4ivnfyf8ndO9BA+dy/5d+GOPB+GZf5XIz3p6gV+RJXjm+yH9Yf/HQLf192Oe7fufAd92/EB/f/2n4+1+mPct2u6/Of1DH/7KX1e8z4o9nxL8OtDXqj/sB0ryh/YfvN9j7/88O978GbrU+l+wB/LfSX5o9PWm9S+dHq6a+F7W9B/Db5r2M/wreI////QRaOJP9mN+o7fCM99v5xfhR4EuWo7vif4j+1dOy39sPzQiHhQ/J9zH4w8fyr/sp7HfWPz/hufjIG+p/DsO85fY85/033b9TRL8JFn/WPRbgv/08fX5V6DhL/vx3Oh34ReOn2ZNPHQp+w2DPsp1on/kOWS8+B9DM75y/BR50P+J+GO/vYQ/+HHl4yN85eMj/JGPNzzPZ+CVP2aOzzPhj5yez5t46PJU/LOaztW/Mr/RE8Uv9fg8jG+rf5hXNR3xb4+dnmUJPszXvkvwgc7bTXx26uMNT/37Bn/lr/Ownnbwv3wg/MLpbyke/tLfPKvpXPWf+Y2W/nLq6UVSfy7IB/jrhfDYk/rVTvDUo/a6iYeO1185fSH7MT/v77ZVf22+o2T9zEf9vnD/sefQbfU/1GPqd676nWdOL8RfdFS/d3QYf+77v07bac4bjT/1uZ/V42N85vXK+pe+5yP1D9nGvl+8revNrv6H+hTiKZf+87HXr1L2Zz8wIF9G/S/9BfqshF/7+i8VvzdO59If9bXImvqz+ko9Xqh+XHk/ENUfqwf4Y0vxN/Z8OpP+Tz3/tJW/LB6JH/Vv6Mf00df6567Pjuov9amzaPI3eahfl/LfnsdjJ+LPfAl/k4f1Xsp++OMV+UbxW3o/kd/I/kdOX0n/zH8Ff9Uf6nsn5Otc/Rf+YPX/Svxn1M9k/dSnTpXUL/LJpfUfvn7407/E8T/3fkb9Sxt/pF8bSP5Ht0dH+b8/r+lo/cxn+Ej+tdOR/1KPkT9X/1b2nY7854z1UC9Uf8+dztU/4l9GX8p/8Yel/GXXvwd9kG8VvwX8We+1+NMfEr9d9Y9d5MffLhV/Ib5y+u2o//judEf5G3viTzZ+t38J9NLlNftduP9E/ImnzlFz/eZPVz6+7l9rf478/yqsr5s5P8OTP+4T/vSHy3nNz/DXrk/Tl+Fb7n8R/l546R97djaJ/Ec+XyQ/67mu6vGGX6KPu3YWvv9Z47vYD3+7UfxjvyX2WyZ45H9N8NA31byBv2G84s/mg/8mz2o8/QP0d60f+aAj/szH368yeQ2P/9JPdvX9vBfhVX+/Iw/2Vv/XRZ/twP9W66f/hu5um/j2/9g6s7U2ml4LXxAHMWGIOXR3e54Bh8BZmAwYMMEJJrn6/emVW6u693+ShxXXKqlUKklVPfXbZfuET/09X86rfORr/q+RT/4txD8MnPD/iK/67YL3f+++NxHzvwx8I/25aAYu9P0Hvi/V3e1Xy+eHM97fSTy8SvPf3OLZyu6/TdbvqrSn3j/Ynvv7p02e6g++p3uL/pJ/avr3mG/lnx7+9NXwrfjU73der3ZK/u28xNlRjX8c7RM+/fXk//B7q5Dn/GXwJ9tFyT8MXFyGfNfHcPZfhq3wwbPgt74YvtuW8nb1O/0dGl/7hx7xnHh9r/VL/r83fl/5875VYm+f8Kn3l/Mq/8ba95o1PvlX/sPvOfX/Uvb/EjiVz3hanq9aKd/xMvTP2Q88IE/xawm2+c9V/9J/Tr1+H/rnnC8++P4n7P+wDHwQ9u8TH8B3yyof3Ff+eAicq36G7/hB+ffQ+gPn45A/bS1K/Cz5+NeL4X7Mf8755iN8+c8j8m2+ctVP8B0/hnzn019f9aPzDec6/6P/nP1LV/6HPuBsG/KfiJ+baO/yiU+30d7lU789ke8bVX7f4mE+r/Lz02if8Fc23wPl397cxoM/nob9vH9wuxX68/6GFfWi3r/A9/QG+M+Zxs/3APheyUryqQ/akgf/mXq+36nIH1g8zMm/7eWiwn82+YNFlU9/uc4Pnf8j2rv+Z9b/M/68Cvt5/+B+yO9SP79b/E/yJ/n0xeNnu+Rfbcv8m6v+4HfHd1q/9AfuboP/4vtnwwON3+JTTr31IvtRn6L/QPHzJcaTq36Dn3F+ddqaV/j011X9+9PwYFONX13hB8Wv98DdbZVPf/m1/G8R8eQ14r/HE3DCJ58OiJc6//J8elGNX7t8Rr7Q/mPG88O77x2E/tTvf6v1U87+6XFervfd+iWeNmrrpxnr51n2/y7/k/2JZz3Wv64/kF98/l9lv6Pwh4Hi3x3z2ajlP+qbPfOH65g/nw/mr3eY2N/yN/6u/Tf9Z+y/bhR/LwMPNP83yj+yH+vb1/Or7M/7Z8BJ/eH2JH6r/u2vAq81/4PAif2JD4NmNX54PGE/8yr7Mz7ql2GS/5al/+baf2Ifx2vZfy/wsF/lg3Ndf/V8QL37JP8Zh/5D+R/64I+56l+fj1V1/Nm/qAeHil/UZ+CET3zOX2r+dxrxe6j8s5qX2Nu7/o3QfyX7/wz/HSr+34Q9cp3f99phj7X850fYb6D6H/2G5Gvtn/CHjPPblfj9wAPF/1XYM9f+Bf/K76rrx/2D+nEg/79dltjlOR99bqv+6/bw+dP+Z70tcSLfMfZ4k/0Z39uyOn/rmM9c11/cHvT3Jv/j+c1f7Dd1/+c59y+yXtbBb/P9IJ5f+SU+8fAX+V7++53n5/je2S/FP9YT8fpd/vcRuD2O/HO9LeNvrvP7If7Dfudd4/8deKT19276jdrRPuFTz26WVT54NK7xmX/FH8fE79/yX9bP75Dn/A36MF/74rcD/5b8z8AjrZ/NvMSJ/iPiGfH6j/jsP/4gT/Hrj+k3ol78VuMTrz9q/A/aN2r8w5DnfOxHvb/V+Olvi75aPx/zUp8ir/Idb+c1fsjb8U2/8bgm334vyN9bzf9e8MdaPz/4fujC802rVZ5/2P1Y1Puf8t87/36btVf8+LT+x2avQvX/2OajoN7e6Po9+fsv7bc1PvdfjGp84vXfZZVPf2Pl33/gRshz/jb6+yf+OPC4WeMbLrR/GK/DfxP96b+B/bV+0c/lJ/UH8Y/1rP1f/hbjn8j/iQ/gJH4QT4pptE/4C+5X1/yDJ/1o7/PH9+um/r3M0J/fG7XxN2I9FDr/m5g/FdRL++KTv/e5X2xR5U9uqv7r/DzWS8pflu2dvw/f/KlQ/e39gb/q+iv56yv8TY2/qcmHfxXtnc/vX/E32Z/99IT4qevPfeIR19sOtP7agSfy3wP0wf8vJJ/1R/10qPHfxfin7SofXDzW+NRPX2v8Q+Rp/uh/ir1Vf0xbgY9kP/o72JbtUz73b73U+C81+czHEfJ1/nJEf4xf15+n2B//Pxb/VfLXNT7z91Tj09/xtso/3FbHz+/TbY1Pf+Srb5JPfjw2e0wPa3zs/VHjg7/JfvTfxF7p/WMhX+c/M+aT+PFN/kf+anL/k/hN9GG979f4+9E+4Z9w/1u/xj+s2p/fC/YjJ+L/FV/xs7kscXFU4x/U9Ie/Z/Jmiv/8PlvX7HcY/D3xv0m+1s/etszfxaHkY/9mtX5x/nst/8MfNqv53/mHIc/XL/p8mVfH/xv5xB/tn90e4C/S/zDwTP5PPTbDH/0/iN+qx74ofvv5uDVI6jcw/EL3X0LY4fl2x3fCfD7///z//uO/eJ/F+Tf5yfNRUn8R3w6onxU/Fzx/0R9zfaTkU9/u8tGylO/1AfXAUOvX66FNNX+M3D7WIKm/jhJ7jEv+n3lZvxRflH+JT20axPjdHp+MZx58zyfEL+1fiA8eT481f28Rj2bKX+6P4/A3j//jyN+K/15P/I18vas/W6X/FTo/6PD95twafEo+4/tVG/8+/REPOuE/nl+7hg8ln3ycYY/L4LOfaN2Yv9yqfmA9cl6TbUv7+Xw26G8pfitwLv9lPnf5MOyPfTP8YRV8189wkr/cHtjzr+Iv+rg91sH3+hLcC/nMR2tk+Iv47B8KGmyC7/EUe42DTz5qTQyfpPfvGh/9G8HHHzwfTcUnvg4MJ/4z0Hgk/+88sORTzzrOW9sKH5z4j/ePPSXfx4P+hfjYM7f5SOrffb//ZFz1n3nsZwrNH/V8mwaJ/ZFv6781D/5oHeu3Hesv53qO46bW77KUn+yfvD469f5C/k2sp6wdfF9f9Hcq/dlf4Q/S3+3h9twGv0CfQ8Nnwff5Pava3/0bnPWDT3zLauN3+4CziH+tIRh5N8HPl7EeZX/H8HPF7574sh+/Z63q/Pt44LcVf6d+//B2V+/vzh/4fi/385wHPyM+fjfckf4L8JZFHPI72AN9r2r8n9E+4Xdpv6jxV9He+djnOto7/4fhHu21flwfs3exzSt8xz3xL+HPq/K76u9O8peBe/LfRuzfMtn/d+Dk/GHK/btLa9BX/iH/dZcs4uAfcf+u+XPxouffjO/6d2V/vv/71c6LcvnfxL//bPhA7x/l/XKPyJf97w2jf67817PfHT9r/M3Ag2WVDx4l958wHuZrHfz8MvhD+e9L4Fz+7/xl1X7eP/3p/Kb1C/nwNf9D+Kzn35LP+vtjeKT5hz+Cv6rxN9E+4b+FPOfT/2hLEgk+/RXtaO984scm2id8HsoqFL+wR8F8voqPfp+0D/sXfj8j8pX/G34/sPnPLOznD5V+1MbPQ6cTxi//5aHXgvk6CPnOP4j2CZ/+imWND/4qPuvrqDb+fcNTG0+h+aP/An84rvG/0V7yPwIn9p8hv1Hj4w97hmfiNyX/psY3e2StGp/xz7ZV/pz2h+Jb/23qZ9U/6JMVIc/5J/ANt8dVPv1l7RofPJf+jO90XrXfNPrLkvxtz29l1H+nyp+8zwk80f0fXy1+TC+jvbsL16O4yfRM8YvzrQH1h85//3H9En9dVfnuj2fhfxn572yLE4f+Z8sSZ5Pgt9eBT2v8c9pvqny337TGx34z5T/6Ozf5HfnPuY2vw/zNxMf+1F+LGh/cadf4rer8tW39ZPPq/GXk1+/WoKP8s0Cffsjz+p/5vKD9tsan/bzKd/td1Pjfa/p/l3yt3+/zEmfK3+jn+KLGB3c2Nb7hTPWTj4f8vdD4bwz/oL3Wz49WibN78beBL1pV/iXtGzU+9l7W+JcxXufT36XJ7yp//tiWOHsSn3hA/r+q8cHddo0/DnnOX0Z/F1q/zM8P6kXlH+qr7jzkef4lHn+vyndMPdJN6qfAmdaf9/cc43V3p574tuQhOMXfbdQPqv+Km6gHp/H+CF/PY/wt8R/sf1OzP/N5W6BK6L8X8bOt+T9vles58d98EfFkqPjr+XRZyz/byF9fFP+4H4B6ua/8SX1FPdbW/rer+ZD+GfNJvTKWfOxBPdUVn/7bjD/J3/jTOto7n3rsCr70xx7ghN9uBT7X+mtFPkr4Hk+xt+oPtyf4u/jE85+qd5zfKnE2EB993qN9wsceXfFP6a9dnX/s6ziJX93A3W2VD860f+9CeIh44fb7E/7Q1f4Tf+gSDw5lf+xBvXct/iryWTL+ccynj9f545i/K+Vv/Ot6WbX/LPwvU/2IP7n/9xU/ppp/rX+P5/A3Wj+XMX/X4nt/6K/8NcV/WE9J/cX8/Q59nd+L/hL5p6FP4n/Mr/OT+X8Pe3QVfx0fRnvnX4b9JN/vT/3J/UOqP7t8/xw81/d7Drl/lnin8wveP/aN9z1o/NxP3MP/PiSf+w+4f/lG+Yfzm2sf70jyt3a/gTVI4i/jR/5Non/ok8i/gU+83Q9+bxxY/OwfGP5ljY+9Dmr8v9E+4d+GPOff0h/xR/7v+oDvNH7q9zvTp7eo8Zn/bzX+t2jv/H3xtX5v2U8fhr7OJx9RL/cUf9m/3lv72U3UnyeWj3rwT4I/Y//K9w7vZX++/3hv4+/L/rl/z9iwvn/b4vtop9He9++ZEZbor/W7NH36Zu9c9Xu/Hfosa/wH7NWo8rF/3q7xD2O+nJ9Hf33ZH33Auervvvljznq9a1X5j4b7NzW++U/el/2X4uv8gviOPfuKn4+M3/w91/6hb/6QF9E+4T+EvVK+9ZePa3zwo8bPeewT7ZX/+b3frMnfBH/VqvLB/UaNb/3lqt/dnuAH6c/54MrwQPqvTJ9Bq6r/oB34uVXlP0f7lG/rJT+r8c+jvfOp356Rr/nz/vAfnR8O0P8y2if8lY13sKrxV9He+YznR9h7d/3H1oOPR99PbfE9ePxtEfwW3+cc+P2+IZ/zuaU1GCh/voQ98xvJxx+Il6/zKv91XtXf+auwV8K/CXnOJ/+90l75g/6GjFfxe9AI+et5lb+O9gmf/nLtf1wf6v0XyX8MfjL+tekzZPwPwR9iT+qNt3mV/0L8btb4zPdTlZ9Rb7xJPr+/0V7+s96WOJWPPtT/v2p88HBV4zPeF/HxX+qBtfi/YjxDjf/XssRJ/h2uAyv/Ot/lL2p8yyf5usbn/Otd8qmPftr1y+5lXL/k92GjxqeefLH8/z6v8tGnu6zywdlbXP8cEj+pZ35p/eBf99YgU/xpt8r6JVf9mPH9dHBb3w/8bfnvhPt1lf+9nrmMesPjF/YY1uLPueKX8u9L5MNM+x/is+cvxW+vL26J/6offD7nVf2JDx4PHpV/ycfgnuI344OfyM/aMX75r8eTV+KH9t/5vMzfSfygPnD9H1T/cb79UKuf3vEf7C/7DckH7j/KP9TnG86v21X+CPn/avx/0d759P/bGozkv5tWyG8E3/ujHt9sa3yz90j68/uI9av6bcT65fz0j+Sjzx/kb2p88n+zxm/W9P8X/Y1uavxNyHM+64n9+of0Zz62yNf8fzAeG3+RVfn+/attq8Zn/633L30ETr6/Bfb+tvJf3icDTp6/n/P9BH//fchv8/0K3j+q708V1DOf1mCs+duyf+P9Xcn5J/ZD3qTGX/L+WOkPn/7y5P25nMd3Q97u/Nx+/6S95p/+xxZvCu1/0Se/9/ffhv/T31+z11jr99PsMeb6l/bv9O/9/VX9Tf30j/Erfv3dlrjQ+enY/KGgfmq0anzkNav8iTUoTmv805DnfHDD+JPk+oWNZ2LjKb4Hf8L1MM6D9mv8feRd1vjY+7LG//4/5Rue9Gt87P9D+lt8LagHvsp+48CJ/eh/soj2u/Mn8wdKlwPJpx4BT8T/uo344aWO+I1q/NrxWW+a/7X9NrH1WCh+Du234t7zx3jH9/7pb9Ks8gcWKgrVTxPGDz6U/jeBE/0PsR/+dxv8aTvwoexHfXK4rdoP/pT5f6rxJzX7wz+K9inf5rPQ9UvXh3rmKLn+ETi1P/64ivbOZz1Q/xxr/LeBE/szH1P8/1H+Qzx8q60f1tOxyZsqfv8zfabbaJ/wp9E+5Ud75x/Pg6/zl+kq8Dfx6f9brNeUj/+ofvP1/BHr1f2H/P5heCY++QFcfCr+NwM3a3zwuF/lg5P8MWM94/9N2Y/8dcL5gdZ/c1vmo2K/xt+GvikffedVPv0VOn/h94J8vKfz80bgmfbPJ0aY3UT7hH9c0x999rCf6g/yCfmj0PkL37cqyN/6/pXnlz303Vb5fd4/r/evz/Bf8vcX+b+fr/znka2Zzj++MB7iwX9pJ+X/l3D5fniVj/1a7UmVv6zazzzIFKK/RqvcfxZ8v9pwP/iuD/LbId/5RcH3xkP+zr7WXvuXbN4o10NX/MUk/F/5t4P8pcm/mVT4jvtVvuN83qjwwVPFD/99be1H4q/EXwZ/YLho/S/+xtqPg++/g7V+WxPpfxj6F/PAM8lvTEp7av6d3zb5WbvGb0Z78QvWK+1TPu0vxbf5yJjPc/Hpb2q4I/4scNav8cc1+XP1J/t9h2840/x15oEvg58x/6ynTo3fNfm99PvXJS5UPzsfvKfrF7wfH362Cvm3fM/pssr3/q9M3p3qR3737wfq/b0e323+Cu2/puvIh93Qv2D/7PbU/MPP8L+F/Gcd+eNQ8/+T8WPvbfDpf0q81PVD+nPc1fqF32P8c9m/Ff2dSf4i8mFSPzwHzhrBP/Lz40lFPvzWLfI0fn4HZ5vg9xjP0vBS898M3Nf6vWf882gvfs56eKzysz/+/vwqv2/yk+9fXvP9O/Pf9PuX/E5//bCf98f3HBP/oX++h5l8PzLHvs/GH8h/V4Fz+f/A7J/3o33CfzV8pe+nrUKfvF/l8/3T1lPwHcMfxvr175vyPU7Gu7v+498Dt/Hr+6luD96Xe63vn70RD9F3Hfyh4qfib459fiFf/vcWON9W+Tn+NKzxN4ZHmr/fYOzXDD6/O96K3wicxG/no7/WH78XrWr8L/Cnv4bH0v8zcKH1M57HfP6t8RuG9f1g54PzZY2/jPmGz/eMd3y9f5v3Z3+fV/nML98zTuavIP/9ifG6/P3AheL/xOQXN9E+4X81PK3xwcWqxgcfiE9/xzFfzuf3qbUfK/9PsOcm2ovv++Gp7I9+09r8z9CH+d4Tfxt4Jn7T8ETtEz7xQt/Phu/fj560qvwzvjep84Mz/x65tR/r/IPvOfL9G81fTj2+mVf3b5yvFOaPfl6zC7f2+xf0V/yEwHlIofH7eQj2PIrx+/kCeB76F34/muHk/MTPI6iHvyn+cx5J/diL9VdwP8AB5zeqP/6x/xhHvtqdf9jv/9A/+D4+xjOT/JOo371e9fWL/7yw3uQ/j5EP8oXqj2VZzyT5l3rU6+ek/iE+Zdtq/KK+9P2c6s8Z5+GtqFd8/NQjn5x3tRT/W1G/KH/5ejis2t/jGfEvWX+cR079/tnQP7f+M+rvufyX/juG24r/feu/TTx/UP2FPl3Ve/B7gduKX9jD8S/pT/ynXj6V/f8FTtaPx8N+tHf9bXwZ8s40/pfARZK/luV8envX3/wrG1T3L+4fZ9a+rfjTsvHgP5nyh9v3nfay39fAbeWfyTLwofRHPvuXU/EfAif+h3+2l9XxY58M+5/L/ieBC+WfIXzDmep//DOjnj6X/Zmfc+SrfsIfOvIXr3+Y/wvyh9Y/59kL5l/+f8J6Rt9T+f9l7Melv6+nU/xd/s/8MB/ZVPzd/ZzzXXvXH/uet0p9nT8VvpD9loGT9fMe429r/MQT9E/OD3x/NK/Kz/qef02e6h/8sTOuzp/PZy/aO38c/tPR+jmP9ZfYH39yLPs7/7vWq8uP+ci0/3J7gr+H/X09gNvyH+anfVmdv/Yi+AvxO4Hbij8+Hvjaf2Bf98dE/ihwJ+Fjz3ZNf/O/7KJmv17Es4Q/D3tmmn9fD99jvnf1j+TLfj6fl9Hez6+4H+aH4Yuw/+56DPdrqf7+4/fPGv+qxgcn1284D7owecn1F37vMF8/Vb9hvxvDP2S/azD85P2XjL8Z7RP+bbRP+ENr0FH+h+/96fopOLuz9pcaP88Dg2d6fwX98fxCdq/4w/kS56d6fiEj/l2yf5L9L9n/MH/af3VZf5y3Xsn/4V+xX9T5ifNZP8nzK1x/evb9T6x/7w/5ir/cT9vz68XJ/sf6ew19d/sfwz/ZL2n+6Z/+snXwJ5wHcj3ip+If1xd+Il/xZ9/vp7T4o/tf4Wfsd36qfqC/a+Qpf33lPJ7rvb8lfxn4Wvaj/r22+e4pfl5b/z3Wn/YfXdbPv2if8G9oP6/xyR+fNT77jxvxt5Iv+99wHnNZ5Xt/1Pu3yyr/1s9rxAez/lS/+njI13fifwbubWp81kuzxj+K8Sb8+1Ypz/n38BnvF/Etn+TUf0utX/L3vY2/36/ywXlR41Ov3C+r/CV8zR/9g3Odn/VN/7xT5Xt/D4b7ixrf5jNX/cp4cuLto/xnL3BP8eM++stVf/XNP3PqqceY/3wQuK/66XFe4nxS45P/H5dV/hP1j87PHwPnqh/8d87bn1T/cD3C+br+wO/9Zujr8smP8PX8kfcP7mv8K7PHAHvr/GvAfJDPVtq/UE88035R5fcsfuWLGv+suv6c7+tnXJO/CHnOp7+Lmnx+fzb+QPlztQ3+D/EZD+epF7L/aeCB/Jf+6S/X+euA+SOfvUh/8uHVtvQ357/A31Tjv/NZPy/LKt/zx02V7/6r6xf87vH4Vf77GjiR/4D9tlX/77D+yJ+vWn+eT2mv/Qv5uUu8uqvxwa/bKh/c1fpdW3/DdsiDP2T+scda9mP/9kr9sq3xme9Vle/1wHpZ5b+FvB3f+htiP50fuj7gN/HJv2/b6vidz/zr/InfHct+OfPxFvKc/wt9VjX5Fl9z9iu/tjU+7dc1PvP3VuNT77+rfuH3d+Rr/f2aB1/nV67PR7RP+Taeoda/j4fxqn4YMX/ki43Gvw080vrdtEqcyHc++XMzr/IZz2he5Q+J1xvx6Y98/lv8f4FHWv+bbYnzgxr/IMbrfPT7va2O/yf+bPORa/9LPZOTP/fT5weoh03epsofqX3CP4z2Zf09t/eFWHv535958JW/R8wf+fKjzjec3D+CfiOuP+j+V68nWX8fWr9Pgcdav5eBs8f/x2/t6lXng7ecn2n9XfL8RHtcqV+7u+vhFu90/Zb94BZ5mv8t9qR+0PnnWPiP9u/wP7HfosZfhL8k/MOQV57/GZ/zV/kP/Y0t3ub74pt+BfH0s8Z3/SUff3T+V/Ft/Rbk+7+qf/viy3/+tkrs7RM++fxfq8r/16rK/xu4UP013oqv+n0ceKz9s/dn66Ho1PjUC/80/k7gxH4N40/MHwrVD5NW4Ib45P/9aJ/yd+cPrZTvzyPvt6p8nh9uq/459funzP46P2rz/Ab3u821fun/yc/bg8/vk4Wvn+D3/fzX5Mt+1CP7xp+oft5fluunUP0x4TyWeuJrjQ/urMcVPrjIanzwVvn/pxHgT5Q/eJ4V7M+rev5e+/7doOTTH89zdnX/2lfGs63WTxP8kXx+IP+9DjxW/II/uIn2CX9S8//rwBPlf/qbcH6l/ffkMPCh5v8u8LRd5YML1d/oV5Dv/0k+8fAWvvLX4TLqx+T6s8WPgnh5sK3yD+bV+hf+pFkdP3zv71b6PwXuqf483JY42f+hn+OjGh88XVT54NR+6PNcsx/5/Q/5SvY7In4y/8n1D/yP+ue4xgdPVzV+O9on/LfId84HHzNfin/H8xIn+Y/+8360T/nUv1p/9O/8E/GJXz9r64/6gufnJ+n1D+Nz/qvnb5xPvf5tWeWDp80aH3vr/KLN9Rew4of3v5hX5bs+nL/o+Rlfz9zveZG8P8j6a3J+lfh/4HT9Kv7/1fhvAs+U/5vgfpVPfxnjbcr/P0N+d1vjm78Wyr/Eg/x7rBevX+i/yXpL9m+cZzD+D/FZD8TPW/HPPH41dueVCb+DvXR+ye9Fo8r3/r5z/5XqD34HZ6ofOV/MyZc/FH9ZX0+x39/tn/z6z7iy/+9iz+ta/YU/nlDv6fzU96Poq/qD/ZHLT/Y/7I/YTyX7B84XZtS/un7f5/4X9ssn4uMP5L+J4p/nQ66f6v69Kfpgj3vN/zpwsv48HtxEe69fN1G/qf7388Bm1Du7+nle+lOh+xc4HywYj84P3R/3WqW/7c7v8Efivep3ryc/q/W310d/avKpL2bI0/WDyTzW857WzyLW81T5j/3MkPE2xF9F/k/iRyv8YaL9v9tD43X7M56PqvzdeRz5VvPPfMxYb7r+wvz4eVYSP1mP83jfx87/OQ/A//9J/3HUb4n/ML69ZTnf5fXbEuc6/2R/5/vXPfHBv/BX2Z/9MbhQ/T8l/5MPvsj+7N++Ml9af9h3Jnvtzp9j/X3R+H+E/Qfp+bXxD2O+PP6wfr5U+X4ehP1niv+c78B3eT5+znPZ///V/t+vL/+XkSvjZz+OP7eK+P42+eSk5n+XoU8y/qXOY7Pg98eBv0i+3x+1PDTatOTvzmcM58H385jdedZhKf815nOm+X8iH/t4JH8bWPGrYH+U2fhb/ZDv/mU4iV/EM/c/bw+f+JLNDyvnzyfMB+uhE/J9f9E13JB81nfGeC5DfmNerv9WT/oznp09Qr7rg/3mwV/S/2Jasb/HkxPJg49/722jPfyW+tP8u3/RX67x44/gmeIP8+v+r/oJ/m79pPdvGN/sl8h3fdaGB5K/CX/Ml6X8Vhu8rfqPzw/2HImPfn3DhfTHHo5vNH7pI/mtdmCNf6cP8teSj37bqnzXp1eV7/r4+LfBd7wxPBZ/ZXgoefD5/nhB+8Pgd+z+p4z7JSfBz/h++dRwR/cP/oBv/WWyH79njHcmPvffzg336nwbr7eH30M+6ymRjz7nyNf4+b49OFvU+OCzGv/Wv38e/Cn3d9G+Efd/tdAfe+v5sRb3h/0ouN84+IXfj2ryNX/OXxq+Kqr8n+i/rPJzvtee+M8y5N/msr/h66Kq/0XgRH/6d32uNf5x4MR+Q7efzcdSfPTBn/qSz/2n3D/Xmwd/AUae/M/5TcN3RZV/6/Mv/4XP/Gn8be7HbYY85zfDf9ryH3AffkN8xof8peTjn7c1/q34zeBfbvt23sajrcHvjgP3Y/6yp1aJu3waBP6Vvao/N3tnz63g8/tjwfd2g79qlZj2u/qD9z+a/6bPn3L9mnp6EPb360kDk5/Lfs/Lcv/Tegn9fX/yavhF+1f2N0PkK3+wn/F6dB187FFkjFfyyd9DwzPt3+nf9XkLfo4/vhseyf9+YQ/0X4b8IbgR7RP+a7RP+MhPxj9Uf79r/E20dz7jG0me88lHjP+P+Py+gi///S2+/Gc0D7wSfxH2SMb/bJj9U74KPvObs562Nf6n4T+tbYU/tv4Kxc+x8Qvi57/g++/0N5b96G9i/JGeP3I+/tgIvv8O/qPnFx4kX/EX/3D8KP2R/zfaJ/ytfRqzUP0E7m14tar8rx040Z/+JsvQ1+UzH5ua/el/vzZ//D7aVtcfv7v+G9mvFXgS/uPru097+d8V4zGcvcb679/4pz63VmjE+unZ7+D+OuIHzyMX5g/FMNb/mOfR+V73NOTvnie2BoNtxG/Hlu+8/e783fg8v/wa969nvCp0YX8Xyl/n88DfYvxtHrUDn/FoF/Y7st9OedRM8d8fHQWfyH48KgKeiH9IPvBH+8Q3e4wt3ufDsF/Bet6z9v8ifhczG8/M5nus8fM7uEju/6b++2L8ufyP+hFcaP/J/el+//QX+Q/167HvN4P/Ebgt/x35/by+3uL8jHxAvXkq/ykCtxV/59sYz57sD5/6/3Rb42+r44ePPV2e82+C/xnPn2TUk3/DXrvrD/TH8/6jvMIv2jzvr/zJ/ubM7NdW/MoZ/8rrz3L8/jzdNtqX+19I1l7+x/N14Ez1L8/DOv6m57+ob8+xn/znHH0s/maqH9vmjxn1wrnsB39h/OFqWOGDvX3Cn0Z7X79veYk7mv9fVr+A819hP/rL17RX/qf/jdlz1A/5/A7OVD93LP44fyP786qLhY2no/0br7pwzK3o7r/cOnMQ7V3+d+v/u62fjuLXd8Zj6y1T/dpZxPyfLqv8C2s/ng8rfPw5u6jyM+rnC43/KvBoE3z6G61530TYr0M8BCf+e+X5aL1rv9v/8j5K859C7y/i/QL+/PQ03f+WOIl/1349y/jJ9XPO06mfLzR+ztMa3H+6Cf4PG0/H6oVM9W8H/7k3fKnx34T+nWWV32W+v+VVPv392Fb5FyFvV7+Czf/zv3r+jf6aeSnP+dTHG/PXkdb/Zfhf/qnnl8dxHjnS+HlV/Jnpk6zfU4vnvn674X9tu5SfjaJ9GT9Leyb50/Mx8etnEn/t94OizLfO51V8PPrfTfaPrRJnqj94lY9jf1Wf1++xnrtaP5fbcj1np0n9Py3z6SKp/4syHyf5F77396XKd6z87f29bNeV+EH/A1sPSfzoWv3g/ke+dvnUFxP0lf8xPzPO62Q/f1UE+TdZ/8zPGfZX/saexI9M+x9fz52IF25/8tOl4bbsRz7m1YaJ/T2esP5/KP+xHn6wf1L9iH+D0/jXDLxR/cL8nC+r83cuvuK/v9/kGH+T/5CP5uiv9ef5yOJNNpT9uB7DeY3yv9dnzGeh+p/81N7U6qdNUj8p/ttvF7X48531j71fNf554EvZbxHz2VX9wO/MR2J/Xw/wT5P9p+yn8V+RP1s1/6W/dbV+cn+4wv8k/1Typb/bk/Oqn9J/EDjxv7PAif3JTxn7vZ+y34/wx25iP+xh9s9uJd/Gk22q8+fz+RN7S/4M3KjVr+jD/u1a/GnUH4n9fD0S/3T+4vngT/i7829jPF3VLz4ejdflw2e/eS3/PQnc0f7lLPTPtP/GvzPOf280f/3AXeUP7IM9sk/x24Hn0v885Cf+d0X9cBjjdf9ZBL4R/zlwW/KxZ68f/uby+yE/0R//uqrN/89lrB/tf/ndceI/65CfzD+/9+Y1/TfBv5X8lxh/T/a/kf20f+5hv/2a/p/RX0/xD//qtaL9rv4IrPl3/Zyv/HEdOJHfbUq++D6eeTnenf/Y9yvaTb43EN+vcMz++1Z83j8Obuv7Ref2/SbeB5Z9TfzPMPn7LvE/44Pbm+T7N/b9MO5XEr/g+Re+9ziJ76+1+P7a1N5fnDeS949tyv70/bGM3/meXFd8vufYM3kdfX9nYfmvR7xaxP6zY4/aZnzv4077P77feGf+01P+pb+M77Ufq/7AHsT/RXw/Zdcf/qP904jveeM/ij8571fj+4f32r8ynnvOnzfJ+5ONj79IfsH358nX94ofR2HPXrL/5nvu5LPfYT/sm5EPJN/nY8n+Wd/vm/M9ZPP3vJWs35iPpex3EPxE/hnff8efNX/MZ8Z5wVL1h/dnuK/679jOb/vUa9r/Tu08yfHNsqyfivdWibvNvMKf2nlMrut/vM8r51WTv8TnfVzgvtbvgb8/2Oyv+986dv6bHbH/tvMh53M/IO9f6il+Pth4hnb0m+jft99z9uuPOj9iP//o+9eiwu/Po33C70f7hP/L/B155f7VxmP+mP+K+p3fM46WHuR/XJ9/9PmI8xPeD8P7Y/Lk+lU/8KPif9PwE+dfiv/4F/6X6/oV6yGnnrtX/sW/nxiv6i9fj9ZfPhXf4n9O/Xin+IU/rUzeQP5zFzjX9eMe+fMg2vv88fzhinpb9z/u3k9l4z0P/mz3Pt3lrn15/YHzI+5XUPwInH9X/GhMSpy8f4XnZ3h/1SA5v5+XONf5Be+3cpy8/+uv+f+z2WOk6xebZd8O2afc31TyR3b+n39a+xfN/xf77YV6rxX+w6uw6C9P9h/2qh3HL1r/vDr6hf3eIvi8KnnAfKt+4lXMGX+/Sv4CTPwTn1tB6C9Prz8FfpV87m94NfkD+Z+/j4f7H+7F534Yv36l+6e+hj17yfU7Hl1Evq4/8elAx2vJ51OAjueh/7HZH5zEn6E9CppTLz+Iz/V77Jdp/bVZf9xvlYy/H/gl/D/nevyaeKP6hfgMTuJ3X+thrfVLPnnjvEzx735Z4kz7B+K79/em/EE8fOP8dhH+R34ln+a6fsX6yrme+6z18z3mf5hev7d4hr7J/RuriH+yX94I/x+oftxYfB6yfi7l/3b9oei0Sn138xfxbyD7zfFf5N3I/uNJ6c+Pyr/P4f8D5b+eP880rcwf+TA/rdn/IPxvoPGTT33+dP3D4+lzxFvnU188cf+J5BMfiaeJ/X09EH9eFT/9+UXOPxS/yA+ef5V/fDysp7XyVyfyWcJnfgeMV/tHj2ev1fjr8eQXfNVPL/gf9tf+gfn1ePZL8898EE/6qt+YzyHtdf2xL7zS+hnGfA63NT7xS/s3zyfE3zfxTwMPVb+/4c+Nav5jPfl8vsf8+3yCh4pfa/prVuff/YHzgI3s9xR4qPzJ/IzQV+c/rC+fv43sV0Q86yv+vUV/ufZPfezB/nUj/ceBk/zv8cj6y3X90/2B/LmR/c4CD5Pr357PrL32v4ObWM+/Nf6byEfJ/OEPPn+qX1jfPv+J/Kvwv4SPPdx+2r8NhR/Ex57P0X6nP/64rPK9Htiv2X8ReKD4y3piPhK+r+fLiLfOn0X9NND5BfFg1K/WT8SHnOutyv++HrHHSPHnpRV87T99PZIvf2v8b4GHks/69PnT/o/+c+q1d/G3ki++r4dmtN/Vr4aJl++yH/75B33lP/w+uozxOr8R/N+y31r6K3+4PxAvdP14uIl48Ef2e5d85Q/Wg8tP7LcO+Ql/ntn9v369JPir/8qi/9p3WvZ8XfhPyzD18mq+KPnsRz+Qr/X3B3tir6bsj/7096Hxw/+DvqsaH3tp/+n9OV/ztxd4LP+hf3CRVfmOPzR+9Nsuq/rz+9jWU6H6vW/7o/zI7PUvrj/nfDrx0fBY9n+0/c8Y/6O9+AXx7lPyuZ7h+id8+iNeq/7p2/lvzqs5PnV+zKei0Ge07IT9bH7AxSz2X6OV4bbnr5g/7PvB+m8HHzy29Vd0Zb9G4GT+T218n75/SuQf7vyn0P6T+XW81fwdBR4pf7g9uF7YSvzX/O8Nedo/+fVn5kv+8wmf62/94I+5/kw8/rus8h/N38fbGh//68f8OZ/6+d+8yv+HfOX/v349nfpFfPz/DP+RfPQBj9dVfv+mU7Z3PuMhnm7T6wfGR57iF+Nz/9X+zfnzaF+eH4R87f+24ifx2/QpxmGvXfyP+R+r/nvaLnY40b+PP7L/fliWfJ+fxrw6fz6f5g+Frp+5PvhDQ/u3W/u+x5v5Y9aP73/8tf4mtNf9m/TvWPPXOg/+ROuvvZ2XeBHfD8nG1v9ZtN/tHw3vmz4T5c9Oa17iffHn//EL6o/95PwFf0Bf1W/YB5wPwn4Tm5+C+nO9Dftxffwr8mW/fZuPyTraJ/zraJ/y52X7hD+yeFBcV/n5U8bzKyGf+uWgVeV7f8QL7V/Qr2A/ciD/vZL+8p+v6M/8L8RfB96X//6UfMWPQ8NT5l/Xr6atmP9DyWc/fcj+6bJT5Vv8Lp5qfPo7alX5zzFfO771P13U5KMP+6EjyX8I/59eVvn0l/j/FPxak0//x+ir+uNwGfKT/YuNz8fzovV7YfP5OK/q/2H+NWC9qv4dWXwvfnm9H/wvxj9G/3T/a/mnVfWf4bxT+mND8X+VzXf+PEnr/3I95s/h/1OLnwX7kSPN/3vgxH+OwRYPC+2fnH9X83/4rv+8ymc8yfixr9vzm/ivgRP5B9jf4n+h64cej6iXjxT/z8OfJ5K/H/5c6PzO7cl4vsp+l2Yf/Heq9Y9/gBP/dXswH8eSTzylnpiq/tm2Spzmj2Zg6d/ie4zfuF9yFfF3aPFvSvvk/le+z0Q8/Kb5o75ttsp44XzsOcNe2r+5PbF/U+uH+NKMeLGzf/RX6PrdZBu4Kf3zDNc0J5vH+m8RX/FX6d8aB5b+/xWU8x2eaf7gg4tGxP/ZwuI/+4Gmxo89Tsxes+T5H9NnNmb8wff1zP73RON/DjxV/j+KeFLo/uVp0+R/ev6O6w8f1n8T+aqfv21LXOj6bd/OD4v98Jfd+QX1r/09U/x6XJa40P6xYPzfq/Zzf/pWi3+ffj94Vf++vWrW9TmR/9LfCf6q+d+fx/rR/mfWasf8q35oZ/Pd/E+1fn0+mD/t39yftrX5W4c+s+T6USv01/7T9fkb+u7Oz41wQv2r91/xfacZ6/VA65/naf399en+xTD20vx/GIHvRxXav7Vt/RXHHn/nO37Wt/nfw38Vv89s/D3mW/efTKz+KdgvfS5LfkH9tMf4VT/f2fwPLqt8xufjOUi/X7Es5cv+XxgP8/mfxcv5w/7H0T7h24ym+juf/Z72T+YB/w3Y+tvT+vf+l00z0CzWL/0xX0dV/g7THvm+P503K+Pn+zy8zzmZv4Gdxzt+jvvHcj6FDk7G/7wscWI/9wf2uycaP+cTe7IXfPzD9df9vzPPDxovfMbz26/nxPhdn5sq379HtnufavB5v2Rm9kq+n8b3dKY8z92O+Rtfhv9chP9kP81/vuDPi5DvvxvOriP+dTaWPzrWXxb6+++Z6dPZRv65wL8vrb9eyG/NZ63d93/EL/Wr6s94WstZ2Cv4rS7y51W+42Xoz/eIpryPqCu+6ePfI8rCfu6PPh/it9RfR/x24C/p9dNS/4T/w9Zv68bsdxv261r8bQ2sfS77Pdvv59Tzq+BfkQ/Xxn9J+JPW7vvB+VZ8np803NXz71c8v34Z7Z0PJl4l3x/m/Rn+/WG9f+Y3+m9Nn0mMf2T7p/xfRqNSfk5+Lcxew03M/6vpP8AfpsEfNAIXoX+OfcAD7R/dPthjLvubPVqnhq/Cf1tDw23TJ1P8aJs+mcWL5Pub/J7zvSZ9v9L7Ayffv4Q/ZL3p+1GD3fc4TJ705/0V4L7eH8H78Hw+zkJ/f58j72/qyH6dwJnW3wPf0zCcvP8xYz39sP66wW9dBM7kP51lqX9iP+eDO9saX+3F9/5+im/2z3nf/Fv6/ZPt7vuxyfdfu8FPvh/rfNb/m75/xPPnXdMn24b+x37909bru56/X8f7A7qyP8/v9pjvw+B/xPtbWrfyX57/vTOs95e17g33zX65/KeHP/I9xiuNvzkrcV/2d77Jz/tVvuOnGv8p7OV8sH+/WM9v9ZHvz/uE/XLLD47r/L7Ze5C8f436g/dpaf1OPOkZ3tf3t/yiO/FO9l9teSjb8LPWr9UfOecvA/kv9cfA+IN5rJ+B6ZNb/Gutg5/jf2+Gh4r/L2DsL/91/sbwa43/y/CTxv8S2Nv7+RfYxpN+v5r7f/j+3VD+w/cR0CfX+Pndvx+t9wfTv+OB1s878uN707v8g/xGNf+Rj/x7hqPIX/nG7If/DrbJ93PnZTy9C/5wG7gX/Gxq9fOztc/l/+d2HuL4I/jtw06Jz3V+tjXM98+T8Y9tPgrWw9/gF63AY41/G/NZtGt8/FXfT3f+pjr//vvDsioffeC3Goqfu+cXt3b9Leaf/uD39f2OidmnwF8Uf4tF9Jfov08+NpzkP+cj/2uNfxbtE/6df+809Af3VuOK/vyecb+R9M8mNn+jbeQ7rx/mZf3QOgh+h/wJ3sT+wf2J9ez+tqt/zR/Q94/iD/Yf1OL/VeSPvBV84onHw0Otv37gxP8fAyfxB1wsa+t/Het/rPrtH3gZ8+Xxh/xOvFwp/uD/xPNC9TP5oUf+0/iJ754PkvhHfYn9tP78e6bUM8VN8HkfeWtT9R/P7+fYT/HvPeqfJP8wP97fWHzeT/Ide8t+vdAnke/xlfEfyX7zwFPFz1XgXPVDTj5qRr3g9RP4G+1l/1nYs1D8nIBZj+fy38vAbcn/qvnT+vV6hPGcyP+WgWfiXwZO/A//KEzfTPtP4ovjsfifxJNov8u/86gnVH+6PVgPM43/I3Am+9N/G32a4q/Cn2eav2Xo31b8oz5w/CD74x832F/855i/tuoH8qnjZP0ynusaf2F4vq3Wj/hnm3ij/VM2j/k7Vf1yGPVLov809M+0/2E9Ox6Kjz6nNf/phj6Z9l/koyyv2R97ntbmr4M+4yo/G8d8JPqD5zHenf7wzV8z5d9iFThZP0dhz7bij/e3rNrP/eGL4bOQ7/6I/VP5zCf7v4HkrwPPtf/DHmc1+8/lT3uS3w+c2M/1WZb6Oh//bGP/ofiXMZ5T7R87kr8O/mnok+jv89Gv8Xthj5S/LXHCn9n968We3e99EvfPFx+G9wxPdf//UWtjpz3W/jnuH5/AfzF8pvOPq8CTdfC3PD9A/af7z8dt418bPo/5K9pg7Jl8/9vkj01+pvzRavt5irWcx/4TfI795b+ZEcBZFvt3+vf+zjX//H6OvVpR/21N/qhZle+Y/dtC9SPjA7eT/Lctx59p/8fv2WlVvtvj67JsX17/43kKa6/4j32zEfLF/4l89Bcf+3bGVfnTy5jPZP7A32mv+HVk8wd2ebvzd+Nvo73bj9+/2/g7ip/fWqU/eXvn8/wD+93vkv87/K+j9f8N+bZ+Ez7+mJFPJb84CH+eyf/AHeKH9o8znn8B78n/+f7Ll2i/Oz8EE68uxEd/3jd/IfufGB88Owz53h/r7zL4vZU//7xN39/q73O943tLit+O8R/tn/17IE1//2TYn+eJf2B/8edWf7r/d8L/88Z/+4+M/csorp+3flv9e2b7kY7qJ76HM2j686/hv3b/Q3bv8arkZ9zfcYn/NJP4s7B42MFewSf/kI8vtf6mgZP1y/rotKP9Ln78tz4z9ttbnb+zfv/ZeLuK/9t5iTPt/6e8P5p8f6X5Yz6POK+T//N+3C7nlfp+3NT23xn74Z/yvyeu5yFf9cuh1Z9d86diFfbn/dre30/Vv9PAXcVv3k8MLvT+6iH3T3C97qf2z6vAXa3/N/Qh/j7p/Bj7/zb9r2X/u8C57l/6wXzY/VLe3s8v4X9U/SejPro2/XuqH+kPnH3W+OBr1U8f5j/gTjvi7yfvf7V4Uuj8jfeLZ+xXbjR/nOf98++HhPzfvI+a72W8K37Dxx9+6/2HvH/Q7Sf+rc1vj/in/WdvHva7Vf5tBO4tanziz7bGp7+7VpV/Y7ir/MHvvVWNT3/H8OfJ+jeM/HWNT73xTXzmg3rrRvmL96/c017y33kf9I3Hm5LP9xEy9g/J9yM4v3737wXJ/5g/W8/J9zP4nkZG/XSv+D81/1ya/LHOX/7Z+p5y3p1p/R8GXmr/R/225PxX63+5LHEy/r75U96J9gn/lvaXNf5ltBff+7vV+QnXPx6Qr/zxYPr1VzX5pk9eRPuE/xjty/OL4B8Hf8DzA6/+vETw7wL3Ff/5Pgk41/u/+3a+7vHgSfbrgs0f+ouw/4PZv0/8UP3Tt/nNZzX9p2HPgdb/E+ehnPef1fjgpxrf7Teu8bl+cCo+/kQ99Cz9Z4EHWn9Pfj0j2if87zX9qZ+f59X5I597/lP+9noA/Kj1fxV4IP+5mJc4qR/6dn9I/sPr9bh/aGD2f0F/5Y9Hy1/MRy75A87zyccr6Y/8F+Rr/b/4eaa1v67xsf/rvMpfhb1SvsWD/EZ8rh/c1eT79Qc/rxef6xkt978qH33Wyfk1fOyt9Ut9OMR/HmX/m7DnWvEPe66pFxI+14+of+V/Xs+yX39T/P0eeCj/e5uH/rLfkOtBnHe/afzUE7/gX1b5A9bfW43/Whu/85En/6P/Dvb/Jf5N4F+ST39vy7J9wh8iX/WXj+c95svHj/3fqd+0ftlPUM/nyv/sJxy/y36d2D915T+n1F/k701y/Trq2bfk+nXgofznYlviQt9/YnwZ/vhL+Z/rr0f+vaDgU8+BM10/4XsQGfOn+svjKfmor/Vz1CrrtyT/8D0kz3/3kj+O/JXUn6xv1nNS/3o+pf64V/1IPXeJ/RS/P7dl/ZPUL+xPPJ4n8Yf18Lws18vO//FH5k/ntz6fT56/gz+P+Ryq/l4EzhR/qcdz6r9L2Y/5e6W98tdK8V/7F+K759OV/Id66HZezb/Uk15/Kn5QHzlW/eX18U/qTa3f9Tbq3+T8l3hKPnvR+nvR+pX/UN+PWC9J/boMvJT9OD+72pbtd/EPPvbW+e8APvXrRvmb+E7+HUn/X4rfun6BfR3/lv3fAifx48H6H9XrFzDn778lvxv2Hyn/+H4G/9P1v347xv9H9ssC9zV++usRr3R+Tn3s+Hd6/d746Kv1gz95/lH90wdTT23EZz6pZ0ZaP9RDI+yn8wvWd8Z53Yf8j3j6Ma/y8Sew7zd8/uG/RXvns56uqJ+1/2J/yX4y1/kh+0nHH1q/L4G7Wj/kozH3WyXxZx54nez/Iv+NZf+V6Tcm/ur8lPXoOMn/p7Eex4rf5Ncx8nT+7/mYePOp+Wd/vo14s9s/RP4t5H/DRuBP+d/vwEPZz/cDxE/FL/wrZ7/zKfudRDwdy3/v0Z/9kuzP/qag3vur+ef6Jfu/nvS/bpXxJIkfxJOM6683ks/6+Duvrv+ryIfJ+QXnAx4//86rfOJpEn+J7+6/qh/dnsz/p+bvIvx5rPVDPB9zfqHzX+zr+F36f4l8Nlb+Ix+Cc+3/+ubPxagavz2+EE/GWj/uT4aLXPKXkY/fNf/riF/J+ct95NNC1w98Pr7Fenf932L9jFT/+Hg4f9H5O/m4YD4vpf+PiMfjZP0yn7X121M+/6P5I57+YL41/6yv8bgav/jd5Yufs7//hzzl743mLzl/bsX8af34eoI/Vv7EP8asd11/Gy8C/9P5E/HgH/bT/G+3ET90fsx4HP9T/CE+NuZlviuvv5bxs1D9TX5z3EjOz5m/WvxnPsfs13T9ctSM/JfIx/6NbZnvduc/4FXYe1d/BW6I35B8+d/vVmmPYib+NvwpiX/kw3/wlX832L9Rs/9NxC/FH/dn8slE9tvOy/WX8tsRj/9q/llff7n+kpx/LkuczB/2KRbRvjz/Ku2R8FkPk3HNfvjDac1+JzEfE9nPx7Oozr/ns3ZN/37YL4k/2Ad7puNvxnj25b/n4U+J/o1lyFf9OsF+7Pcaqr9PAyf8P34/id3/q/g7svtTit31i0a5/k95/o39kq4fLdj/oK/qv569D6mg3ruP9xdlxy2e5+vbRf8kf5W40PWLXiMv8d02+N9aPL/WtK6T+89tPNQrSf2FP1Gvf9X+i/j0iP2S6w9g8p3qX84jC/b7B4q/n4Enir+cL4Iz3f/k9mA/sC//Yf45f5mo/uY8DFyo/ud8xvGj4gfx8GBb1Z/vmU/xN+Xf3tbvx7XnhaQ/11MOuX6i+M/1lSn+kpw/bANr/5nx/aB9rv8k3w/j+3usH9UvfN/dcfL9d75fc9Iq25fz19h9Pz7l8/2hZ5//4B/7/tf0vazywUWy/2U9UG8eJdf/DB/DV/15NC9xlnz/D/5rtN/5H9+Tor3yH/aZUj9o/zpch/2Olf+JR8emz1T29/M85l98zoeKTfiL81nP31pV//mGPoeh7+76Y4z/MLn+CN/wrFXj30T7hP8U7RN+s1XK2/HxB/xH9++5PuT7pvh/As/aNX6/pv9N9Cf7+/ka50GzZP8UuNiX/ZqBXxV/if/EjyT+nCxLexS6/212GfjrvMbneZFxjT+O8Xr8Zf3OLV7tKf4SD8Ez+d/XwIX2X94f8ayZ3r/G8yDWXvljzPOEq6r+fN+gIN5N9PwAfL5/MJF87DNbVP2P87SC/eKJ7n/h+ao94q3WH+sZXOj8n/jgOPG/rfxP+5cj1s88/M35zD/xdE/z9xH9zRT/vgUuVH+6PuA9yae+/8LzO/LfL/78j2GSmssn/lEPf6nxWxzytecVPrhQ/TYjP+T099kq+fzORdxU/rzk79qLXxj2mzrg7wX/v6wbfOxjuPgS8r0/xpM9lPxWBkaffvBbp/bPpeFeyHcMPw/5ra7wKvje/6rGvzE8oL3k83uO/K344LXhUY0/Adf4BfIbGj/zcxj6uv2Yz5nhtuyHfdqM97DKz3gI5azGB3t78TNwU/bLor++9Me+59X59/ktjJ+Ng9/RfLaDn3HTD/PfCfmtReIPVX7GfP2o8cFZjU9/3t75Zt9sWePz+3fDXfEvAmfrGh98KT7zN6vJp38uwmUb8T8Dz2S/cdgvGf+57Cf/acNfhb4uH/5NTf8rw72a/l31dys+9riDr/ljfD3kyX8YT47/3Nf4Pw33tX74vX9a5dNfjr88iI9/8RB1/7PGV3vnm/1z1vtK/MOwZ6I/4+EiXOK/XeavEfKc3wj7DWS/W8lvSb79nuO/T8HPsf8L7bV+n6K/XP6HPXw8r+K3Aw9kP8Y3xN6KPwPhX+LPgz+s8du18Tsff5iL3w/9B7IfeMj45X8Dxgf+LT7je1a8En/EeDdVvveXjJ/1s6npv4aPvvKfofCb+NjjD+2l/1vgQvM3PA2c2A993mmv+XsP/QvlP+zh+K/4m8AJH33GjFf2d33wl634zeCPpT+/T7gJXvlvLPw1+D6eAx4CzKp8+ituanzWa6PGp7+h9Hd9TkNf5zOfrJcj8bHHMfKl/6fhGfIaVX6BvZo1Pv1NH2r8uvzP6O9AfMZ3QnvxDwL7eOFjn8LsnSl/8ntGvTCT/nZTSmsOf17jH0b7hN+K9s4/0fjlv45t/Fkh/jbwqeYP+5ye/g9+2/TJOuKjD/XKXPFrL/htxZ+58Jfgg7Nedfzen/Nlv9OHEmeqf9ye4DPJ/xK4rfXn/aG/6of2TeCzsN+uP+Qpfpx+ljgbiG/rP6OeOg/7+e/gRD4P2bXNf7Kh+IyHeuRc8tHn/LNsn/Kxt/J32+IpL0FqLWL83v+54U4i3/rvtENf5zOes5r+o+ivo/xHf+1myNtdvzVMvbCQ/qeGv1t/Ha2fReiTLcS3/jPqie/io8/Cxt9R/KB/cPa9xr+o6Y9+F8hX/loETuW3wp4X4p9Lf9Uvrg/2Uv3G+DLqjwv574/AHcXP75J/I/488IXGT38/sJfWH7+Ds2vx18H/ofnn9x81+a4PfNUfPp5ltHc+/V1af13N/w/pr/qpQ/x4qsl3vunb1fzze5fxPovfCPxD46f+ufws2+/49GfjyV7EPwx8qfl7knzxr5B/U+V7f9QrP8V/DtyV/13R36pqvy7xi3z+U+On/yv0l/9cZaU9s3fxsQf1x7X4q8DdZY2/ifbOJ378CXnOX4uv/O/jaUb73fXDwD9lf+qrm6zK9/6Yb9UP3h/4Rvp/BO7Jf64/S5zKZ/7+1eTz+43hnubvGryI9gmfeuJW8v2hQtqrfmI8Pcar+qXXCnveyn5/pb/s7/pgb9UfPh7wrfwHfe5C3935LfLxn2Px26HPnfhHgXvKP3enJc5Uv3h/zZC3O781fH9ale/6YK8T8dfBvxf/UPbT/Ls+hnPVL9jD8Z3s983w0tr3ZX9+B+c6f2E8ju81fvRZmvy+4ge/g7O94Pd5KJb8uYz5d33ukSf/4XdwIh+cUS88iE9/D8jX+n9APuMdVPk59cJjVuMj77LGX9Xkm//k5Otl2M9/f4Sv+MHv/U1t/GaPnJcoPkn/InB/U+Ovo73z0Yd64zHm3/HDZ1U+v/fNf3LVH94f438Sn/E8wdf+jZuE+/jPJPgD5o96YSU++Xtl/IHmb5WVOP9e44NXpzV+6JvwXf9z8W195NQDz5L/PfBA/kv/A/OHXOdX/J5Tf7xo/k8DD+Q/2GfQr9nvMOy30vzPpL/qP5+Py5r+zD/nLc+Sfx7+O1D9w++Ddei7u/4R/BeNn/E9f1bluz3gq/4YXAZOxs/5zQvzp/l3e/ASCp3/DJaBnzV+6odX5En+K3z85078bch/Ff86xjNU/Ys+4FznR97fQ8jbXf8wvIav+af/IfZ+rPGpB9aST/32Yv4ylP+6PvNo7+f/6LOq8alf3uArf/K781U/DQ5D/zfpfxc4sd86+st1/sH4HCd86pdfvMRP/sPv4FznF0Pm/z3ap/yafOffRHvn92M8bxo/mIfwh1o/bg/rL1f9MGT9fkT7lI+8Zo2P/XR+5PqQ/39J/nv0N5L/8Ds4X4uP/1JvbBR/1oET+/l4mtHe+WDqjY3kf4T+I83/O/LHVb7r868mn/OL37X543fn6/zF53Of9pr/t+CPZP9fpyX29gn/MOY75aO/6ifGx3gS+Y6pd/6I/zfwSPlrEzhv1vj4w5/TKp+XMI60/nw8xAud3/h4qId+i38gvvyX30esN9WPo0XwP6Q/+v35rPIdN6O98208BfXKh+b/W4x/LP/7OA2+8r/rQ/2ylf57gUeqP5iPsdmr0PkPvzv+1Pr5Gni8qPG5/pbX+JwH/RHf9cnK9s53THud3zC+gnrjr67/tDT+yxr/Jton/EF1/EUW/Y21frb0Z/5a6PzF7QHe6voh9vhreKz8tQ1c6PrReBz8v+Kjz1/0Vf3k2PyhmIq/DPw3/MfH9/lZtt/x0d/mu9D5zXgT/H+SPwqc6M9L3ibY61R8xkO+b+j63Tj4k36Nz/yf1/jnVf/Z6YP9FX/BE1uPheo3twd4X+OfBK7zff5/1PjgfcmfBT/RvwHG3jq/4veCeuir+Pz+9bQc746fBf+n+K3AX+V/9Ld/WrZ3vmPmS9fvJlxPpt75qvn7HuOZaP7Qz/mJfPOvgnrnQPJ/Bp4o/vt48B/VP/xeUI8cyP5XwZ+2a/xm1X+cT/1xKPu5Pugr/3XM/Kt+YnwF9c6R+DeBp4sqf9qP9gn/uTZ+6smjmv6H4MsYL3x+d/6Rxs/vRzYfU80f4wMXqj+nzP9LtHf+s/RX/HJMvND1o+k88LHkrwKnfDDzrfptynqgHjuW/NfAif7HyMd/dH7k46Ee+ib51C/faN+o8Zu18cMn/36TfNfntJS34xueYa9P8VeBm5KPPZqfZfuE7/b7V+P/rY3/Pfqbav0wntk8xuv8bfBP5H/8foK+sv+30+Cr/sE+xdea/eivGe2d75j5Ogz+DP+jnjuR/thjL6vy0W+2rMqfET+on04kf198rX9+n61jvpzPeqDe+KLxM5499N3U+NjrpMYH70n+YYwnlQ8m/uj6D/bwu2i+iE/91fT7f04r/N1dIqzq4Ht/e1r/2OPLZ1X/Pb8f579WhepHft/pQxSD77/bLMyS+1/QZ66rstvSHn4V3a/Kwac/H08/9HfMXUAd8Tmf8Ksokk/95lh8149T+XbwXZ8u/M+S77/vsPhgTjX74o8D+6kFfMbnu8pNjc8pyLDGHzF/uv7m+pyGPPiOt8qq8Bcxn0XYz+3hWeawxmcV9Wp8j+Iaf094Gfw8C/5c/GXgZPyc6rStfSb/43fHZ+KvArc/q/wO8tY1PvZaiI8+32kf87+LCoazRfAZT3ZZ0x/7/DDclf2mgbOV+A+Bv9f4zEdH+s9Dn2T8jhnPafBdH/rrin8RONP426eBb8RvB25r/PTXo738r3Ma+t+KT3/XtBf/Z+BsG3zHDcP34h+Kr/m/A5v+eavKd/xQ44N7sj/j6dNe64/f83nVf1y/J8ODOt/0yRc1PvhRfMbzEvo6H/sM0P9SfNlvXeOvo73zGU8/q8p3TH9vwXd7YM+B7L80PKzpPwCvqvo7Rv+h+G+Bc8U/tyfz/S5+P3Bf+r9o/Jp/9HP8S3zw75r8jfiKP6Ms8G/x1+JLPvqMGG8z+Pzu+El87L+lvfj0NzZ+If/z/pD/KX4z+GPp/xG4kP/Rv+NEPv01Qp7z/8T4C83f6CFwI/gF/rxveCL5jcCF4oePpx/6Op/fD2r6f4qv/DEW/ic++KvhqdbPQeBk/GPGg7+txOf3Y9pr/PQ/pf26xidffKvxVzX/Q59ZFu3hT2S/pvjgV/xH+mPPGfaS/07AzNdJjc/6nX1W+fMs2id885dM9ZP3T39zjb8ZONEfe7bb1fG3mU++F9PT92+ph8Bt2X9u4wdn7Srf8WnIdz440/cfTpFv8SdT/m+b/2XUL6fhP7v+zB5t+a/zx9He+fZ7Rr7u6fu71B9n6Kv8iT5t87dM9U/G90H4/tKZ7H8ZuK3561r/jq/0/RDDGfn3XPqPA2f6/tA5+ls+zGbSfxv4XPNH/wvyv77f0eV74OYPmeqH/NK+7/xqz08sxH8JXDTj+8/P9vxYx+Yrv2jF9zfs+9DZufW3CP3z7/b7oT1/1tH8F3wP277nkqX1z5T7eWz96PkJvuf03frrLKr8DvN9IfvzfQ6+F/Zd9r8P3JH/9uAbzooq37H8dzefp6W9d/UH+ps/ur+4/VfhDxfy30HghI8/dFbV+cvs+1kZ9UpH4+d7Ul3TpyN+d1tibw+/Y/OfX/O97GU8v0f9AO40gv8Df7DvIWV3VX6L7we2tX7h/zD9O80q3/Ek/Be+9/ei5wfB9Jfp+30/vJ6dcv9MyMcfwZey313gwSb8j/67Fn/yH+F/Lft+TUb9Uej7Rff2+9z8r6v64WBb4v+0L/mZPY+ZkQ87+n4h38O7MH278l9+Byf6d8l/fM/xSvqTD8Bd1V9XWYmz1xqf79FJf+d/9/3HtMon/mj9OKbe+Rn5w/sHdxW/rsz/uuv/xafe+qn4swjckf4/8V/i9bn4m5Cv9Z+9S36N38Vf1jU+9c51VuUvaC//5Xdw9kd8+qPeuRGf+u2a+WtW+b1WTT7xgHrkp+aP/c1NLf4RD12+6q8O+ZD4ef1Q5bt86T8w/8uXOfcXRfy9CZzwGd9NTf95xLM0f7VMvy8m/zKpv4l/rF/VTx5PGP+1xo8/Psd6d/kvWv9aP9fgcXX8A8sf2VmV7+sLfXqq/8gH4MR/WoexfrV+fDzYP1m/VxGPMu3/ZnaXUcalh5uI/8WhnRqCZ9z15ed3dqo7s7tAs1Gsf56v9uepF/H+NH+e9BZ/Uf455Pk53h+q+nfK+ziot/T8afFg8m8Zv+x/aFcVpvaUSvZVfHtKIqNePZqH/rxq8w75Wr/H8G082aH4dldLdmT4JPj5lY3vDvnKHy+Wvwf437Hmb2WYeu8l8seOb/brqX55sfkb4K+qP72/PcN3yv+Xxr+3+eqp/uT5xqm/L0fzNw+81PkZ708Az/T8/6vp3zf/KRaqP+z59fyn4aXk3wbuy/94Hrhv/p8r/0838fxqIp/nM5c2/uT54QN//6PJ1/Pj/jy5f69C/n8XuD8P+f94/n5u+nZD/hj9qWf/hf2Lien/gP7yn6/+PkjTX/UHz6fvnl+X/jyP/2jyJ3p+lefp+xb/85H423j+/lHnj7w/6dHGnzx/f2xLpU+9ofO7qa2/gk9TPEn+Gnxa+uvu+pn5z/jQ3jeg70/M7Og757zqSeuXo989O1rty3++WKd9W/8Fnbr+ditBTj37waUCv/5jv6+oH7R/PrCj9AnydH7lz1Pz/O9K4+f9Ayvih96fwfPBA+pfxa+RXSrJyZd38f7wnEsl6DNQ/PizLHGu/NuzoJRxaehZ8Z9LTc+sP31/647+Lql/kvVn+Ir1m6w/w/fsXw5VP2UlziZaP+ST42if8Omvp/2v8/HXK+l/SP3J/kP1J/Hg3uu34PP7wPcvIX+6jOfPXxP/CTxQ/jz293fZ/Ov9h237nnLGpZ1X2S+z9/++cv6o74/O7f3SA/RNzv/s+6M59dxRfH/lv63W3E5u23Z/Vshv2/uJ6S/X+R/vJ8g5z1rLf3mfD+8vGCp/Hfr7IE1/vT9iyvtTqfdu5L/cKveGfMWPI95fa5dG82fZn/dXb2v570es304rxs/7MVjPyfr3fEj+OIv6vTgwVd4eyny1i9+2dHqmf/6i8fM+KeJpEv+IRw82f33tv4hvQ4tnyfonHnj8e5P+f2P9DZR/jufl/Oc6P/R8Qv69Fx/7Mh892Y/3k/Qtn+bav7O+fD3Jf/7bOpf+M1T+wD/wh9T+Lc2f5OOP2D+JX8Qz5qMSf43PfnAl+71G/OzJfh5PkK/z+94q4o/ih8fj288yXu/k8zw+7wvU+TPrO2c/eRf6ez69Z/7kv+eWv9q2H3N/8fXXCPwi/cnPS/Kf6v9DC3VD6k3VPx4PqcefY/37+H7h/xr/c8TzXOfP1Fc557m/Qn+vp6i/hopf2GNo8ScfBx/98szwu+R3Aw8Vf8jH4FznT6xP94d3xU/8gfXT0/7xjf4Oq+vH54P9mvKP25P6b6D6bwW/WR2/24N89q75G4c9Ropf5Gdwrvrd8zn4KebP7bFhvPIfn0/yn/Yvvh45L9hI/m3gkdbf62mJk/VLfZSzfn/Lfu2IJyPlT+LJiPnS/od4mlOP/5b8p8DJ+iceEI9z1e897Ek9/Uf7H+rRW+TL/4gvI+KHzk+pR/Lj6vr19fyH9vI/6psR9v5W41P/fMj/yC8ftfxDPhrhP6q/iU+ezz5kP+rDj5DnfOpBl6/45/GwH+2dz/kr638s+dTT4GT+iU9eD2r9uz8Qv8eKn+RzcK7z+yHrfxnjdf6zxq/4+aj51/6B+c1Z73+0/28ETvZvj7L/VOPfhD0S+7fCH8aKf+wPwMn+oW/9F+Df0p/zY/YPY63/h88yfhQ6/6a+d6z85/P5GfO9sx/50HCh+wcG7fA/rX/fz30+VOeP+WQ/WGj/0buMeKT45fH5vRY/ic9j4q3OXwfziN+f0v884lky/9STI/b/8v/BOvxnI/v9DH/qK/6SnwfYS+vf7dEPezmf+dg+VO2PPl5/aP9EPe94Kz71wF/4Sf7B/mavQuvH4wHx46/GT/z+l1X9x/0J+yv/DDX/fyX/Iuw5lv3Jz9gvmT/yY4H9/mn9ryN/jmW/X+iDvZL8tY31/E/6bwJP5D/kQ3Cu65++nr5EvHP+H61f6f+h+KXrt6NG4F+qX/Kw30T+w3yCC60/4nNxVrP/YcT/ieyPPSbjsJePn/nj/LAhPuNrIF/54x3+orp+fT1Tf+1r/v7Kf7R/3wQudP4/wv9a0d7HP4j+kvWDf4w5f1D9N2I/fFGz/5fIpxPVX9vP0n6eb51Pf/j7V8W/RuTvifT/jT2WEW+djz2pF75q/P8CTzT/3t865Dkff9hW67d8T/FP/vcZ8aPQ+eX4MvBf7R+7gZP4t9X8af/q+QR77Mv+neBPtH9FH3Cu69f07/FH8+f+dJCV/rbzn6gHCt3/4v4wra0/6rFNTT75xf1f8XcEn/16Q/KPYzwT5f8/2G9T5Xs8ol470PhH0d9E8YP1NTmsxi/iget/oP3PPMYzVv7y9dSM9eL8dtgjsT/17GFW1b+B/xsudP3F8V20dz7rY9/wVOuH9QRO5p/4WNxX46fHh8OHUt/d/lXxQ/XrxOJHQb32Vfxz6Z+M/7McT6K/93cX8px/FutxKv9hPqbzmC/nEz+od480fvxh/7PK39f60/0fxLeC/cphsn+L+Zwq/jnuR/vd+XXgZPyM5+C0bL/bf0t/yff+bqv6+/nQC/JUv53b+cSU/eM4zo/adn2moF48knz2U8fYT/unI/pj/Lr+M2X9kH+Oa/xv8Dc1PvO9EZ/5JF8cy//5/Rvj1frx/vD/PzU++7lv4qNPMyv13Z1/cB6JvRV/0M/lN7V/YT02uX6n+Mf9BDP8TfW73w+AvzdVP/r9CMjT/HN/AbhQ/mg3Aovv12e5fjtT/nm2+QMn1w9mfh5keE/+R37ZQ1/Z/+SzxEWzxj+J9ikf+Y0afxvydufPhsk3X5LzZ/h+l/pZyf+SBc7ay5Tv+MtDlU9/M9WPe/D79Cc+9YvvZx7i/M31+zR7yX+zzH5fGL8b/NbccK9dXm/x86t24MT+8B33a3xwdtqv8DP0uYnx++8rw0PxF8HPP4PfEV7V+Oua/pdn5frNxOf3wvRN1r/rA38sfsP4v2K9OH9iv/v8HYb8wuTP/C2MVf5/UczkST78FvaS/8FvNUOezx/9zaO9z9821mPWDvnNLPBc8lvCYf+MfNJ+6Ffmj/XURd5Z8LOx8UfYO+S3zg13wJuQ32Z8S8Pfa3xw56HGt/bZvMrPbL5aP8Tn90vDXfnPQvx18NHH8WWNf1Xzn5H6k/8cKx7Ogj9dRvw5VvwgvjOfM+U/+B7/FL9m1IPUu92Q77+Dk/xx7Pcj2/x/BD/bhj16Gv8N+ps9M62fHuPHH+81/m3gflbl97Oq/ZyPv94FP8d/Hmiv+VsGTvjeX7Maf5wP7kv/n2Dmbxl8xpMTv56CT37xfHKh/MH+fWDykvtnuJ8mJ16sxOd+FOr3Qcj360nEg2T9Uw/0iOc9xc9x+ENT5/c/wp/dXm4/6y8n3uj82u2BPQeyH/Oxy0fBJx57/H6QfPIR9XYhPvHwxO93Cv6FX080fZ+D7+v51XA7+Lv7obhfWP7jmPXyKv/HPsTDpP5hfIwnyX+eT3f3e4f+68DS3+dzaPOXS3+3L/YS3+Pruho/i68Rv5Lxf/H7v88q45/t7l9f2v3iwT8Jf8jlf97fZS1+9cMeSfy6YD4/a/OP/yL/RXz0v0W++HeBc8Uf/DlfV+3v8/FW4+Pfrr/4xAefz1+aP/YX1/BlP+LLiPyn/QP1YU4830g+4/tjeKT4+dvwGH2V/0bIZ/4+a3zw+KHGN1yMq3zH2+AXxI+G4YniB79P4Ct/oE+xCH0T/r9o73x+n9h4Cs3/6CHwh/RnfPvR3tcP51tT06et+tnvByafHgef+3kdT5V/OT844/5p5U/uL3bcFJ/+wFOtX853uP+zkP9RT4OL5P559P9i/Lni/x79GW6rfpg9BP4i+x2GPaY1/ljznfD71fmHn1EPzWX/Q/BnVb7rY/OZKX/4fBwYPg35WSa+1v8cfbZV/ek/o14ciT+M+eso/55kYc9rzb/1l1Evfkuf3zB9mP9L+Q/rYVOVz/ra8VU//435LLbyX9lP/lPInon94M+y6vpxbPIz5S/6dzzW+mU9nOL/0t/9iXhyovi1CZz4z3XgXP47lf5Hko9/vNf4JzGetvY/M9a/yc9y8e1+ptY/2++did8IXCzi/pOx7f+Kvl0vHog/zpnvKt/78/Ub8okP7U3EG+dfhv3OZL9G4Lbmb5KVOJsk+gdW/PL7Ky/8fpngnwl/k//Z/W+tfe5X1PWTre+fzX9lP+5P5X7OTPWr349K/Z/cf8r51QL/7wff7+c0nOn8lPvj/X74hfSnfv9u4+1o/S3QB3stVH+Zf2bU298fanzk39T4hrNxjT+u2j+j/rpAvvLf989Sn+yn+PRH/X+e1fimT0fx/zz6S+av1/f6cWnvFwz7/fX4be3l/zf+/E3O/IZ8/IH8/0Pjp/7+gb7yvx9hT2+f8JfRPuVbf91WjW/9ZapfOrb+MurJS8m/D5zK/6SejvYJH/mXkv9TfNnvinoc/VX/dOfBvxJ/Fbi7qPHxn3WNv67JXwVOxv8TPvOn+qe7DPxT/HXg7rjGR/6b+NiD+HUp/2d/znrqav3/9Puxz1rp8yN+Pzz54lr8P+5PfVufwb82e/bIV6o/uoehz9VDlX9j+vb6NX6/pv9hzMeN5P8Vf5z4r2HsvZ/4f+Cfdf5n2X43fvu9t6ja3/PRtLr+Pb6B21r/t8hnvR5KPvNB/LrV/H01fFfT3/mraJ/wqRfvTqv8m5r9vT/kK//2loHvJP8wcG9b47Ne/4mP/1C/3Sr+kP/u0Vf10z35iPWm+qPXCPnJ+OFfIP+wynf9ZzU+9cid/Ae8NH36qr/uP8t8mOv8Cv0y6r2zOh95ih/0T3+Z8lcb+w1jvGX+K3ESP+m/varK9+cRyEdL8S8Dp/nzs/Sn7EL+z/w/1/x/q/Wn/HFJ/GS9aP/l8Zh89kN86tFFVs7Xbv1xP+Sman+ej3F/vNb8Ex+IBx3Z358ns/WWq/7h94z670ryTyOe9MQnP3cZ/1mN/1yLv6xH7NfR+j0PnNoP/9mEvZz/W/ZL5Gex/rR/JD5mRzX+QvK1f0E/t3+i/2Hkw4Xm/yzmo6/4tzR+3/TPO8Hv2/rLqb8fQn7O/uIR/7+s8c1++aDG70T7lH9aynP+A/2ta/LRh/rnMfTP2+Jva/xttHe++V/O+nnS+RX9t+HL/x8C57Maf1bTvxP9JefHK/t9YDiX/QcWH3PqtWfx54EHdX4/2juf/qhHnjX+08ADxf+V6TNYRvuET732clrlvzyU7VP+qqY//EW0dz6/P6Gv8seK/mz95qo/fTzUjy/yn/OYv4Hmb2W/Dxohz/nj6O/xtMp/fSjbp3zmX+evA/yHem0t+9P/2vobyv99PhrRPuEvo33KR77iN/4x1Hpx/2E+qLfexCd+P5m+w3mNj7/p/LbPfLB/epX+47BnX/H/zfQZsv5U/w1Zn7zvTd9vyqlnfjH+dY2Pvm9Vfk49UjxU+fQ3lP+9cR7ciP268+33gvsltH/PX8XfVPmsv0L3v/p4qB+f5H/wT0Nf5/8in5CvFD/43fEvnX/597h4/6b8L0cf5l/nX3zPy3Hy/S7478yX/A/7uD31/kPuvPHvZ/2S/29Cn7bWD/21eF+p6j/0cyz9ne/nN/MqH5z/Fh/9yLfaP/vv4Lb0fw+cX1b5jt8fqnzOkwrNv4+HfK/zJ19PrMdXjf8u/Heg+sHX86q2/ojHN7X4cR/xb6j6gf7Buc4/B82IP881/ob5a1X5xNNc+Zv8llM/6Pqxr2/if1/r5+Eh1v9nle/Xr3X90Pnks/5Nld8i3mr/7PmU/PUo/XuBk/hJfCAe5Kp/R8Rf6unfih/sP36bPiPl781DifODGh+8+azxrb/RssZn/vZrfOrvP6dV/h/4st9v+Oiv81vXh/4+xGf/8QH/psbH3/ZqfPAf6X8gvvzn92dg7d/pv2jVxg+f63Fj+c8WbOMt5P/jduBPXX/m/PUz2qd8W7+F4pdj/OVT1x+of/5af2Pt//+PsbdrXlUH3gW/yqn/rVMloiCeqnMR3t8hICjcTIGoICCgouLUfPeJYS3i2ldTtav26h80STrdTz8dIsHPt77+J+r/0Ven+3/1v/ayov/of+dPJPsH8PNFnK8G0r48ySbhT3g8WBat/+hj+UXeX2F+/sHtEfzB17EsOkRfm+TP+z/677/j/aP/le3vfIge0cf2wPyNIuPH80Hlf8f7q4/v9/+jj59HkfnfTP3/GT/2TzP4d/xYFjB/X5D4W0yyReIXP8/G80Xif7Sn+a//ipjf4e/fSL/75754jN+nkP3bNsZjfty/96/+Ao+XxC/WtzFekf0DWF/E+O+Q95f4Ou39Rx8/7xvPYkz0cfxgPKVJ+9GkzxP703j8+P39gejj54/3v//VX/LTeIn++DySv2zsTzjfLIk+rodcvH+QzN8S5y9sT7L/adTH/Sff3xn18fPs6F99Eb8vnRF9PH/n/7SP+4PXMxyCH8uvfRxcbxL8HPWLr7zy/qOP61f4rz7+ntB4/6iP98NgPvkz/zj/rXD7P+8/8O9Rwb/64p/9sOff7y+N9lhN8/2Hv+Hv/+PvfZL9A/h77qN8m/jneB6gin8kTL7fOJ6viGVy/gU+D0zE9ffP+Vv4+84Qfz/15/39V1/G398k66f4PKRRjqb2x/NkEqxP8kfK/5V58v1xA3+/G39vlHy/nMffx2Xxeif5fuV4nhHeaUD4t4rPH8LPY3/Xz/4+7+f8Fnyei1OOePG3fYHYQyDnzz0mWSTf78TnkTl4/Zp8v3g8Dwzzf5bM//g9X7z/gJzfssL62r/2M/H3SHE98Cb8n53675D4XYzf3x399W/74/eE95O9xvbVr4yf92P/9zQfP9+PHr9HO/Jh4n/4e6zcNN5RH4z7QX1sr7/xN37Pkx/3f078Px73j37jhewfVqbvb/1+fw+/34ym+8fx4+8v4/M7HBJ/uL50MP8g/AHzSxHXD2vCX84T/3QI/mB+7WD+Yfz438S/f+rvfpIdwl9qfuLvpP4f8/lryvej/fQp/7lk/WHw/soi4c8WxvNhnP9JH/MDDu+/I/gx5H/l8f7x/S3O3/h9H0XwC+ML/v6ZS+y3+urbuH1iP4yHf/Iv8Z98kl0S/xgfsfyLnxJpn+AvJPyB2B8/z8L+96MPJv7xw58g4V/Ef9fjfsDv/aT+wvMrYr64Ifbrp/l3if4on6f7x/jD60f4fcaMtI+vz7x/7b95T/rk/TF+vvj5t30Bn9+Izz/68V98HpOJ8fJn/Z6b5J/zl/D7q+Y//jf6A7Y3Wb92sf0wX+eI/bF/zd5/7fVHf9xP+6//jPZc/xs/AH8P2Rm/dzzp4/NFsSyS9+/4PM1RhuT8BoyfDK6XyPfLcX7C8s/48Xkm4p/65a/+HzwZ188nfYxPOB+Jt0kfr3KM+MsQ/L995cV/8s+Yj87/4t+Ix82/+WvEVyw7v/b7K//gP8b3Uf7Bf2XKRyo5PwTjMZZFsn6PzyMXx/0rZPwYn0aZ5D84fj/6X/yVLPhXJvg7nmfKjvsH/X/1Md8i9RugvL/y/Hf/L/wj8+T3T+P3iF/eP/oYj//4I2/9Hf9jkn/8B/sXln/wG/OhEf835P0DmPIBT/aPj99z5MbfH/zVH6/z0utXf3ze+D1faTv5L55PHE/k/Dkb14fCV58j+OkTPNMm/Wac3+3f+Rr9VyPjeU/jH/dneNafeudP+2N+/+qT+lsk80/0x+8Zg9z6p/94PC439XfsP34+Hv94P44/3J85/7e/f/wX2x/rS5P+mJ+wPCP4Ma6vfJ/nEvwZr8Pv8wDRx/UllufE/zekfTC1j/1p9N+f9leTPk/8x5nqX4vUPx9Sv5L3D+N6CPef+g/jc5//rXdGfbw+MsqXf/VH+fn+Vx/LJvFf/Hy8fvJTP+J6cmz/p360J9ki7V9xPAdb/L7gr//h86HG86R4b5o/e5J/zq/D59mN56nJk/3G83WVr0zOPx7PQx6/Rx9N9of4/NzXiLd/28fno/L4PAx+8r/xfFksy+T7//h8ShXjjTa1P57vieWf8z/x9/fH8xd/zi/E57nh8/vI9/PH89AxX5fI+m83yTw5/2A837bc/tN/PJ7x/Fthst94PgPuv034Pz7fA5/fAFQSP7iewOMXpvgZkQ7LNun/eL7L+ds+Of/Zwvx7O653T/o9sX852X89yeKT5A9cf+DfG/KkfWwfLLvk/Bz8ffDx+9nk+0vGn98/vL6/H5/8F/uziPtzJ/iF12+DMX/8HT9+PzC+f/tZ/8f5VcT+R+Ifr6/z+DwZe9I3MR/F63ciwR/Mh8Sv/U3Cf8b1vdW3P+6kb5H9+z+//8HPk3D/V1P/Xzi+MV5DMn84Pr2v/FM/H6b1jJ/1zyVZD/WI/n1az9BI/I98BOcfgr/4fRKgtn/fN43rx6vxeeff35+N84Htz5P8IXztwX/x8Gf9epwfH98/2e+Pfv73/j/zj+2B+T75/gO+Pso/8z+up+N8QfZPd9N5ZD/xZ+DzDM3/4E83xe8P/vTTeVg/58+Oz/tM94/xj8+PGfGgmfo/nk/8lXly/s44v+P4Sf7D73NsHC8UsR/+PcEf//87f+P5AsFXFsj3b/H+WQnbG0769rd9/ou/YDfpj+fLY9km/Aufz4bxdLx/xL/v9REPDIJ/5YR/FDm/BMf3eJ73gcQ/vv6Nf56cP4nxif8v/hA8lgl+4fFJ2oT3f/xnGv8P/uPzyWTsf6T/0nvCj5/ff+Dfj+B4kMnvx7bj/mPpH/+X+UneT+2P84FlieQP7A9vbM/zpI/xhD//Gz/j/GL8/7G/Pc0HT/TH9xkYT0j74/uRsX3iv3g9S8HjJ/jbjuuhX/kH//D6cTnd/9f/pvgl/ivlk5yS8WuT/OO/OP/J+b/tj+PBckT6j8dzwPaf9AVqwk/+RexHxpOQ+eem9lXS/+0k8/ef+Z/kgPTfmubzRx9fV97/+s84nvu/7fOYX4TT/aM+jiflP+O3znj99LtfOCPxp02y/7P/GE/C10ckOO2fzsj6A3l/i+txvpjq9TF+8P63G96vQ/gjru9lcv+oj/cP5v9Zf8H1Md4/qvz8fjH/Wz//6APye8bLb/15/vM+6ef9TzLJP/tXlfs0HvL+acyHmH8K5P0V/j3b+P6M8Fe8Hw0cv/Y7k/oJrz+pON5I/sS/J7Tx/eT91fh70tPo71P7eP1J+/qDIP3g7/c61j//4O+Yv7/+Q/wXr4/t8P4TMv5qev/Nk/cXeD/zuP5C9t+M1/H+6Z/3z8x4HsYW/P7+Hf8eHtnj9bXPhJ/4ez54PAKpf/zv9zeFbz7gdfL7efz9Vvw8fcIPpPhXFkj+wPsJNcxX6mn84/5ELOtk/Pj9I5aF87/6WP7Zfyh+vx8HWmy/qX2wAX/nTyTfr3Tx9+fgdP+4foT3r+HnGdP4x/2cxrf9n/cXp/H3W9/+3Ej9hddT8PvLhPj/edIXCP7g9xlYFon/4fcrPDXdP+onk//YP++f8ul9yJ3wr2aStQl/0PyA7++trO9+TzDNH8T+/h3/g9ifmuJPIvEfT+3//H7W+87/+DxiP/Ca/F8j+Qv7A/YngeCfD//6z0/7KuaPzVcm9h/3h6pYn9RfGM8EnO96Ur/h/mDZIPNfTf4scJM+9kcR88Fy0h/79/zKFsHvDsvev/OH+zfKZP5Hf2im+0f9yxTPAuEv2D7jeAqij+Priv2f8FdsHx3jB8Ef7M8CzgcDyR/UJKtEv5zG86OvEXs+Sfs4vk7/6X8zxSNP7DeOB+PZm+i/Jlkj+vdJFgj/Vsl8kPgf8RX33yT5D/uX+b1fJPwfXx/lF2l/NckWwS/7+/1NA0Tf/aXKX/0ERt/9nl/588M/J1mBh7/60Vc//coiwS/6+31vLIsJT/if+uWLPOZbhD9Msh2of/Xf3/5YuH2a1G/wKy+/8vN7fWxf4s9f/v4dL/Gf9tt/Ec8X88O/lL/yddIXqq9+C6b7sX5x/o4H++uaxH+j/pUL8Hf8gvHt/x1M94/6r6/8nW+B4yf9+1d/89V3p/gRTP7v80RSf+xw+9/54oNJX8btz7E+wd+E/zsfIvG/07d986Xi9ZkJPzgV7x9A/z5N88fPv/rw2x+J5N/ztz8Szn8iGT/46m/w/T/4g+WvvymUSsYfffPHFu/XI+NX/so5jMj4v3wG/r1/1A+//ZO+8ceT9RP56x+jPTwy/hDL3/al89T+FT8P83+b/5s/dErBfOXL/4j9s+917A8S4Y/0+a//8vykL5Xf9rVvez5pX8cybl+a2vdx/3H9aRL+efi2j+sBZ/I/sPw+f4vzD8FPG9tP+t5v/8Svgt8/vL7vh6f46bE+xhtuil/zjP15un/U/7YPnt/7A4LfVyxj/DlP+vq3ffmLRzxZvzCx/XC9EhD+scH6X9mAk/7za3/zNd0/5l8c34uv/HpN8SN+9bE/iIQ/vb/+J3/tLwyT/1sQ6YviVw7J+ps0yTLxn/13/PLXn0Vxmr8R35ppvH/eH3/1LYyXJH4wnkm4PxTJnxqOH9wemX9hkkWSvzE+YTz6Gb+J9XG9ExL74fFh2QTEf7E+rt910v7Xv8d4IP6HqNJ3/nH8kvwVggk/SP2O/YPH62Fk/gXszw4eP/XT/7/49Ysf1IQfP/Evf9v3MF8g83eZ4o8n6+/Yn0d7bsn84fncffsjE/th/8D25En9ivPB6I82ab+c/O8HvyGev/u4/jHZH+MXrj8dMn/YnhhPZBL/GE+wzJP6UzpM8k/8j/GI+0/q323+V+YPRH81ySR+RzzcY/8l8+cRmeRfKRjXs/7e/6Pv4faJ/+J8Kkf/2g/PD4/rN5fgB54PjN8SmX88PhnjF6m/JCL7P/x1mk+F5A9sDyzzZP1CxPbAfM4l8YfzaYTzB+Evoz/i9i4E/zEeY74Wk/GP8YTb/8kfuH1sL7J+I+PxYz4Vk/7j9YvgO16F8GfsTwrmEyvSf47Yj8w/zo8J/6/9Rnvi/NkQfTyedhrvOH52wgPlx//w83D8dMT+cJL3RB/3L8H2IvoO/7f/POHfMrYv5k8pqX/8Sf4ZP44H5TseVB9P7ePrM3w/sT9ej8Hxq/zgj/dX5kn9gO0z2iMi+hiPUhxvhP/i+JAx/hD+jfGJf/3Ln0Y+FX37qxJ9PD84fvif9R8ik/6P/BLnA5X4L8YXLPOkfhCjSbaJ/+D1WB/r/9T//F/5Z/5GPKem+8f2mWn+VOK/ED8P+y95/4r52YjHGfE/fpJVgp9wkn/8D+dDHr/POBD7Y34S/Wf+cHyP8/ezfn2Yxv/jP2N/cP9/3/9Zf/PHkvSfjP9A7Lef4vnH/3F+UnC8kfppxLN+8rfRfhx+HrY34f8x9l/cPolf7N+jfCTjrydZ+dGf7PGDfxhfePY/+FNO9lN/3j9g+98nfx31tQnPTsR+xSSrJH/s3hN+bsj48fNw/O2JPsbXE/YXMn+4fyo34c3YfjD1/0Tsj+vpMx4vaR/jo/qdD4Hkf8Wanncm479Mskr4a0T8l/R/HA/2x4zo43x4zv/O9x/+xv8dj0D8f3wejtcz6f9iktWf+gm/T4T/5u8xn+P1gpy0H0+yRuIv+fZHi6Z8++f981fG+Tgn7XeTrBH/x/ii4fqD1D8jnmL8Kcj80VP8aMT/cTxjWSD114gnOH4KEv+fSdaI/x4mfxJI/YHxcZQz0v/T1B+Z2G8/jUcg798xHxAwn7uQ/ieTrBD8xfigfv1dIPULjkcB86Uj0cfrHxdsL+K/hwl/f/RxfI/9L8j8vaf8oZH+j/J/28fzP/+P/56n/v/EL8ZjjZvs/Wf9fIqHC7EfNcka0cfxqIMpXv/w52k+SzJ+fL30/vb3j37+V18g9ZcWTPOR//BvrJ//67+jP+P5I/UHjk8B852KtM9N8g/+YDzSpOn+Ub+c8LMi9mMmWSf+f5xk4Xf9YcKfithvPsk64e+nSRZ4Mn5cD+7/9b/RH/H4deL/R6yP7yf8ZYwHLBek/sL9q7A+mT+Mh1gWyP6B0R6YT5ek/6tp/nSSf7F/Y3/+mT/sX4L17/gFZcIPncx/MfnPT/yPeJD+6z+CPo1HJ/N3mfxJIPU/xgfhMNlr1Fcn/NAJfo/PI+2N+to0ngvRx++nr95/9PO/8SMQ/jXKyXT/qI/5yBW3T/gXHh8ej3Cc9PH8ChivajL+PZl/kj+wPxrYfoS/4PkZn9cQ/ZDMH8GfkvhfTvS/+CsU/8bPGB8Nbo/MH75uWP/63+iPWL8h84/96YrXT8j4sT+O/Sf1zxhPWK6J/ePpeQbB35qMn8zfaM/zZO9RH+PDlf/Xfrg/eD5/x99M7TdEP5lkneDv+DzqX31sn1Ee5////J//+X//r//1P0x63CzolGXWbLJOuPWBY5n0sOHS9HhcLNf0/81QNJf9z//+X//P/+TJPUf/+P+rgh7+GNrjV0OumuTBrsDtlgzfvz8f5ffP6H9i8kimPx+a6+N4fXwvXZ2aWSnZ41CKK40Fmc/GRyjqtwNLqek2BiHjXG9Gwu0ogWJ3TjzbJxaUlHd/bVgnssFLjV5Rw+nnEjySLL6sxXcCDU8TDL6AQQXOIWjC3euzl3j5bDtrRc/f0JWzNeueTmoOFJqhdzU1XChh85aLWlzOXMifDYvLm5XGgG7LKOaqDND1PaPx2XLbu1DbnlztKcHVBqVzi6Eg018ocFXtUBIugwuNbMntV5zebIDuD3JNH1ZIv8g4rk4Vx4VAMcM1lAKkb9+cHXgYy6hE5dAeZubGe0NHusnJLPO1EJTuPmCL5yIJxK59MGUMMxVaO462gpm8k0Gbnsp91s6iQHgMV/8YzxcF1FOxXJmfct+Cvnic2wV9P1JAvJ44W7LiNXR3873W01vUPzNLTb9bnVD/1nDYaClduND5zO4e/4DaBqzAfcUpm+uFEm8L6YEC+3v9cL4+Ht2A9I+ppayH+waNv/bZ5XKgEhcKz5P11nI/2oB5f6le2am/lCBfevUyqmoHKmvTLuJE0GMwKAv5BrhXXgJFFI9ycet4aL5NbpODmrHBbj9/ea2jXgOxKkuO+vCzFErPl4tsrDE6KIP4zM/qLg/Egcn3VLTKPtDa3xWKUYdYRsip2v3msS1LvhbY5cczFQBdLT0Yh1pqZRDOufczv54PEh/uWn5Zq10CXeru0JXTMQw4xjr1OWz1ShJoaL2fq2o4QMua+SzyocYDm6NbXZcz/hwAajPr25kl7KD8UbjK4Z04A7Pta7FN1lkdgLfcnqjIazkoLm5SftjCtkJMnauiGpXSpRhkgxPNP0cPKteFOrNMMQqBelnGBkjhMRCqLftsUm6zgnyatobmWVcdJLIsGZ93mVN8SfeL9gGPEFq0TM/u/Wz1BvfbgXEe9nCRQHbij9X5xkbQOl5uy56+IP+7JktbUvPsQvHqsrHyq8wi/wxkJ7LYGM3vaWuv2c58HinRDI/mS1MMCO2Ef2buLIxacDdXtST2l6xE9rvsZoudo0A+bFSN6wUN2aeEg8ua4aXkG1PmUSE9c6B9Vdjtfk+tGGB7j8XzfhUuARge+n7gD6wF3e3VvryamaaDWc22zo5D/inuaev2YuSdDeUHM5zm0veos/TsR6ymN6dSaDLQr0ApxNDdvObu7rrW30AeSuYjvHeXQLhtnYw5FQKESnmDwq5RtBYxgz18Lp5CKQmyxTK9QTk6tNo0dtV82djguW66QO9fOSWoVJH376o3oZL1meYVZbMATLp6bQS3KyjApZWzD98zH0pzt19LsNJlwIDT6vThBBRfFrg44dv0DSgtzXkx29yiBQjP7z3/EeJc4tfB7CPGwdGGavjh0sPDXulAXefPXRcEpQTaJIXmUvMhlIw0m2fpLcrAZrVKJE4v0fWNcP106XYIoVscaWbvzpgQ3F7r9BCtPOS/srMerJj1fcgL7Z2F4R31j0oV0e/eTFkK7pp5L3mI+i9T3KHqnGNrg+JxReD1VEpJnFnwrKrXJED++UhVNlm0IThKCb09H/hKAiv+XfqBPwTQ8jaMnd7FGOHX1mnKvdQg/3KFch3t0qMD+ThUmuFuI3wJXmv+Y2kMsk9+uS7mdKC4ULX3cRw2BvK/uq+O+jKI0HVN43OvEhE+q3uVnxlvB+HLR+N02FjLrz77GrLj97rdzcqoeS0iFL9dK6bPCOG7CK4blBfROKFeWM8HvYHo+U9LSHVU3qD+rRqjHFrK7qAelZ95uAESA86DX2xrzk0lQcu4joo39gqa7CbZCPu+agFleq20TX0Un12VrGStznv4/RFg9KD3Sgg+eeXRt+f9KImGWp3iW/q+QrUdOrGZQzoDL+/pd5ZwQvgemtwpPxcbGgIpvBRiqH7zi2Om/Gm7v5TCuW2TR+uj/CPmmrmtL9/rF9UxPPXkoeur/YeJz1s0Pos7bzfvtYXscz8wwla0ODR+Vc8u+vGC8Nl+vSmeZ1xkf3PB+5ElfZD93NkivbX8YwFdLtv0h72x4gE7y2zveGsSCrBHTX0oy4yCvFyfqPDy2L+BE5+Krte9QgLFtjjFQl+oUOeO9EcD/ZIHrVWeqb4rM0p45e5sdpDCFRQuEV0lDk8zaHxA3q2i8ByIsbHK3lIvI/uD6plW7UJlQPLYNsdztspK4Q5PTmDpiyd0mmXPXy+XVQYCzXL2s17MS2EDdze9TsIGOrtqc6W3jygG4p7nH80nP5RCHz+LDvn8gOafl7XYv9IVym6vo3AM6VMJpBZSd1FWNCh7e/d+v6RaDgYp91734y0v+Q9vtuBMIwA0P0k9VI6oLUAnnxeC6Dgov50N8/QYWNaGPPvc1KnBIfz1hS24rkTrEoiJFpbp9cY6UDoofXQ/180DlYvgivI2RPh4LiRJ3vOdC+Xtiga6KqsZEMsTZ3If6iwBxa2Elc/za2jTdRFd7oomg4XmZsLraB0kYTuvVoZKKyoUxFBgSmW158Gcn63jgupzCtwyfrtTRYTvUmUc80u3iSpwYuuTzYSPguL9II+p1UlRoDYX+WDf0Mi+4cY7K0WsnSlw142G113Ev8Rj/ggO1G3PAN5iH8lqvi4CcHOP3jLWeAaa10snZjN3n4H5oo6MG2UfAj6zL7frexh4CF6aIClCr/FAm3/qXbA95AFfrZP9qVIHBboP+/BQ2PdeB3zYvjZ7jcpKMQLyPdiKmzfUCo45dmqP2q/0OQN9LT2h/AAuytw/8AtoMuvS6yRGy4CsqCL1fjgIv4cz1R4Y5vGGwDks7+E6bnSw/uSyx5hvxI+Wr7U2210LGQpc9qkyyV3aANBHSaoVF9k32D1WppbzKP7XnZRvdH7JAJHpVne7bNDzn+7q6qbBoEIVdigJdsNyAzZVithYGJ5L8Zq4nfeYFTa0W2MWtnmL/GcXARCtjjTCf0VeNd29/B6lEh+asNx2iF/4z3BLFdcz4reqPzyoVhokaML3S5rVe+Q/2sfa9+7HLSSR64LBemmJCMVTes42N7jyQHZh97zoKkUpPB83arXUaAuqt+y9TD4q4rdv06TmtmfnkmBkMKCDHumDubO19/4J2a/y/E+/2xuIn3TzKt4rhaBBZ1XPjESvUXx0fup7Qyuh+Ffg8fOOOV+F5lNdra2aQf0zPJZTBmAXJbhpM2/gSlqHip8K3WE9Q/kzK+LZoowWZ0ksFTqMIrFG+MZzl0f54b/4tNJv5YJD/Fs8ut3T8r7+y3uzLub2HsJv4eJqvbH48mteeFGnVNy50BzEy/nVfPl5f3W4vd/Mv/nHgK3bUCg/KEeeCvjlHum/adp19l2IrnM8XNl3BeUfvt7EAu3Guwfw0ke1usjOrhTY0+l5ilHYQ+1Yr11/e25kUHMpvWvB7hgAJ4zezsHjM+h4m5dnnSoxBwEVWoy96MNAXB+HkmPlTQTdetbLsKoWiP/Tq7e7yLIDJdzi5iMzUctCzW6Cbna+IX56XyUHQUFmQ/6phDulgP4eSrLhMX5s6TxIAjpabAWtQvwtUsxivusR/7suragPLaSfICA9xFSO5vfZ6+7FOLAmdHn6wJ58qOvgsaM3/juRqkB4X59zUal6xA+aTtJONaNXCDSahXakl6eSt2irmN9lRAMkr2wqbVch/J9V0SLIz9eSEj6xUx8DRREQPidUSe8txG84+ePsPrZYUiI9nFLFTRA/MZyPvhkUHeWX8vnx19LDO5ZAqOhP/mnZHVSVAtw/7avlwWfpspZTr0qJ3/izuackfQBl7k376wut2WDfrzNLuO8Q/9mGG87QWlRfGBtptnYMHeV/Y5XcACNuET5vJLkujzHiVzZcFbW+2iD/zE3vxrwFEfE/f06v6hrBD5Su5QHxaAbht30Q1j5VsMj/K8+8G1KaoOvvG7UpZqdVCwYtKpOEHhA/AmZqX9KWlqAorRe7O9U1FVDRJPJRH5UBUKLH1eK2OxHy9zoW5fXtWoFg5RuR3bGIRDvPNrt2XfiGfKBVV/ZxQv4byzB+l4sE1VfmQRSMhUy70B3m7L3wAuS/YckrTNxXZ0qE/TZ5vj2dhXIjSVqRfxD/nkO5e4faG8VPrev+TBNQfJmM2lxeURrnYJYcjLk029QliADDzwtWXkPhyCQK/Tw1PPA7FOyxEBSIn14K6301dwYUqNO64awE4cNK2Ann23CuKAF6avmiBgdCgW/6+Zl/oPlz21Y+b7jyIvH0vKcHd1F46PnpkzfYEtVnr+e33npvvvyVd2/tAggelFd81UXGE/lvv1QOutdwZQlWd/BcKMXOhyZNuUp7pWIdLFRf3ZdiiOwL1SW1QkPcQs3fns6fvYiuJ4JSs1EulKVotCfJ3FKGDxX1fqCf0ZcfWeKDvXeyiewjO8GumFEIP9xVIXqOb3/xZYFyJ63ryP7OYlvfjAviby61F4Ap1Si/OqWSquraSQIeXNrX+mDET2gecwUh/0yJwXH2aF4hH6Pnp8buwAwFer4Mj0uYmwFq/72QAjhfIH4rvvXbRo4/DsrPy720WOwDhH+J+7L6nf29flSMk8LJiL+hUqmLsu0O+UcZHMLkqkN0nS8q51GFBur/Zf5RH8tiH4ObPX+XJawOpeie+Q1r06j+N7fgtbjSAeJXquHvrlKpxJRos/mifw8tAwWfjqR1KC0zsI6P8WqVHk8BjwYY3tbMTIJu1urFld2vQmBFR1SWKg3iZ9wxD2IxRQWWyh+vCGpOVwbUsWIel2FRlcBfe9WKMXoL8tt6lW+LW8OA11A8YuWzPUlisTApaZ/GCyho1LlZ3C77FmSI4e8fXJ+XYB14ml94vQaVRSPbHyZC9REzKP1mHsWof8OM4m1UD7+g1YfM895HexssNa567sv4LPFlsbeZmXAEUIyuTALrB+qfGQzh8kzbKP8srfbufehag2agtB67AoifxPvTwedCB+WXJ1dt1tEWXQcDuveQDAgfzJq9gHRIEb6wrWI86AHlD6u5IXTMb9oDcOobRkHqFCVPZY9s9njvTAjUSA/mfYLqX2FRcE21f6H693NPuJsrIn4gLnvgevCGrif1YlEB5ozav+RUdLAXyH8cgY3KdBUi/4DFTb7k8RbNv3HtKi5WUH1gymzWcW38re+LYbEsN1//S2Z9OU8WqH+armUnsfjW9xVfVtdcR9f5zqIY0VZ85J+0+rAzK0L6uqRdaDW/o+v9/Tk8jR3Kn8brbeVmmiJ98b2LU9ruUf/E+iO/NWHGQ8N8X7k6jvUQGMmiTAXZayT+Ojwd+R3XPFRy3nBmadJW4Cp1t/ftENQBz81qZ5Frxxxq6wOqDDrIIv4nPmcCN2hXSdyebx9RuRcof5p75SxEDovw4Wjbp3tfVBToWf5yY0s/hzzkjM4x3gYPaAM8n/vq2QTiINN1FFl0Ai1+8Y4+ZZPooMkySXhTqwblv4XlWSvBqaDtb6/NqtmwMSL17rbbBUNHCbpx/Gz0rG6hfpeGs+IkOgMOja2ECGavFF9Kvbe7ULMIWomjhX3rJihkAj7fRGe1oUDWSi93+RIOEHwW/JaVdNYGT+9NL2m5aANhdUnu9NNha8S/wkqB8hrh1wNsmitH7ctAZCVjo6wOPaov2qrpqBPK/MA6bNc9BU6IH6hz7thTKcqvyrl9gKM8R/wyOp0EwVd55J/Fcu+9vIj1oKJfhZbeu6g+1/iam51O24sEKCr6dEKys6FgVPT25USIHx5vundxzBbVL7HlVuGFntlQ2xXm0gLDagFk6/64+cnlEgiGERyXtonw3RpkfV/rbxTf1Gt3a/TLHF2PD7CiuQ71X9fa4+WeDbEHzvurhjj8CuE3ddc5t3HaK7L/pktsx0D52Tpml0JYlIg/Mqez24fgjfC/O83s9E4rOWj6nXFV5vyBAquvg1zv9g6a88zXuPCLLzsmDqTHaldJAngWiyh5ovhzh25vFFwcvYHKF0YePg00T6b8OnCLQ+dAGVAPIz4q2hu1tgz7YZ15lODb7UxasbwKtdobbjVjVjbY+H0mclxtl7x72Q4LdelFUGReyzXsttIbHLg19RiqQ0gJi+pkLF73Soby+3SiF1EctCB8bII5qmb9EnSHplg5QaVBnj7K+gtKjQ30wG3jS2ceA/7ub+wd/Zb3UNu+RB95ZRiCq6UbvBe2DqoPmIZa+Uc9h+5tc5Psea7wYLm1D2YxmFsJhHF/79YN40DN8PeHrX+WUHz6Vg+05WwbiOHLEHaWaSN+tUmOO0YRrw8wQ+WCWMAP4kcoQapmly5uiH85cld/TowMNm2Nio89TEowXA6P7GBVNyhlt/B+Su/XEFxqN1knVZgEwjpZb255x5yhEJyH4QRXMg8yGCv7Kl1HpaglWzZbQe8GjbKmykO3lBnArk/AXG8eESWcr72tpQLKD6ouXqETiuj6/Cl+litXQDyoPamCdm92ZyjnnmHyyPkzcNs59fx5rwtKdAuBjnyGzqDrcmJ/284Rvqz6c7dMl+6REty5P+yci5BD3S1Wb2vIGVT/XfuddZx1iF/ZttFrjLGTof5YN2s5T1F9LHL5EwWljepj5wViybAHAWrJgz50N6hVwIkSOriyQxaIWRGcxfdtQP77gKEuy/b3+sEVk043ylLwNCBroO1UxK9FSVSe3/cT/atp3dn1mZQifeE2C2WJ8o/Otlp6twDqX8x3+54VNZTf+IDeO/Q+2UK32rQCfVvqGaD35lbgLO5M8c2LfdLHUm+gmJzX61zQUP78xEZ1pEz7FAii1VD1ZoPiXz0dNR8kGor/61ONjNprqkC8u7coVRa7EOqqOWRhPLQxkITmWmr8paYEeS7o+4O7k6DEDctn/1qi/Lnq57Z+elwQP4xvV1k19rM91M/ycFL0QG+BkjnXu7v81sf7pa3OgyeKP36n0iBoPsg+5+pMH+hLfCoBGEC5dStU/ygnll7AD9+0KFDXZ2Gww6oUV/ZzGYtzuYKqb96GQS1ExG9ufO6a1xua39Odn21cx95D451ncYtCgQecGVjLfTnUqD76XKTzbPbmoLWTt8nqUqLxWwfejevKeEogk+zDuW1pGvFH73l283CdAwjS/KV9gkcp1qcLFT6kPQ+lMBb8LDuuZXC+Qkubxet7KUqLQo+OH2ULDbXv7NT8mG/Qd8ebQyVzxP+Xz/hgwfgIoXuf5+gvhumBWfbSN9dwf5f4KBFVYR06HtTuTDS3ERX0wKu5xy5/vzcBnxx2oNkgPor4USg9StVBWSBjeeeYfexK4i+PG+d8qC6HymxlC/YqiN8AVTFqf75LyH60RoXlTkP8SeJWkfuKb7UH5FdMe31QHCjRd7ou4cTv+izzpJiZ/ED57yoEfnUxPyi/y/n7YVqUfYLWo4ieLj9v36C5iEcvTh2UHzv4mitS0JUoPwqvjo9sQweb/GYdwHLXSsI9e7t7KKP874SnYbh/AjYDb1sO+/4ZXgNQL7d3l3v5KRSQ6dVSizobPLjDQU7LCvGb7fNkvfqDgvjFCWZR3H/rr+Dz6rsqXH/946mdXpVgyFAblIuUMTXiT5vhhsha8EH+mzDOW+B0YQ/59Xrnv8O41YH4yim9WFpnCayGILwNK/R8I/U3KrPSIsTv3oWxEn0G5TdlqzN7LVNE6G5nLrWKcuQ/58trZzdRhvjJ5pzfW+FVBFBgmGqWovI0BO3pMy8/CPAk4bVe1lQ+71OoXfT4uIxqBvn/i6c45rysJDG9fkTbioUtVEtgSXaDUjNYVsrj82ZyVF/PHrKSmTfWh6Dut+nqnqP8/twrj2Br1ldKELx2I9tHA8XvemCl5KwgfoSYg29c+E8t8YM+aDYNWAuqATPU8adH+XdHM2yUDTaqz05CImzM2c6Cjnev0qeRNyh/LrvDfbFZI35Qfvxns6TpADp6Va2r7rt+ekSQf3vXHfK/Vduk91eN6l9D3rKLIhKYGDwvz2awwDkuxdN6Kx7SwY8hL0bF4nBy9BxwRlvkMBFQfDTGbMEc6GOK6it7c3Bqu82AxAbRcWMUdSCe+dWQxFZ/gNphUQUB4+o2WNw7ab9qT4UkCnGDauhqs4GOtm0Oh2O1RP6jnM5ldPORfc/ta2doazQ/zqE3n7clhZ7Pv8RouO3uRwlAGk1SmjAoPylpcz+f5qh+ez0ZpbqeNmj+nZk8X8GnYqH2Z/flPF+3LVDP0pK5CS6qf+jUE5fJU0igCFPlHKpNm6P6xIKleaAqSjxpPuL1mx3C7zR+UJUZxy1gw+bMPG2loYQ3yvpybfgNFOjrtpKery4GmatvPlaUd4EwC2lnvgx3qH/rzOS3pwzFR1D6Srj7LNsAWOltFxlxIUMz2psiv1wh/7h410HJus93/Taa5Zu7cuyhFMWRHZpG9wDzx4pHD97dSrAF26V4cJIX1Klu+XHqd5eB1zZcbmxufyvFxYk/ID6I5l+5LbuXeLqi+oUPmHSwLlYVCBa3+Vznp2KH8HEdZaePqz8AKs122lBwV4lfsl4gayKq71VhbhV7zUDzj8BwPUuF/hrw6TaiFeHGppAP7XsK7QeaX96rDp+7XtwpoDSywgZ34wWVMj2x2pDe0PzKc/+wbOWHJEogroRKETpogm0HZj2IH+BTMXcUetdaQgV9K8MiNGxovhtUJZQzVJ/YtGRtenBD+HVat87lCJIzVCSrXh8AjfRlOqAHYRgqCVTNupSYi+BD4fH4SAlrtAtUZ1Oqos2OSD/pTo/0skX4r5m2sy/qDfKf1XCSpHL3QfVfuxBW/I6aIX6umnkr9rGO4vOcxf3i7T8kAYGM/zKeMwoqDirP/evlloMblXr7s2Gg6/phWUZfa0H9pcaXfrM1ZBA3s9taj50yEKTX8y6DW11AfeMPuVBKCP+zky3uVtsA+edmFsz8Yof805RUPwziNeL3KOXyF8WV7ojfnz9d2qrGE7pXnZ/bj8zYgI9lb+nE+dwD8ZAfI9Y/zd7QfVTM7fJmTR507Lo5cuYR5b/gHb40Wq2fUJhnOojaI8KvYb/IWWH2QfhouptlhfAD1Q/Pw2IzvIbkAZb+8xP2lHOTQJ0sa+OTIv+30L838Mmi/PCMXxcX3ENUn5326XrRQr+HDjvPLQA3RgyWkcQy6bVH8eGJ500uC7sY6tZ1TlVCv8pB5rdU719uTck/0vWh7Bd1Di3Heez3dNGGoKkegaUfW4R/L7lX+LmE+BVgmL67XnTWA8q97553ddag+cljVgQJyq9WvXLjAV1H7d8/jbfkRFR/HlYP4BmIDEOh866zAtV3GZgl6yV1OLY1BQZzmbyfn5mF6tP7Vq/CLcL/fSSq4Ljo0fzIih7NTY42oXwXgfKuIlR/B9KyV43TEkGT55TPxLsMGdSk4eS2tYfy17tZpB9xBnOUnw6qytiIq0H9Gc9kulDkB1ic/fvdgvtrKVq608gtg/iFzM/5BR/eWwYwFnVjxexxRfNDX2adZ+1OUJ+t0+oeLhC/eyXz+zLTMlS/zxdWH1SL2QOiLJNXN6PrQnDe+L61CupOEu+fYruWjn2F+IWla+7pYLRgd3K0LGe3qD4ertHn7MT1C/Lbpjc3asui+u7lFx/ncb9S4rW71k6hOBmqH0QmvGsolaP4O1iHTeoj/lAG/bu56McC2X8jXFrxifBLlm+7+XHD3QJw/zhH3lf9K6pfDu0d2R7x//0sM2VgXlqJ3/RXcVdfWMTYcrX42DsT1YfKZ3ZsP9YTzf88sv2yPx81qBjvan0K5qsKtJtC7VbSGeETm7TNQaMeLdRmrlxn1rNG+f0lbGS4MjOK17zN+ri7bkKoudBS+khD9WMWnrkAGJu0FHVQxC+DOwpQonyfazJalYERbSXTau8HVL86xebUWe8WiuGF2kP6totBc5aU8vVeH1D+foQzbdMWArTrw7Lgw2iF+OMg0Tu+MHOKf1pLIV1YiJ8In7t4Xx9MVL+wJ3UXKmqH+M3Dtb10Z9YAWpR/a2XnhernJaIdzsaZfff/HIUTu6AeKL7fHIpCrq910OnZJ3cOAarf3FXBc5CKayhczpf0uXdR/RzP1oq+KLWLJJ4K3Tl7UryG8gIZpZ1vEb7s4s9Oyo9hHogSIny3z8l7QCO8rxXaiegQUN7R2r1T9hyIvfvRsuGO6gvbzLJtVK5RfSnzjhEt7FMWCJm/lEM/LlB8hNfd+XBotQcQludZp4v7iyTQm9e2NHv/i8+UbCcUhfLHkaJc4XZD1J3f2efs8lnPeCis2PlNZJeIP8YUYzt2TKH82R3mju2JfQklnTfCm35H4yuO+/NqvVjnJXi5zk6FhmNAXdva60u/ZnRgsOH1WFWIfwtHTY5K9tUrUIndfbhV3GgBmtv24NZ8XgSCGyY7TaGNAtUnZ+G+OzAIXwIYR5vM3l1KEbbUVlPntQdRVgntSJvpMuA2hbzwYwbx/1ed2ZW1M3RoHfRe+8DnqgX2Yy3sP2e7CMRbLG+aXFQAss++jrZ0F7UgNg6nhbP3ThRfh6o3D3hUf/NecqQ8b4v4kc7qp918fs4kYBSPfRhs3ix0zMZ4LO0c8UNB2y+Fz1Ci+tp+lzeLoh1kgzKCxXVx12JwiGaVuFk8jyXghNlxvtZpZJ/Hd/n4skXzg3JX/arXV8SvKv7xdh51dYGa87yWpcfvUH02aw7gowmIP+SR8kiD2Ef84lnTtWJfWxm8KnVgH/BSokIUxbYsbh0TipxthDwiGS2Y72ZgY+Rv5F/X2HUEFhYSBGrIWIz3ubYAVcHXPfRAIQnDvGhSKhF0qMV7e2WXCMwAbJWt2en3ENXP9blfvofCgbZy4Yan+lgh/nvo12whUyh/d9yjTTU7saFxOhnP7c5G/vFCsegEDYv8n4dbuUHU24JANgO26udo/MuP6GnK3i9KcclFafcBggn1FWMf5QghI6gbxpix/AH577q+vCt+h8bHK2LsKacB1b/icyO93IEqSgEI5REKd9S+EnP7xcB2qL5pXi+zFW9+SQHWUZeFt1dMaHW7esFqFep/yGllew5naP4GeNjUcYbmx5k5Fzukc9T/E7MAp+82NAkZSnGrizC4UFeMR8IufZRf/LStuXapIv/scu5AsXvHgq55uDgeZ6OEt8hraX/z9CrgwULQVXPdGVClsmVCvUVUP1HvdSVfyvgigYKzpXvx9JF9akQUyuGB8DfJwG22s1dI/+6JwGE6P4SmORyMo54j+z1F3xUhy5eUoAu724q/daj9snztwrmH6hPKc+StWswLStBunJBrkLahqKteaHg7dH33uGzF+6ZDz7+loJunlIf8++mkzYWKEf87mffKgeLlgPJTl0g2J7AHKETnc9yFbRwD5XpgaMagjwFvLNe7sFP5E7QXV/81SLDjQU3pwnqOSo8A9JLEhIdXX6D8L/jbZ5p0OnBzzhAG54rwt25sa3MBqL4B4pk23at8aQGaKU7JbqEZ8Jpm1rDpbRXqi4duclQ2tEDzvTrYWh8d8TO5v7FbOhegEjjluustWQa7m1xaw+tmUPyi5h6NO9xnUPQY2b0Eu+0DjbirZ4/N1ZAEc+42uXfzZai06ZldNO8rA9gtW603twZS4vJtz9Lhk6H6tLyb+1XPyTqYU/J8jlDWkfjYdJpVM2dilP9XBps86tAGa/75qRCD9Slwl1e71SfLEX+/X407z9lLHjyG8iijZJ5QAgoFG3BL/QmN61Z/OpRII/5zTF3pwhkZAqaB2ztCvWkgn+2cjQ84uQLc0wk3t+G9lfgy3707NocsdHeXVewzepCDNnSGzZrWI4SPnLbXF7p+gQ4qTULuxKD8sh6OM/vQU1EAtqft2ijszQMKs8PD33MVyt/crLSYdXBD+Re5i7wZxLiCfC+sPsZMaGxwEz+HxIv8vBS2W2jDvHMiyBctPGrNeV8B970/PMx1a5eiw7hRvcoeFzQ/ydZn6+eVB5K2k/3dcZFJIsfWwgcUhQb17Kyz/apudCAeqrn9sROUfzeesYGLcNCgcG7Yqyx1qD74vDzGlN7hkQJgc01fA+gFKEjCfXbcf/3f8N+Wc93lOQWOkmgmmfE4QtU8zrlMz3YhIv3NbMcatyQABd4rvfdVqLizF+i9ZvcGTe9Q3E7yc0q8L00YL2hU/wMqh7eDUCU2eBmXnmYiBfGv99ZvEmM56NC5+EJqzE/tA/AuGzp5uOkkYQbd+Ue5DDXU689q6HvfCIEQU3ncXZprIM6zR/3s5sc9qj9vt30gPRPEX29MuRqUzbEUdnIPUYbz5lA0rgejfh6W3vj+G/a7hBL1d0ofbbVQxvfTG67XkP2X8bDyHjuEb3V6HfyzO4hQtZrL0ajZlQx47bYRSvZUBHwltTf9pBshBK75uF42W1Sf7LI1G/qU8JSEWzw/Jp/SX0CLZfTIvi7XqP87tkzF+tWXAqqZlvu3NHxQfeFo2sIZbjw4SH2yiVOtR/OXihuKc7sPlC/zi3q6R4gfeJf3TJbaD8LvxaZ30md/PKP4N5zrIdIRM+WPcrVK1/syADOmy7W6NM5QuurRMWlnKP/VUSuuDY1C/CPhrt6WptkL5Fer15M6zToZwDnVp5oaI379yLbB8Yz+g9Kp9wx/YSD+q3vXY5CJciOJwlK37ld9d4DOcAkWJ/oeV+Bs5Xe6Xt1RffOWs+pDt7McqlLiLVTrgfSph0U/5EOPnp+eAOIh9xmqj+vSv1ylDOFftzjQipEtET/WXNFXlxs6glYplsG+U/UWpNc2Pzm3T02JzPsja5w7i6CtzbPPRRPbHHhbS9aOGXOV+PdhtffL7/5e+ZisP8+Nj8Ynlu5Ck4zv+70NY7ODv6f3UGPdnl3qNHo+KltmTn9F/QeqdO/e1jy5QbNIKHXm7zvE77pLFVVW0km81rIMt34KHeQ15cYeVCPZANVoP2F7h3dJtEzJeK9C/w71w4sRzPu2i8EAH1J3ew6ovixLk3PPfYH4a4QSFhPR3/kv2svF14t7yTuz+aGzFrMSWuHyGc0dJZGBJl/Y7PDym1JczJ97cMqUGrqLGkUASBMPHGdJqr2uD1QfG0Y5l+mWPaP6mH+vH0mSIPy6b+nW2M9qVN+wiHZfX7sjNHqXCu41b/BgqyWoXtG9Cvk/ZJ+9LAkpdCPLlU1pjeonXrTNljVtNP9rtW2O3dYJoFFTyXVIhRbxl6wtBuHuXQJRXNSfyo6HBKqz4L0qbYjy10r7LBJ5/0b+0fb9m9PtXoMAsut+pmZo/oRhQBjkFBeJTxX7HOcHdg+FxKOl8kzp4bj+qy52iN8tUbHq7bwkQ/wjppfuadAXCP86N3gdTqj+jS/795GLWcTPPuKGzzkL2W9vdywTvMO65K3dUX2fXSGBmv146y4vdx6AD5Y7V+kO+Qfnm/HpMwglNF8eKiVogPDnLTCgTMIF4vfbp/pW1IDNoHG7R0otf/ePhEuDpaJXe0XjUySt5bOjBXlGZqjI+I7vGmxWsX3UrwHIe01Q2j0NoXANzLP8qZoQbGEXxdDblJKIoOfkOFzhQhU9czfcjkj/pZpOHbICit9PRe/iy7IooBqvntW+ktD46O3GRYWqVaH62aqy3K26LXS2nZR623SF8ANe4hfDd+j5bNTP5ffM4KGLuDzdCwPDg2Hfm+7R0MuAd898djcOOwHK2qXeN4XZeojbhavV4XJF/LCV6MVGfQkRdDqPv508Cs3v6/l+sWwZofFdpDl/e/I+wieZH9rr/I38r5ol79d2d2sooQtXQtWlSQWNBWV6wtwwMvAo/LtV8EyL6qN1wAuDP/Ognb+8GTNXGQYo/YtbuUVVS7zh5J7bUjvEX5OwMOIi0HSwbF7zTTVrEP+8reR3E6wQv0U8qYnooohksO3pd5299eZbH26yi8Ci+NDW7nNdnN7xAtR3/mJWp+hK8bZbDEYaf/eXsmpXsgu5DUGX61XK1npB8dvPVaPO9ySA7vp2Pj3rDNVnM41ZfFBNdJQEcXd68UMlc1BZPcqZunog/H3f6r2XtXFZgttFoKT6uz/NPA3r9MxRe1Q/cKJSP9LbKeClLcLT/qKUUGYDtnzf1oYHFLuY0dxdaANBs47X5zEcciiWJ0i/2h3yX6mn4qPk6W3A19ydoqnZDuFDaOyipGHaBVC9+vbxN9mVEiMpyu5A8jMIGmdhsbmA8HfouUuaSVklAeUYHaol1e+gNI9sI7jliJ88OVoVTbBD9R9N3SRGPaH8Jw1KgfxJR/XTtjH8ve/fSwmUz03FR84G5d+3MTSGw6shuAVrJ1C8GMWHVLvii34XMXRsW9uYn1nMAFrOGmt3OyL8DbfXTHxTzh7xQyfJGTphMsRWBHr7MuXi6589tZOZRIJilN+2apMvUX2Wbl4zIcobiR9eVHt+5Ch/CcqR/jRJifjBJ0Cm0ICE5n9p9MX9GCiIX/Xbhew8RDZEg45P+jnskH3kp32Rb/V3/cpZpv6Vv6L656NQlj/bGaXEvxQ+fdRUD6AduI2+M65dBnhEUROZT9H8fJe8h6dzvCL/R/Wlx3lJCwZH1+5pyH7fX7k3LVg4Mxea3bb23mcjicGCeq78OmCqUpCl4d02zqBC8fDat/lDQNeL86xIlvQXP7etcq/DV3+CUiHIwWdTfPeHvD1mnV7FDtlvtgQLflnn0EmepVnTYscAUQ2jlW+GDcUP/TX5AMW5QXA2l9nTzNgFMFai40efRRfw5fwaz9KL/0D5Z8Z7nOqnPLCvZaWDvYfG57OZ2Cb+cIfWsr0jbFrEGWAUCpSZXCP+oR34zdHVCgg1LTXC/pWukeZwWsThfnsvQXjodkc5VBbQzIL1ukm6NQ/2D2YZr4b1TeIlFO5P0aozKEApEFVxscoQkuzW76U9rwKQvltnO1+g+dWuZlXJvMPygJGv/QH2Corf85njzvsZnULnzJzi/OWiBzq79RVlpxT5l5Bnu8/tk5RQPFZRTF8UQwccMNNsuItdyc/ctL2DuB+gBR/Hs77SzBCweSDfLWpzL8XabpLqfk9oaNWzDM4d9fZ9vzBk2y6gWwkR4uSsSUVygSq9aD65+2A8ILTCcNlsAuT/kFq+2NnSCVF94ulGacy6DTh7akdLnFhTQq3dGouR+gYKr/MclWczowXqPZ0fpTaoEL54EdeiwqGGSiiudwvPR3gRoXDRCgcBNG80T834fLoMyrOHbrmqi/DVqazBL5dtF4C3Qc+Kj8dWUFvpF1n47AwbXJOoG5Tou7+p3IRvcxk5KH/fw8yOi1kcAlpaP11vE5cUH14K/+CH/gHaKK+fF6cZat9NlvePknqI38mebayk1HlAwG+7hRe2+huI2f7IHU6HWhIlyZk/F2c0f6JQ+LIRLxC/qP0mqrLtpaMEfrX8rBGDPUAlQ4WtkNV6DOYLnuXMd4j4/8ymeDaT+xTqym54IHMj/5Mgt0+HLq4DEQ5L7cIgqg9BrZ6HCtHHHMiPvcqq+2NbCsWnUQz/47dQSxC/5Ycb6wFalPTD7S61Er+wTWtdQAfhy9uTcrOtdjZAdf67zk9ZRPHmYwVuG81G/PbN36VZFbwf4/v3ijvJpbCGd1SCmtQT2p/PXKkv9ZOa052kHNVDLFLgE2vp3qWkFMrDyTDn69xnQIzSocPHbycQzlqmVdT1FUCgpq/o/2PpPJZc5bUo/EAMDNhgMxQ5g7CJM3KOBgw8/VX/5866qsvYSFtrfYuwVTFKyQBP0fA1eOssDsbXA8PexbeGQsLYVNmNR4Xy7WNTWi5lLqyPmcNxx9CEivHmTskIuQ7wdH9N1t1Bvy9wwborXPhG/mLFwvVeKg98C3CDeM+h49fXow8TOIZQiLIYYz6Fe4BNOAOeUCiIc+HIbeRzNCWoIM2InJrlEX+fQ3AuY+u7rEzdfu5xVjY0nMt/5dkpVShUyPs3n+gE1Xcy1LoQHR3ktg8uXH3bUeDHueBGOUOE+DTCMGPtIzS+2tMW1PPpIz41nIQ6bkbUciqwBeHivAka8SW6bpT2B4gpY+fftRO2SPtY+cqaqoQ69e3qGFieCqo0flRnl1stN1kG3ND0HlAiRWzOus1VgT/QYppdX/T//Mct5iDAAfH9O3b227N3QKZ8OK9hZh/Vb3G4zywXEf9yy5KVBSGtoC4QK5v6J3RBcXTjaecr8mdKmduZbHoPFI3D5tD5hjgn+WKjYywjQ3t9I/oQuvbv/YzO1q5tdAXuLagrZt9YAwr7zaS+1609QH5wg6VbPxfnZRKf98uhED8KNKs8hAJH/pzaK66D4NMC6UfeqNs6UtAaxQGL2qn7P/+bd9drecFlBhafjwjK1VwXnLYRIhItb/h++tYTeO0r/DEa0yJ9ECtXiBD1gvpl45IAaB9nm4TXcdJD82dkClOWRO1NoKl16eiKOER8FTxh7eRrCU328vKxuUsHML3s3CqRTBH/hs3w8HnqB9W/mx7xo/QO5H/FYR1pjuZ/8l2Ko30vgXL9DekEI4QKTNiFl9fiuAKv8M7kwSLWIWhHuRfef9fHSy8UeaaSUH6wC0LOois2oCEKVyz5S+iAMbh6N0j+8u/oPr/eW+9VyLHTeXw24eGA6jURHCSw0gVD2KFo9uYElC/ATY8qB/E5/X18LmZ4GS33Im633d5xAnLMu3x9HJdD/tQL+1YktIoDuTim96ggpjN/q6p/V5bPAImrErOnsyXwLbKhl8B8H9Caqt/57OITnZ+6XYyYCh+BrwcjDUYSZRJdfzri3wUmBrg0NKIOvxsCR4Qe7Wi+MyA+V2qvc0/5AOPvw1TFY8hb4H4SCR8ghfxNJmZnGL+BifK9qY2UKXoC+CrU0nUYWl9a/TlOKrXDCGiNvZedwpWIL8TVPnZvukPW01IeHh0aX5avmZop+BLxgfce6rxwTmg9wh8uDVhoAuZARlRYb8TfxEHGdXibLKiozEUbDONRoEkW/z5nQyQgi5NJ9ymZHlTrXZ3H941nAIhOnlc6Bwr8aAaxSjcHDznD9XH5c6H63oph2brLhi4LH1dP5n/3b/7TB/3MIxZI2Bn0uU3XLpc6O/O76ZgEDbOw5DN4jxMYKVId7v7StPwST0XyW04OmtJR4vP37/2Ese0Z0PxqxJdPrT0FY0L8qn3TG708lgcLilTMFvmRVwLXPZlJE8Vcghbp+pIV44EHght2w6g3n7lAm3b3bc8VAw0JJNhbL5H+Of5P12rvhvjedAIY+fImoLxd6bmpY+j7q8IsiH0qChx4u0KcjMcpUPVeT45WVlVE/uKmiljVKJ8JrxQ7Tv7vHpJ6KYzws4IKkFF5nkdnIB4nsh/vbZDjoe0sNJ0Wj/v67/nBTS9igf/bylWJf+YBOZvkYi6kvQ4YDhNneSoifbh13OSYlXdBFEUvOZpr0gRE29ajlcWZwAXt5raeUu0QZAydEzsvOyBog+XzkdREYFNbvwZgo/o0zerCyvArdyC6232sYkPWAl6qhKNeiBfkrualmvhvYMA9UtKvsiZZyx1Tea+DqjuhdIPgBadEFsGDcvYERcMc56i6uJW0MKP6WAyiCwx/NEGjPdKYZj/o/D+DJCD83ND8xKYFWm0KKKDtSRUPlFoKKGp09Gf4MRRkv+4FUfXLEaDkx5f+EMFffwDv87utvaZBzSrP6nWuDwqE7dji4RZXOIvXH/i8WI2HGpUVz7wrww5wNyKj/ZipW8A9sc8HPCUDagI7My2V3hmwsHaV8mwc4+xDEXO7l04IpWYcMI7DAxWQVaffctHOBf7efqOxCTnr7xm3O7JTHB1/WBdb0n5/zxc8DtOSrtWHUIC5LBS3GyUCZWqL00v+7r8Ez9ftaWYzB/VeO3xsjmUK3Czmfh8uP3W5/RwDbSd8CQKC0yntq3bIXzIsU1z5jvTV+gZKfgjUX75Mp0vxm54A9W/psQ+RpC1iL/nZ3QH1hfoat4f1Fi4WjGEl8vxKvBEfCbR3rehcoc24ZcG8XeQPJ/xpVuwJyN9+wcedz4c3Ql4Ft1STEqTvgrLc9dAhXLS+XWXyn7MaQaG7HzP5eKPkcUjd/TZbuiGwPBFRCjUyApQLfCeOJ4f02exCmQqUR4nqp3D06Y1yJtTmRxqu06mIIDAeIJ3IoxJYr0I1wuIWB+XtobfJxgUMwNszLZPIznA+Wek3HnMrhvLbVbM27yiIj8jvgaT8g/zhW/NplT6RfgjfrP5cW+dOYOq0mvzJ3rtlR3aXWDl+PaDCebQpU9LlAZbon+04eJ+W/cpUkVmak0Ab84F9fOo2A7f9Qz938Zu0/KGr1w2fjgMdX2A/HT8HLKA/pu8GGhG7nG48QgSMKjIpZ5AZLl8GE0ywptmbSqQ4e1H3+umZxAHZcKXeQkghfXp/wK+a77cMZ+Enf6T6o0Klr7eUgl2LnIF4ejSv7d6VAn9VH5f+cCwG5S6TqnlOgwn8mDp7O8kzE8D0cj5mMJoEFD1e1y7RuxPgpfCvdZezQgCKj+c/nqXQ+U8n31o/a4hA7J87695Z5C8qsQX7ljEn1PJ7v/I3Hq3v55qM9c1sUX0OO44TmjMh/ckfezfg9p++Tk9LDF3s7/3aJ2n477OioKFEN/vOPZC/pa4bMgnzSwSu2a+fmiYM4rsfYTqLZksUODEN76pmT1tOG/OEeAUMCdXBDmqt+dxFgM8vxf+IToLW36MBjNNHX6iltZhG/pvMQEiObCsMQvT3SAn4bPrFzFD5e6dJPnDk1TbNMsyMC2HL04UKnY44Smi9N1Gvlgrpv3ZXMO24naHLvgN7fNHXFCM+t8+ZvQkdGt9lTQ85+7u/VEWbZ5oA8bWsAF9uzrQjwAMekaVB543GJ8XdSYmpAMp7ewSoGgUTFPterNN2xTg3frU7zZCI36xwCr1fmfoeiMIl/7SZmbVsIMsmb1no/KxS0fb3wt8d8FEEH4USULggNO6VpfkUA2Xx16wvJGUecIeKMB7Vgvi7/N0PBJ/egNaPyBY5v4iIP4/I7sGaBy1vVTLwodi9oS5ntsuipIvOv9T+3qV23JYd3Ocrra5JgUqD7TQ6fNuBk47vfceyLs7e2HG0zFemQOtVcIxQpcj/Fcz6PgjTcHD2TsTlV6cjB9p1V6yUi+ERSD598KgnG+lLffNaJvUmEWq9YTpq8JYnoNSNIjlOj/zpwR54hLMTyk8Uo8jDkJAE+OwqZt6aDP0DMs1Gnbj3hto+U0Eed4hPEZIWTXJ9UwHYBDna2Av5p4E3xcVDHY1f/FvxdlEOVP9PAvD7VREURLFjnafkRaL5PeQbR92opAXz6LMIhlga8uIE2yEQhxU03UCqNpfFOJDIRH0FkEJ87fAS/zIvSQQ0N3OT+Z6Qf5r8L+LdUQPo+BhzYvED8Um56XKv7X/9EZJJ0w5vswC0k6IDlmy2HgDnO4asdHhIUbxEW78sYi1xVSRa/XtCCyT7Si3jzKB8e0iy1C+zp0HesYby7nZdBXz//NR9bOUta/KsiXAnwqAS1pbSvco7C1jdu5iA8tDva6xlBFazsdAUf8lpa8Hf+88DgeT5VZQt334T/tDWE/FxH6A/H0awgvyvF4CenohP36R68tEpIn/7TdhbW1RSBb2kXae5JbHAPfN44pMtsqE5URk6jRGN/2RWZHGKU9KyL0ZJnm8Rlah2ueP+fjbeCjiECa77MNH317Mi6XXvA2jMfWCJWXhH/jvbqbJ4dI6zb9zCuyVg79Baa0pOqFMiwN69fJUrsFwA1fvi+01B+Y5rn+OWPgv0/zWwib29dA3xbYmITyh+NdTzwBSSReImcH+32WIzpinwvCe8gzIpG2heJibZt1RgwVuapPn2+ukCuFpDhY/x8YUsHZQDk+xvCtDvUv7++p8iICulhhebRhzkkiZ9aE6Dq6C40keiJ34kcOFyxrPQVRGa3+speBGB9Cc3wGLZeuq3oHU3Jy6a1YMI3Xsz6j1/RUnKVkj71SI+D9GPaa6P80F8lPNKLBhIfzZwcyujxD3Ep0xkPs8Xw6H5H0XXGFvkX1JhCcm1pyVavwCU1lWdf8+3d6Eqx16A+GikWe2HPRH/RtWKp+5JWVB+5QiZwkfPgqen4IpyPS3Edx02P3DZQ3zscxq2ZBnKP0G3qfWoonwAMLN/+pWP8hEwZD/Z3u2HAhnPk1vke8j/6zA8m8vPZsj65fpSxF9vAs10MTm8nTHOez+4fu0HdUKb2kkaTwpiBXz32zuG5tD6w7zJrYcvQ0DZsWPNFhpU359neF92FwkHT5bz+I0SwoMa2+52wQLEv3VY9C/7RqdoflcWEkVC4RAMtjV1Wyt14PhxsVtXRoKztPF7iT3CfGgsyTrBR3anALFi9+P7eyP+cOIbjvE59de/SXGw2KgCEYi7+sauB4b0C75dXRYe6w9Ke/W7ouuB6s9o/E1lKRSQuXv3RScDnAyyf9cMDC4gUP1GkVROrz9/IJ7U15DE6kD5RcHixlsGFkwlWwf6tsYuYH84WV1t10GrmYTvZzcGD1Di3BDym0G1yhSwFEu5IqD9nT1V/zUof7wuFI2AfCB/TfplqRZ33ZH+d2/i8fkhfQ07KzvU6IH4hOHWbb5TFAl1cCf6yb3JBIjl+mI3ps1d9mAEVaflCOXLit/ZpduCA3i+HLKDtSL+1+IlDvxCvUGVDfLLJr4hCzC+3Oye59H44Vtwc96Vg0OpXmPZfCEfA62qjgIlxLnLIQ5rwa7XHBSNa01C2v/r70Gy9DeMvqh+w9kNppVE+VcedoBtH+UzofxeYXEQzoHL2UWGwiPx5qGRMA4dNveHCk4raOn6gihfPFVp5wk6QvkqQfVLt5E/AUDEV0phQ+Hy6S30KG1wRjQ+F3k/H9hDBDy8e/dG1lG+uoGgmCXGmaHw9OxEidIB+ev2iPSloIqW7drt+IYPjUW/X+L7RhVCD9yIh8afi1i5ILPoRkCw9oISgbDnfbXyChTjfE/FXrou/yYHin/VjAxRlEnaR/c+I7Bpej6kYWDivG8oxG8SEN+b6nP/im/1noF3lfSvHxr7lmPF7mQ6he2hsAso7Zgz8q+/exL35xGULou34dXDnkbr83IKbgj+3k+rwB1nXMlKcW6gMWcYvuId6tkvXoQOR/y2HbGC5YSQ4rz1cblHhBwMyr8hWohwklYAo9TTn/sH5euAid/D+IhCKBxp8d4ViaAALpsePRtY2AI/K7NBbYkAipBctPZLeSb4mYTSUAHj4oD/YgWqG8KBJp10sUEShIkkjx5TmtPfLfeBJbM8ZEdFWmNWoFM6kQDei78gDJrI5WKxjMhqWC8ofc7QQ5CO5udFKgGGiQmqr5exdPVLdS5oto6dYd1zEIGqBpbOPVnE98XtlaoCohxoRyLsvpseEGDauZIMvLJwOamO111N1Ds0bXPVjZxEfB41R+JGjob0k+P24akYDA7ZpQ/OUKSGDPhKprxKkc9aPvYOuj1wpF92ZFCx+UxlE7xueM7OzoDq68m8Ni7SkL6o6bt9yOtf/lx1NwLrN4I4v3x3y3n+KBaCyQA1ZsWyBzLwpH7Vy0P+J+2fXArt6AdBzRfsxGIkBSSPma1VxHLEr8ptfR4gWqHkjhZINhGdP8M7ZWu/XZQveLwPfIaIdMg/PjPBo/xEAUcOrLmen4hv3TutfaaMkZA/1jgr7RhughaOivt9MNDlhPt16p258lDxyM9igtllQXV/1aH0dEucLy/fUc8OR+Pjm2uCXcGlgivPWRNUT/R5Nf9KgwUpBaoUPRni+hZRfpgz/Cs/kD4Cxu53JYbiD8ofp7WFsfVN5F+uYoEPi/wxM3+1QJGdAM1bXEcaXBF/7qDH4mKS0PitUztpBs8qUCfNK6Rcv61AS5dBoc7AFcCoP0jacBkT5b8iz5ncEzywfZFLtib2FsBGpgrzEFQZ2mf1eDqH5UVgmk9vv+SPh3P4CztHhUf+Zw/06vHms0f5dyHo87dRiL8jVJR7tTk15Ezm9liNFPmrxcc+dwdbjPjIjjuQ/a0f8Z6QJ65KJKryS7QxPSRR/keEBmysR/plZYt1qPhNZgF4p91naHLkP3XwTlxErS7kPBRLFo/1D4ACnz0k+BkKPG7/lrEhxBLll3ttRtqB8qvjgjluXJi57FfboufjE9HQXk6wnXwSRKAyruL6MjwUuIKZA4V+ZS0U2GkWRYXERWA2HvEjvm/E/+R3XNZJZnQo+JQp02yO8qc7c/OQ/VA+ZfOKG7TpTSH+94nvbVBTwUF85MqcFfWOy9ra4LavFemXsgyCW1msrIJviZ26Wfk58o+vk9DS4y//Ps74RfWDOIFRzZPNE3eUX+5x/bjTAsdBaQk7VBr39gDLBPifoWeOAIgZszLa7ixoy4vO3raXm4GhQRGWYlnEX/v0+wgq63XIH8gs9BtZQf7OfpnTPqkPznWYb8b9r1OhGLUob7+x+wSi3z33MK9OXPDpH8yCgFKHYmFPWp1/J5S/m1kmLn3sWzA9lkdxGuwApa15ocXo3E0w3vye1NIiQ/4ffrve0LU35PBOLc3mmCoQfuaVPBxharleLum7KmwN5JUgCI3l/OsfJFS/Yg7bTuBh1HCVXPQCtEw29ijXGzskqt5D44L97/7set17TKbf0C5UN+QAObGgNuoimHK1FThL+SbSdWEQAtiFxo2ephVgKxAZp/2NAvhYJHSJaEX6t54UXyS30QN45DV8oEu+wH0NI30VbFRDy/sxjz+odYD25tfixeOIv2RibbQXzy5QoBtVfukfPwMJ+/hyYNY9l8vs9me4R9VBgekWVX5UPgv63eReGq3HiP+/9Fk2zTRDWT8PYmBIz0GmOu1LGTFo/gz3PUuC4XRQssUA78YO5Zd1XpIGG/+uT6L53xa2Q/oozTQ8b8qB1ke0cyk+xn/5g0GUlokYCSFSzj5mAgXll1dbBkzJqGi+m7cwFgERjVBqlSJiyuruAcvkxy/d2Iiv8HzTXIJ1SIio/GPEqaWwiM4BjzHt33NvwvOGm+2Su1ATuNSv9ZjqgDlWTxyuU9fyIGvY+vZ7C1DDzF9zI2cF+cuhE2X/WhucDcoaBYvb3/sfHiksyLEGBmxq2GrLraha5D9/L93ZdAnNqshahtxVAtjU5YyS9tdfVGIL+/XpEH9ZqFRonLuj/PeKr21s2luK+MCkWi58diME/S134oP/e7/pV3wPf60KHGjlN7+bGOIfvnuc9xn7e766NLbV700v+v/zU7JvZVBu7WrnsOf9AAVtZObxo9Hvw/RimPR8bqH2qu6B8/jOInjc1CmgZ6lukdTpH8aiLRmqn79dsmEaRYAUOsbPlhitr58jUMXnrvYoHy7p71IGlF8yrzMS/Zl5Lav+ZeaNYyIovBvr0WT7gPg3EcuKSpo/PvI+GBBXdof82swfzKCR/ypeMfsOv6L8lO5gFnotQvUtj3yvDntPgL9nnqwiMhFf0s8n0da8M0GFnw9lvFl9BK6tG7k7RYc4+FFGZjVtREJh88rrjfWoPkwiuJ9C0iF+fU27jrhjQp+H6eQdS4x+3yTk2VmZLeLjRs2pITqoHvJqqQJst8IOJK/+aeoMicbPOJu6Koneg8KqHkkAtYf513n93lrOWQvg9gG/j/gTD5RfMMI0a4jGZxJ9ZazW0W0BnjufB6FlMVS96g7udSdRQP3gxpLTa92yZXddFP7ykf6GuRHMCCpNUIRca3+xX+ny4pe4vYVr5iBgkrz5eI/eQZ8PsGZQDeQv9T37YvKHfEMheMkdF/3mCkh9P+2C73Y4O9xwnPqKKgn5Sgsmkm/HAxD1Sjp5+J5cVijlkotGj4ZKZl3PncVjNH/r79CIKFwErnunjy1m6R9UFD/QidedPoA03L727ZejfBS8R7GMA5QvdZ39tV2ck8zfQyXm78sqSP9qQgxJ29l0KPsgTaaNpCLw1AVMv5KkFvhlQpCZSFoD7dv+eBm8FHvAZoTFs7xkEhDqfod38s4rKI9WtjrcG83vOGvlOTDS3/PNIUp/7a2jId/wsS7YKvJPGcThUAdsh/xrN1iHInrzr/8FbBcE/hXIsh/9DqrXLHD2NIzn7XgbUPcgcb9tDzT+gNcQu9nG1IKt1fiH5m+I74fubp45Hq2AKURi749rEDh3GKkvuFtofTj0rcSe+eSBjwPiaPCIXuBdjN81/kl70FL622jcn3QEgufcHsHHnHGuUrMWz8x4geB0k0NuXrMHvhiJm6lq/vWvDOBvb78EBs3yTtVrEKD8R3Qi/b4eYSGwhoXQlO/8FBrW6H9F5pomwNWp5UTze0L5vHL/OjH4IVSsH+cwpalWSF/C3nw+/AXl27kyFm30FyhXXfp1cVWrAP+st96W8N4Fb5HZb8aPRPqv+MzyaR7o815+b+WgNXqB1QkpuYvHO4LAGawxUFSdBS5dPzbyt6LjF/qNeWkjNqP8fsCVqX2Uj5ytNIzYtnOBPXP1YnROCqHUOQP2kULtAHmIBDaEz97leMGcXz65hVCrX786i1F2B1htHW+4j1+XS8+ubKpw+0GLGXUnMRSNAJbts5RCfjqUr95PV5zRAEABweQwpFLkgXQ5B5EZclSfW4fVMhSkHZp4rCzNbdD/rq97nrI66hfnSi30NenA0PG773pYyeYToKQKe7YYgPjK3FLtWXAmifQTThTDNkjfUDTCbl10tjhbT20ZaVb+hZYd+J/nN45QvgtrlOomqnW5XKHytqJjHfnTIsQlCPUMdED0b/GvW13OzxiXv+o8hLxZJPTV2eEELIoWX/eg+iL96n5bPxPeDuUZDrUujySqL+b5VuQ9ReNr4p+4qXEGg/zPS43X04xYcJbSs+9OrGzBIHHDvlTvN9LXN5N3mRWrQDfAym/k+tcfRV2oG+T7Doqc5m0Pk6FV8Mfpk5x8RpzVMCZ4C+1fvtJh9ixOgPhs4ub77VtMLdI3pRlwBXIKFH74ExYRT5ngVuzDwQ391P7LlK2tiSg/Cp+ThPnsAKXF3ssorRPS7+OaeqedBwjwnx2v2Bo5oCf3Wm9hiNY3stNYvi90B3kLf5PeU1NVkH4Lcv1IbNvy6d17rGTz1/9B07FkYPyYAJx4BJfJB4vLC7Xy2GgeG6E4WXDrkzuN/IG233Z/9h0OTKeJq3g8PSjikls1HIH0CZtT7ablY/vXH3X8mMwb+YNdHvUt0MSZQlk/Hz4oR6D6T3U7ywjWGqERUk6s625QgRhGhkWyt7/3l6w66U1j/kBFwuwR6Rs6Py3+XpzpmS3Oz02BDQl2QqiSctIJCNiRvl+u1wtvfsH59GcacR7QGxRB2EkoQNMdMBoVZQIh6AQwX3fN1ijEVyb8vD6C/vf+Yzb5rZIK64Ly27ZH5d3dPpB/F+mzQGSP8jnJl8GuwAXnQOG0x42PJygTxupzizIhfrm83yI2DvIHS1aoj5ZuNpQCNvaTGME8CFVGQ0pUtSizlFNh3w3rgtbGZ1NFluj4T2TIZTrdl5aN1prr/u7kQeuXqfb87McM8ByoEpL+VgKXdxb1oQdShKa1BMCioxiNL/bjRFt8zS2bjckn9Y3+gkrAeQszyuj4lKXwXcuwawti4tdR4jT70AyJG/FmV2kFn1BP6ZXKUxfc9AeC7DUOoEXXw+6ElvbXf/rJ71vJtYhDUi36xCaF/HEDy4PIAsR/nLr/gHfxiwBwiDO7h+cTNButC9f6gfyniSpMH5gY8VV711/mU5XQ+Fhedl/m7k6BTx5NXPvEshZZAfnD2Wx9QOB9F6nlfcQ3ung9J5JDU8S9Gtqgvot4Qm0dGGp27w8RePwdt9Tsheqn1iSiHIODgQB8guRsVxnVr/74PgOHrP6uX98ysycxAEWj+WC4vIwo38XmMbO3FvERBv2Ek6o3gNpXqF8W1SJ+7i7Fq57gidYvR9w/V028nX/3R1+NOJlAbd34xMe2af+NX9D3EGrwIj71KFAqaDx5ZDeoIj6SNanZbCsXoI0GJsuYd6SCn5yBYlklVN/52DTf32EBaI64f1APgD5fv/IyKc0W8TtLKIKcQtKG7DPQGHHzHgQwnOc+3MsOqaiVJDSpnH/Ply+CequqPWSBEfqMfXyO2uUHA7y7JI5lqMXYo8PiMchAcFCvdKDWouXzsmCDO0EivrOLspLKjvLAf+/8vXAe8TsRnG3vb7MC7YvvqgexTiooGGH3mbfeudzXKeZm2v8+b+Ffn2i/iG96jVw2O32W6BBR+0s9IHFQDXEzwX7eX77B6VkZRQrxf3IZLzNJVAZyD3X+Hdh9mABdH1P+Wn6FwOt1JlsVcB5Q9bH4/DpLfwB5ySyhR+vYZVN+XnhDiQVofo3Sv1vlPQLbNEuv5jUgfT8u7VHOPe1CTrspL+YtqhH4BSL+EtMdrU/SYl0h3rsH1K1q4Ya4uTMgxFt3zRgZ1dcY8t8QvGsPyh6hVAe2oPp4raoZLmXTunzKNPf5/vf+vfZO+JlCnKACh5VSR6NgjvN8NWfB+7/7X/aV1MeD+Os/vy2fh3Hhf88n9EYGM74WoZiNRFl+FORvMa+s2MVIqD73mIwV/SsBaBkGT69q+NdfKOL57cy0smV/lb3d8ajnER+M2OSSgELrf8bglqh//W2xezhar+Eto/xGTBhPDI8I7HkwH2SU1gI37+y9EnlagEClNeIACfLH2odN/AQtyue/BqcyqyAuqD5X3PlajdwBiiJcx1c+Vcub+vdpkYakQpNZrUJZUmUCcEjyo48ddPzpRFYIcg75a/zS7yVXofF9nza7YOdff7GngJvnq41FqHaDGhOP/IH0RbvY0Rh69PtVYQSt8f5rjR3MAxUTA/K3aBMlNS075D9VfvI8Y1R3KDRd+bZejbwCVSM4ERBN07JkWzT6nkkW5HoiHSdK/OufWRDGXtAx+rx9mcPBphuAyto5uvGyUX7M7Szp6uleonzA5UPRWPQH6pTtxeJkUwhuF7aIxifyP77GrLWAZO9C4wBca6gfpC8MNnyqzOBLl1uHpuyINGehESht0/tpiH5/zL7qZ/lEfCHQYoxRngYR37SPiKsvdP7fLxtkxnqi788N1irdbBP+9kewKTD89S9e2dOkVeuB1tcj5eBidSifq9r3x8jegepnCrH9RboK0qc0ua5pHzUFWvwuPi0CG1cAP7MkpGdRuVy3UdzlhbUEwX1RAl+6UL7z4kalXty3wXnsw5ZjB3oJWqteamt/jg44GYM3TMyu23/59G3EKsr3LxcN1K4c4O/ybhEuf/sDsK+LwOpdY6GOAwwr8f2RAXtuvDGD5F//ffMRglBC+UR5029NNP76Q45HNQfza0DrS1xn9u2amAM5xtk/7iOKRODmPzM8GBn9H7kldnNzTYBcORTUj/gqDgic73x0rV+7wMAw/U5fM+KHOCPhEAuPFTxYN93yfkD1uZD1h2BFH+Uz/q6x6ukoaP3fCM+claRtgTvR7/CCiA8lv3u/u5EZCZAgNfuVQVTj3CXkFoo2MQ+NtMKT2WhCD5Av1eI1eKLx3XhsM8lak6HxhLX7AMXDA35bJuPizZXAxq+hioMV5UNFVXCt7UiUT62KVXJN+v693/K0f6T9oyWoP7jqFz0SNBv4IXaixbHo+xcSm/lpQ+uXCwjki7fljx8sgVnMa6pc9umnHfNIThEqzx0mj5hD9V8KL5n3GrNpuWGG85nXOUR8UrzCx5qGB9gLQEXTi28ENg+va+dukgnZ5bqfDdaHFCgEYv4R5xP5e22hRbdyf/0TpPToZFxVUP6PyPik73/7n2jYt2ecCOmDfYmJMdDFWIEEQka/8bAR+PM0nDcZbCpUfuY9v3b/MYHI1bien1mkP8KPTBLR7tH4dcLk/17FGP1b3yxhovohFjFmieSN9OGpzS+akMIMSA/odsdzqXAerm+sFH9/+zOQ6Dd4Nj9OQH9Uyif+3tD5uTSbgzJF88+NhGJlnIo+v9dpaZJkjPwVo8x5icdNgjzAxO1Xbqh+d4OWbqJRI38/E5PmqAVDx3dV1vvqOPq/YI11lei/8YOdT9VeG3+728eQ1fduQBN0e6qraOV6fHxuz06nFo2QI/uVtqd2325JeLOl/PdpRnK7bsk6vUNeukT7py6GVL22r3C7pADTbTm5N7fsngy9I0uE/RDap7mqjmHciK/Yq55yQ8VXwqI76KW/288h6au+Xp7tTXG72KK2YmsYjnTnfPSfln3FD87Kt1J/3dhoE2TNS38f7F6EN5o+Ask+cP675s+dEW5+vceylZP3D4OLd408u7tnExyVcxTXHIgftXcQduVdQPlFZtPiy19vm/JU3keB4vtCzEQUOeepZHMrQNGtD3rx7L/3GJ8BDDDl1rwV6PFq9/hgEbZCgzVhAlnX215FYzCv2/sktP1pT4nAUg1Tf6hQvUNRcBtvkurhABRbtqRoTYnLwyr/Bc5N7aG9IBzOZKVzAH/bL+X2QQYAiosvvm9l+qH1/3soqkz0KpjcY44Ve8xdFPy6iB8H8wHZSffZvUkpFlC/3juT6e/+6ttF6eNxbC5UaversE2I+CD9LKrXFvXQsribW653/fUP37KNPYNMrUBRACL4sc/RBcrLOOnnmwv++Y/9MukIPL9Kie3MitbHy/K5c1FzlKmE6/6S93cYgXCB1yux/Qzn1+T5QjojPqF25nd/rVE0Bs+HwZgvCvvrT+zSvzgDbx2q8BLltPVQ/s5JZtgWncxwbsfxSo8KdYCyMHOmc+iIDyGc+DrcJbR+7riH5ZN04JC/5z1CDBfpV6W+HiX7CHOcLV2bzW8Yx0HdGB3iTIaAAGW5jqT67EsXnH/vt9yY9YTcwge+VnFofN6cZlsPLqxw4EBSkHyXOaFdEV35Gka0/lSDFcT7jUP+9yOa753WNxFaj7XHMDK+r6Cln7jpJ2iWWeznP8OpqRWoVPN7UbcO8dX6i8n3zglIn+7kQy64p3kiPlSpj2HbCsrH6vCJfMlHfGeFbsKdLIb8WSbvyfMh3Anw97qgJSgvNL91VkrapTEYBJEEjnvNjyxQJCH8AqcvcG7r8NUevJxH/OF66S4f8gR2K+u2VP57P38gXZyWaEmHIqbtdiTZf+NnK1jTR1fuch9Pi8MXLgmQbexRk4acMkELHnb4+XUov2Q7WYlpQ6dQvg/iGaQdzQL2mBhxDgSkf0ppNVvwoiGUUvPepaKB8hk6V1susrrG+St6DIXeSSj/izdKOeUN8V/Hke9ssJYO5yzvFYABQwvOzm6H5D+LUQT3DVsub1GbFvlrMLuuLnlQwh86wNuB6oA++JD4WbBseZQHsyJd0ffznzfzvCkd8p9MnNJaVdsBB9ryIWvOQNor4oWRebIRioCxJNyiMap1wSTOT6Qo6Pw0T58Qi1no/EfZeE8hXw0Cu9+sN59HnAi1W95hw2qGK4jCPLvqWfvbv2yz2fPAEF/KPmm21muJI+DPzWKT+H3COTytX78NzxMoNYL4PVQH+RNZ/vpV3Vz0/ferkEHSxzFUpRtP6u9f5P1t/frKqq7/639BQvF1qZoBwTNzXr20PhzwvGJK85hjwTk/mvvlCecZstqRXW6TzB7YHDwW+00fWi5+/DVvfLB3aLeCTfIv5+/9W9n5iHI39AJ/k07AtFseQ5vlNId3SZTv8wv+PsFhdjirquwa4c85hHLlzI215rQHvvi2a2KZdgLQBprkx7N/Q8EJCtjCefTA62x+c8QsvQASh+UM36o3qJz+J13yAPHLf/tTMIjkW64OdnaittyDRu1T+df/oPxfHzz/xeXnhPTjSLuwYv0R8c8WkYahxgcoY8yUI0HuXfYb0a203OsWqm4BusZfkT5i/fVpFsEfBI5d/SVoDA2dn47V2V6TNAEgXg6BJYw9zr2b5WSy/G1AUzmZK7hHUQbOe2KfmBKMOP9phvCOrVwC9R7HlbdRoPoQVwZi9vlFfEF+RRL2PyyGCmF9DOL1nRlw0HQTim+xb3k+Y8EcPLgMsgqha1Kvo/wkvAXV6/moR+vHKlIzWd79v/3vttifM1CJ/hI5AmxczkyqqoyHrYDWfReysMBoBkTTDqSgV1H+9QJ6m4zPGUEjfGZl8k3R/N47JM8e9tcfHxhCbhu41kOluVKgXce0giSkrv6o/vavgE+73GNbqqBK5VclK4UugjAtYqve68HlK58o79PEuVCa3lFgPDR6Auz1kWeLXEeBvSurBoxf76PfZ4omM3maA8rw/cqTgET1J9SvbeCY/IR8x9gexh+ofpQijXbrSBccTInIih2DIf3NuED94JRkgvC3+Ba702nLoSj8mWTFWSDH2dr6abeeAZi3GkU+2qHLDbr69IJPZ0PV8dA6DMx+AgmBfUUtJT0c/PxJrv82l4Kyqc+n7BiBCl4lk+S7cyU4F/xEhYtOzkf5o/gtkxlpGchf2FuIyGtxATa05xu6Vo3qmykh1mpqB2i9oFqrXzqBa4L227wCP4OSfaum8WSmDmwb/PBQ1MeWCx6fW+boZAWtS0qjUMFIB/z1vKNKNA8uWPJnmtc19YRKd34fLYrzK/Dp6/xsryTFefu1yVhto3ypTjiQekEdWNAxvZGLGfJfYJfBg+7DOYC8XuL+qpSz+LfJO/EsnR2Nf6XLB6P7aH2pyQdzEUBNJqr/l2s04onq4ybnz4j++Cn821Okk18+VYEcL4Ju2yjE96VK3woxqd2/raFSoZmqSAW913tNbRSIXzN16Npm9wcomiNPjo6E1u/btYPrOFyUL8bz2brEMaP5SZud6Sv1T5+xxK00Wy8FzjPv4a2L4wbqjmnhER/dHWBat6y+0FrDedWfqDq1sx8U8tWQcRlHfBIpOjRQMEYjsoGzNXafhP/6S16EQk3IJdTsRrvFiIM5+lLC0m0lFBXY3dPypB3wynHu7PejbvnulXxemqohfiq43/xJnmh+1U+6vx66XbSAk7oNc/gJg5xleJ+Op4IK+cdtGi3JSF3wM4v6kOz1goC9wbGYAfK/hCJu23nWqQDqZvCO+epFyM0db4g9i/JTkA6TM5pCJYDu717JBND8GnL39SNhRf5NnLtzG8+9aLluiBZ9T9Hn+WY67oA8VcRXOzjlnuv/nr8KBU4To7cAzWxE8eF6RSwQBve38L8O8cVeCQK2+B7S/85EAZywET/I3/v3MylsiQP1ISVHWv7tf8IhCr1nymgC9zOkt4j76x/9VWx6mf+uD6lXoCxohlB+f/R+sEVLUeNsKrq4EYwzyn/FkE/CrRoIUMAP9pKNrXT50434ifuifCjAJ6hM/aeq4IOv9e23ky0OsoXa1oxkGPj3zB55Nb8HC6yfNP5tqIX4ggXETJeLZaDPv8PVtJ+hA3AVPNf1NjcCl+Y3ao6M9Qa1HT9dgHd/+2ta40vbH22L88ldrXOFnwHkszV+8t4L1b99Xt3RPUzkrzvD4eHXxXSk/0rrZ28N8VHzvnBZvU5U/6K8JmAjfAB17mtyrfhA+T9RrqHwCbIQWBhYLfy9Nh4qgnKpdEAjfU8EpH08oyF+khdy2G+wZ6Fw03niFF/yCu63z0e1ial2+dvdPf1KySVo3+FG5pc/MuDJ5SsXGRpa32K27Yv+1x+Fq18ByVYsmv+PYOVJOaH5B7lfzdshIH2Tnmk4PDEGrS910FkJ/izE7w5RHU88XkmoGkhTSnodVGD2m8e6TYjO70kZ3e3baRy0+k8Z16B9iKATlWUiarERUNSdurdd0DIEftM28yErEbjj4E6XxV9/wq32Hawyub/9dcip/l5/+bV3fuvuH8ofP95K8TkGtYny7XknQ1JA+TSL+KC8t3/9dbJJBL4+SRpUX17YYJ4TTuDJLHvfyO/6r3+T0QW/SYqgVI/MSN8ktP7KzWvwTmnnFjhp+mwAkkCo4xb15fDh7/6oTGb1qD07F43f28vWTkP69nhTqaB0cQUawaqzYkhDpM/747gip9uhGDLzvBmqb4I7ln2U7TMmOEvZUenKN8KG+u3mhIl+kCuA1a71tR6EaH0F4HIx26Gh3Od6KyoOvQLniGh+ee5dy05kPz15hS7R/Lu18CqRNAFBO+x78z5RPsLjJHw1ilRDnaQ4WN9xxHeT0F1ZJv3tT2p6e9qEsh8jvmcxQPHhYwUnnTFaotpRy3Ouknr6GO3Q0sVfxUVFEIFkddyQVa8U56LuUzjb3/M5ZoFpCZsUJAU+Rni0631D/nph1MuMp+4FVSHFmlII/55v1kjR9ysvRflIw/DcqucI+Z+0SEueqyZQ5iCyhQkfBX42Qq4nBCmD/I+O9G75IT7qv8fDx9vjb39TTwy36fXHXxAPVd4VqQzs3ob7ZPisccBuF8a/ylmH7MI1CqSkv/1Z//pH0f3RuuxGsUHDP7UWyvioCyetaSawHK8Y77uK9IH3zihYEOdBpSUFN3387Z9oY51Qzm2E+Elcw9+uZnMBua7sVqGx5QzQXhgRZB+UAq8i5NxqkOFQGdLfPHT98Pd+Ncd/5WuZXFZCeTaxhLqH5qY+3eHyNBFYHSNnz/07tCD6NM+6kTQJyl/KuVeI+hmgyfwLUTmH+FT1my3ZCQyN39QSWbT9199yeARrlRxNy76s4j7Xd9qFcvbjbjJPDgdYgRyWSnX93Z+i5Mr+EMcL6gwjf2q5GSbwBv2v6HU1xtnO8CLg7MwIjQ5uU0fmiH80pQfDKBgZ4vcn53zfbzT/9sgd0mMSJRGUxhAsvyCMWsAv18b9DFGF0tHlmh6PfQQgGT1unqWHLV/x9a1R/u6PyVQhVPhD6imACiq6zJ5C/j3Nzp4ro8dAC8I0sGhJ8cCpfeAPnxOU33Vp3vj0i/RFffCp2NyE4O/5orN6PZcE+aPR5zLxef71twUv1YhTD+W/58vuayAtKF/3byIS/b/9XblzBM+Pwg8OkM0TpQVDQ/n3KW7WaYg0C0H8DLMvVzzQ+hUPCfsNd2Tz2RbmQnNQN6jbV5u/MuOhAuvgGsN/1xk6P1g92Y/PPKH6+7HDHv4936gl9cVNSY/Gf333Dh0k0wMK9z6Go3VD439zYG3hy/zn//NLFC3uuEGrs3E3s+9o/UTqtj/jJi5xrl5j3fyFlgqVysAc0OZ/+wPhbFjIQ1wJXDmMtZ3n4gPaNyWzStwZ/vYP0fC0Z4yqBQWl7R/mMX8g+Lv+VqdzaILX41cjaf8bf5so0qUYkH9rx/fgqzZF/tfMZ5UX3rdyAZxRyd+r6vm39QwT7IE6HuAT3/JXqXdI/yWaPg4j8dD/ZauKxPxv/Vze77koX6Q/fESpPswkTIS2bd0MPzBDD1h3DyRvjP67PqypDLWaHAeVQKhOczLQ+bU5SuPKWOfI/86hhTpPo/VxM/YgkmXEj//tjxD87c/Ga5vwVARq5iFLDk3IJCelAt/I/brWU8QfB8NTgp9XJOTvkSZE1RPNL5OEmJvRNfLf3brTFC4gxJdnuymjRHhQQH1KBKeEctmCZ3FCUktMEgJGrQXcThD/IK9OrYKZW5cr4syon7p6h/rIMIxT1og/xPazGVfDlC2XPeyoALOmQP0jnH3ZWmj+t9tbA131ilt+z85Sy8wO8UdeqFsHrr/+X6XaQlKfyr/3RzOVf35rC3L4X8uYp/xA6/fFU3L5whG/6P7uup75d32cDk1NFPLRAQf6Yqnd/q4P61t1dC+CVqDyqQu4sS/FBAKpbHMxehX6fsef4dtC/ze+0uMmW+Nf/+i/++M5K6N8Sp1q6btcr0Gz/A0TmmpUH97XEe4byaEims5FkOr3xkLrNWrwO+N/+89HKHaJpYC+3/w8reSwfA3avw8oDMZG84eo7YlFu5S7fIjP1nSftgpy1HoPVO6pqf/ej5mMtMM5dXj6jlr0NeSvSzyYIo4pwOmvPEhjVK2g8sf409DRCtnM/G08McQon2RpZLVDN7Ys9fot9OnTITRF9lUPSYjGr/oSCS5HeCbw7n2KMExkdwgEzvA/cCGRf7jdu5bDNsH5R/VVB+0VoflR/Ue7naKUAU18/O09wKQ4G5eEYj/t6a9/0hlauk2ifLhP2C3zEXS47Ojm3UG7LA0FtSnhUns+Ov9xOxM/FTIBSemHr7xKA5BTzR2YqXg/AHQQH4z6q8CRUI/xwJAVATUrfrO3KZX++r/u6+iademCqZqWgL2qF7T48geDnUf6eJXMKoSamLc87i7C0dyzE4LK4y98eyJ9uHdFB5vgr75TwmzbHPkI5I/jyXC9gMZHJ5f7fGODv/6nZmnd6+hto/weIrz4/j3/Kqz9d/hZf/35xrRp3UnIBWjcA4lcPQfpX+3/jrr43FoBLTrnFReGVUF+lK/H2y8mBqRkQHzvuJm3nDVfcWs2zP1/hP3Hwqs6tjaMXhANMJmmyCaLYGx6GDCYHE24+l/vqtpVu7HP+WZrramJURjjCSA0oBlHR0UDkq5AE8D7g5KjhpB4GX9nqYLi0+G5u8XnJMKPj5UzNOtnTYNSWaeWLulyKGbPYWQYBulLY6qr+PxuSH/erOsGny/EH5p67yz7/hhuYDO0038bY9PIBTzI4xV/Faj91bSA3N/5UApH9Rrnnx0hLh/+Tjzov/o2NW2Grpn+1a8el+2WTEh/iaewMEPHo/g2c67P/Y9k+CBS0q6GezMoIuYoKuM7BYRWZr4mMDf3P35fLffBk4j//YE+8jeWPqBre5G0Bq1ZAT3zrxhp+YYQsfwtJl2aovkNi6J0TBR54IUAFeAUXUbitNSRXzluBI023JxAf75WED5i+IjqqkX8fg3sb9NEDmrznUDi4ngywFu5Gy2AV/93/kLIZJSP/M2dGlhgvCjk3/hgnDt6us+KnAZ2Tb69qYMKXVvJ8ykaNzA+j8Dh+qltJDqEVsvr3QsqcsAXxqYj/8/c/eYpXRKKH+8XnMHOFwM0kWAUCbZB/ljedZ+KsQ/SL63BE7suxDk02ZHuj9eJ9Lfx2GuqGMYlkr6FPPPx75tDZTrlJuuxKQduaE0rlO1JEW2nYhb+E0wQ/L58yXUV24LcEKjf8o9+Zy7h+5QNLIKgx1bGujGof19SDq7eO0eE/+RW2A0mOVC+vxPDMKiRAVUdsbWSfND8TERBgmKeflAW/M+veHtJAoRfde2S7I2KFBlB9xG0NIJO05PH7ykzf/XLo66K3l0fAT6dctHSzR2Kt9t1xMOHacFPo/Zrf+l1JO4+43Xd73wg/2uYHzny//aH/SpfTn4Cuv+mPJjjhUsDROhkF+fgot9n8Tp6bLaI5ufOl9FaqWYC5eR5PZ1lTUUgyKbJBO8n0s9qr5pMfXff0Lp2arpsdzyQKCc+UbG0qP/aV7jCd77FUMa6eBbf51sFZHX1ztD/nU/7UrgaPry4hEZP452iRchwGS2Gq/097glJNi72rg5f5C8aI/kpIZPm4G7euDzDq0GRum9AXZuFHdB1LxNz8ophQOBlryjI2EaR2L16xQ/KLKFs7c3GGRvq/3vIZlm5i3MjppJYPA/izKDhTW3/nW3EDxQa5vmk/s6/nUVBNOUoHiGg3hu7vuV0BW9f0X/EGiF8MiHzgLT7x48/6itTho/4ofz6eptc5dzItfR0DncwJ+jN4kwUs47m37wrA0/d56mRj443zOaRttAokq9GiO+pBeyFaw6esXMELk9V1zsd+1BNWnfB5r/zZbOH2KPc1RtFbKmGP+V5UqGxPQKP2keEP3yakhaziMi/kE0ZVtL3n+djs2k1GI70y2BmYnlDaYr03d+Zao6vnVD7JFzfyx4ngn4bbvRYpWsjN/KeFuDQKOiRY3i/hmFiwKb+1p85aUsjq3RdqNyeElDvkyTl3ADhR4sxjbH+5IEQubrnJl/RDqi+dVos1JE9QMq+DsU02UmRfs8nRkmx2UHVvbkWU5FDC7Qpq6ZvLaP4bs+nI4Q48h82cljvZ9AyPuC/F7WZUd02simpXH29yBq6rBKiQBrTFuzPY7jljxnhpyPEIXb60gcag/c6b8kjHUH38ju7bR5ofM7euAKgJBqC79c1FIThIqi/0uPVPbg1kg6eluVPjj2QPxauPIb12we30uBCwA1LA2x3SVmKiy+k7/P1JfsBKwCd1hu40u0SybvoX/RypBfUhKL3vhPG3IDL9fsVVTLKv1FxVNmX3B5KmxYp46OaKvDz3wTy34+/870/ajEecOqhcouxc3ybKH5gl60vJc6nRnTx+jsrTNej2WGWG7l+2b/6cvQ4UfStiiRSv0Y3xlOEP7J/RItdIH1UydZA8T33iSR730J+Zw8MehlPjq6lIP32ydnCfhIM0mdW+7vD3mEEeM/SKvCvL+L3XDXcdOWybyNq3C0EV1ggfnrFYy6oS4ryv9QXNCX20IDybvbe84yRPq1Jwc5NNclBhVxVWDl404hGlJl9jpAWOpK2TK/h/mLA+HjWMcelDdJHjpT97Pp0oRt/189Now0DXMtM3rNtnxQZscCtriDbQvFz9Ek1BuwDSH5wfB3yM0UgZn4OoMtpQfpuL7DIerM3EBFfJ/EGc47kVtyqOiDSCdrZpberIDAHuLMRIWxlguI32inGeygIH5Sya5u5eCUrMJ5xT1u3eoikHwYt5Vt+K2gXpUIYH4IZgW6vpR0L9RgBzLoPzl2KB7Q+9oLEWZ0i/uWclyXk1xhJD1Gh9lefNlBihaGUihDFB04vtkrMHsIHie1pZbDSGRpTPph1D9kELGchopifF+SfKnEkOqTSoVnd8oESq1QF0P4IeHLKQyP5xGWudyX9QA2nshEjxIQB+vFWxZW7UP40OeYnJUam8C5TbO6q+bgCp63zmhXrTpHoks/Xb7c9oVasSyl9OjT/51jb+3g2KP44aiDUT7C1iF+dhE7eX4TPWBAt7kmTsyIdlkzg5/u7QY3423Ty5VF+ULVIJuh/FwUsy/PsY5rcoHtuwy/GsMQBBOx5D+h/z5eSOXWnOE+RvskvcVui+yiCVoViVKcPhK/V5uaRHSJ81l2uxTfb4VSQrHoZ4+qG+ofwBcXJov2g2k1JrQW/twi28XV7bBmP8OuBK1bixJsDVWT2TP0HaYRfvVHrWPMX/05L0kHGxA6057K8TJ5D8a0g9Jxio0TX8+peSoGqNdAU5iP6RuGE8DlNt3seofiQ2xLvtPrZIcWpmYJ71O6dAaLT81JQnj3SrxaOPy3+jKGrrhwZiNOYA6YR2tfPDxsF3N9i5YFeqqEk8PYpVdH0AFHcKxegna8CniKmvA+r+EDlSYnnU/7zNxq1Anaro7GRFc00IlyPXSi6IQVSk0hG8DDwm1u6RRuJEVUjh8pJXygtj3kn7gbSJzZxEw7f1gdFbmej14J7kEDvA8j7dbsjfpjsfeBjOVlQNL2XcGt7FsVfhjXWKW/IX6qC8m7OgcoJ0L5s/vR/q4DwC6mZcGxpH1hxbvpdW3wIiWRikgQ00t/aId89aya5HNTtTo3BBBZCaov+tI0neSL97pBR1clWBTgjFKbo2W0KcP3sZ8VBd0KJ+/R4QekWwr9Q4ENc0VaUf4e5+vRSHFAsmlwJcgrFH3xzn50DIsov+0Y+aZwiZ4ic59zH5ILiPwtAg9LROhtwtDd/PXMOQD2WkU7XrEwEqx+XSln/foSkdfF1lt/QgfdotTSW3m0VyDhNjIZMHIroHaStTV1HQQNPfvj502YV8O/voP4eC8KHxyfpZOo2YVBzZiU96q+9gkFjy91dMqR/LovG5yaIa2jL3f668376AC9mHp8lps0NmBgsId3tRPpxxN+La90Qv8qlVWF+dCyKuDKjHCXVdvxrf4hwiuwI5k/25jLRmpB+5oCvJsff+b17EAn1miD+exAdTipSg/AF7/YlOBNsg3K3GgG32sgfXyUteaozfSPRLUcjT6wNQnH47EUpIOkAvOeyRQISdYQsKgX3yWdJQvoJ2Rd8Jl854m+7lq3vE/n3krs1J+gKGkqhKE1p1KD4mu8GEuRttxIi/CJxwD4Rv1o+N0kuUc8CyI82qQvuuUXgJ34w0m/Y5e91DPlU3PTtAMQWxfO+tTPSr9U7ttdXfEBtVbu/c5HQ/HhyeT3STJtRfi9Yc29rF/FzayWUsvd/+6/rJgO/Q6wa0dwMpLPAaSH9MV7TAV+DiOL3fmmHYBQEkECg3kcnlqA8t8SLLM+/+razPelpBr+N7L9RxD81SYdKGP8YMeXuI8Bfazw6pVEp4jkmtBrlf9+fumIaWzPzV1/OaD/Xo6VbxJ8iPwTDthXQYT/w0xiHcYCuNYdNWUPEnyN2y+NmjTNoKs27xf453/gp4rFGUF/EX9oq3sL0SAd4n3zjae83pC/uxZRsWfZE/uTB7HmzpGYNtV2h+4cK0PxEkCwrKb2PDXjoQfAJa+SvvW7rxTI5JgFokRhKkzKNhBy2GD8NAeKnu//+ikKbTH/n1wT5qyELxL9acx7H9DsbKJYMYrXfaIpgACYnxGS3/PkruhV3EeG/d5Ha98POUwJ24eVbHtb81ceUZwoBenpC9bjp6SwzKH8skCQvDf+r3+jC11140gGK748PT4fcpgM8r85umG+O8p9fI59+PFISWrbZ7ep2WX/+z2riL3wshCwtQ/k8Z5KC6q715tPFuRa8UzZl8FJfCUnoftazV10CKolSy4YmIX/pjNcwFSHZEdJ+BYpikdoLGp3mOUQ0IH0aREH+XDmvb6TsIYdxvaJ2Fcn8n1cf7Ap4PboTzS+cCPCNVns7a6QP7DcrflPcZxH+U71lG405IHyv4+VM0o2FMhXXAMmauQVlCRK3BO9fBAzu9/IcC+OhRwt7P+QiL4Lv/VW+BpP/KSDT7pOaf1gGonlnH8/ovSD88qqifjDsTohSgT+P20NX4N8z8WP0d9T+T82wvkT6Q3rpzl3uBq1H69NyC5dUSN8PGeCwWDQRvzPTdnJMgy3Q0yh6+LwVpL+z+4rEpgjHSEw/xALCLa3gfYPqo6AH8wGcsnZz6+6i+ASmASe0MiQE3igek9Qg/qbm0NPiXEH41048v8cm8pe2ReHlK+/Hv/pxmToFnjU1YH58yLZxpRC69rTtcVghfXzwxswP+L0jRDYNBP2ypBKalLP6zN1B+ng7M086bw80vyMpRzDzkf6WiftYC+DHOsD1eFOwQnuKUPblW/dlC9ReM1/PqWukXz8VGd7dTR4bkR7WKa4pxO8iaSlju/VIPwS6iOnbm2wJ4GufhZp0rIXedovuN/OH8rci73zr3RfEr3kV6USETzV0ELN/KDVgDcCOvu4wo9Q3ol18O+TMuhw6t8fqcLTPqsCueMgq1+5EyJuC+1zd7jOUgveEvZi9ysHtZFZX2nMR+atGZRinIFD+ISOTKFty5SCL3kV5ahkgZEIUEecj7Ifo3/+Cny1JK1i416hXxYMLMe9tolzYa2T/ZHFYChSud7wnb3hh5vbvwgsb0W4/zoXHLYSj+hyDv/D3l3cJ0ka+gE9vvzZTyuvw9pi5vW+fdr3jx/AKvSSmmYuXM49QL4mQoFc8qcTtWyYHhJkrp8EXdSRFiZa9pbfpQTcn4mi3sfsKop+7T4IPRtR74068E32roFgrEXTrAelPB6a5os8E8g+BssrjOiB/5AxM1rQm+/d8UP4lWe++2gjUrzE4Ch7Fp4Ufa1xgb6Rv84Dhzr/zKghZgzP7EKbpCQHG5FLBych/36bfHc1/PSrymRjWwtvmF1qLe0uC7ET67Z0SP6W5810kmVzUcZdOJvCvZs6gsuc4glprRKeo0q4BA/PBPmBMOehZnyv2RWr2QdK3aBgS2xDgndGkup5Y+vd9Lywetxfib2NahfbjXojfCJ7Iv6XQ0VArhY/REefbALdjaseWDZdICqdbzc/jtkMjnmK4v0eE36FDA5uKh7URZdtnTJrFCCgdYTkHTon00yvoM8+knsj/2m/FvH304oIS3vWfnvuZiN8bmWLel4byr87nDx9DrIeagSks/yxQ/M73bhJ1qUX6raB8KbEG7YTe4GvV4caWAy7qxSHZiKF2V/80w1tF/sVt+Pz+++azA/Bayu0gv2ZCJrffL/jG0w7V3uWIp7xbKP6dua5iP1r/XX9AYYILqgyvsWeuoutDZMRhoJkr0q+G3Ki3LUX8gBXho2p6lH8paYrzKWYdmt9Xp6xxHBNQVICuLyRtGeBH+NXPQCqGkOejeudZSBIIn79NTRMZ0kdJ/6jiOV1R/z35RxMsOEmkf8fnI348OQfEr7kxjwb+PR8IVWrArQDp15Dus9/sIf66xS75w615aSTQSoasrOQB9bdae9LmIP6iPbhR48Igf/EuDwm+Pqj/1tqFr88hv9H4s3urQL6aG/GIC0mLT+mEShEUx3Nxkb/5nZX42cn87/vP7mGHUkvuEMhG7tbLD10fsD5mindnieTNlBrLLs8DquCkfkvkovGd9hydIUsgfzAVAX/PVy2CMq5mBfKrSYL0A6PKPP73fZede015PIoEOtV0FBTm/tX3jQi3v/xX14ixCsZlCYIUSkzzuyqJRfrEDlMMypaI2iVedfcy0RKoOLR8btTFVIAqnrroqkH77/PF8uOv/oht3upypqYcUIcLO6G8IX0aFpMJ78m5QudK9fSW+0jfNNNTvej4MyuAmwLBCvYYjZ9/a5SsvAzkv+uoO4yAQvydDV+X6RXkf53rOPcofKH+EX0/qCX1RfnPZ4IGtyyOITB/Lm3uLRqfS3B+E5w31L/RGXB5l7AQ/tVMPex+T5D/uPTF1s0V+dN51JzL7boVWs7SA+8bjA7Qn0AqtPLxt//jTXxrbUwfUE3eGHH1DtIX0lRwwxML20ZavIOatjUtoJcqJANuN+RPtLi/gkyWkX9YWmSc7CX42x+pVLrAzOYIepRdw2JNoyIhnSe32XNqoCHtz98CBDS/dfepcJvfu0aqM5lAkdml/3q+QhZ/zy9eahGOfOgi/Lkdu/cmVymGqleQHsH3yD/i3+sg99VB+JZbw2ZcPvaG6t0IsbplxwoUYW3l1SfvCDkdaHUcZjeF5tFHrf9k0O9bH7PC+oeE8K/YngJ5froXvPMckIm9YFtA5cnxuFlCp0gH5pk9NrNPqM3cUgrt/oev9PDFMe8zRZKSBUn2q1H/zYwpEp3BUf++jesHH/WBxrfCKswPMExQu10vapZApYL21Nz8qXBSA+4RLLdB0nfvuqfY+/qeUATaehM55Uz0Rvz7j6tKGID0gUYY/p+0BXc7UKpD+Mr/3r9WZ0CFapX62yD0qgjsGx/xpKFChD9YnFfTcFPhXXznuBMduwDoDx2MROuJhLTaRz8O2vv0eEAscVxkUABznZWYzbpSBEzZo+vCAjF0lV6e5I93iKAaS1FPjlhpxJd5r/ayip7QUYVWuyBdrgC0dThxeaSh8Z+wNzavjKD9sjF4OOT3AeaUY8Z9OgPkT//qp0F+QPg5ZXZ2GjXq/+ELav9uVh/xH5gn864ld2gBQ99Bv0YPcAumfa2+VaSIE0NEKKsOExq6XZM+lz8eYFKEsyKo4tUgaNPwzdqFCjr+S9a+V3xD+j1914UgFi9FtPbvJMscfYOahSUPs5CR/rhnkMVK+INIv7xlUHCUI0IzL1ntyNpG/UsCF1M3ylVk8P3Vl1LtDcqPe4W9d6xpgaWeJddQY9DIW/gl/Gc7mlD5lslGvUv17/yqPeaP6udHYnQaD1ad2gc0bxM3UFpcq2ATf+OSWGVKgEZS0XqnRwnvslSfIqKyFjR96DDGdjwVWXUKLwm2A/Fr7hMfqvrb/2p7O+e0BPaOAKeifCRqFAsO049LPNmtA+xVj3MBLp8GROdiPaurc6Bc3AtB/ZEp8t8mVSpfD+GfND9icW2SWEf4C3edKXQjAdJl0r3TYwg/SvUrA1crZKjWCxOQ+cI8wNN+n9F+C5G+TB8OUcf4H/5GMhQf+oz0YzlHZdByxt/5DMQ6J0+n+0DQ0l855v72b7qm102YHyJ8vyWXEKje9wmlfp8+H51NbuArENjEBoh/JVHli6DLYg7qkkbEdyqdHyC51bFPd+Zf/TSh7Ln9cULoKd9NTta/73fqzzskkcVG+uF9/xj2vdFo6BZnxZ5uwj2AfR3+G5J//BpTt1JTrgnphzW3bzBSkD+QRPyHrU+A/HuER9x2jsg/KElxW0JCR9c/+R/U89uwKiLPhnlOb9MN2s3D1G3xT1/ILN1+4/Q1K2KRgs550H/vv2B5ngX/MR1ADYHdvLgY8QNEpL09fImEzjEhsqNszgfh8uCt64uj/hkyeJ1W5d6gzJ2v+Tra999BxkQWXfI4o/jgXq8aIfcOtVF0/aX7outjLVDfrkSh/vkf8m7MYnrBe2CdbOFkbwdwzJ02D/aJ/K2uxhxDj98D2jL79X3ygcbv8/aYYdmE/EvNvrr88t0T2vn1Rv5EefvgvXU6oo0F6Z/62fCTOqP5U8T58ztFAvWP+KRF6ZkAtacs4wbW9tc/fK+ylj7R9R5zkAzWGgshcsuRvS09fUPr/J1DVPzNXyWs2uQNzByJTKuM9ENE/GrX/TY+JjNdgZ7nt+fgOEj/vJ93/7rgeUGHv/dWenIc0tcxsjwLfyB9EzJcQLsG0h/254BspLZIfwmBZbyGW4f0K0/l56iPKdJ/1svPFeaFxo+d/fhzMqSfgOIGVfUtz+3f55vdFKRfRJbyf1YfLMg/V1+3ZrZgRwEhPe7vQkH6J/KekKZOGembgOxfN9xE/C25/nHchkeiAhOeYBRwslWkN2UET+DHAXQp+HjgaZBU4K9CoA09AvGzZ6EJzRQsQfgXMTt+/vFrCITodlu0LhIri+tJrD4TaLnPd1q03pgA9tueX7fM/urzJZG0VCH6fVnlfcQ5geGDdZM5AiZ5o0iW1lyy8pw1qCucI51s+aev6YRd9GjfIukSrpva3kiUHxp73ysYIryxC1/Yi1WYFLm79FQNv1IEFX1g1/KrjQbgjN70MTcdIjHWN5rA8Bit7/dwFDRr3A1IjErr38beIpn79vi4VnEExUarKGvtGeSfR27YlrJZG7ksWpp7G9NfaQiGZsVRQ/nd1dK8P/TPSEiKRZwdkm7Hv74PaHYvPcBiRLNK3S7kzyLV+gCgfTcI5pfcvPjeyEFBaS+9ERqUP+HceuQoYD+kr5YXGFQS6WtjuivDUuVIv0pPRTOGt3aDuuHhFuHjEwOOzf3GczjODRC+V1sXWIf0263lqw/xQ/4LGRbKPswK6e/EokeG/ud8tEnEt6JN0PpuJK4Vg7+0kTzfvvr6iUy0Pn6KZ8U+If2YCfuov/a0beTf0Pp9aaLgMAvxFhUkfLdACd2yvGXI34gS9tQnWtgIqH0KMX222GwAs06tn57FKP9Yh+rfjxLFj7vxt9skykwLZjlthP4T/tUnnukQ/3WTD833V7G28u/9IFeAmP452KSAUF1+Nfs+WWhf25nZrIXyU08pFUzvbo3EG3ZTGfxLov6lN3n2Yo87QP0bbsMui6h/pFx0XYqTLyhlyutxe1to/t948i3pcm4RP8c/xdmTqYMAnFpoa2yagAEYpQc+5i9CVFBUz1nZKChJspoWyvgWQKuKD9zxnxvS/6D6qju70VBVUfoEwnP82z9zDemUCIi/ohEX/ET/3qDapCiiwfOvfhmuRKZYdUhfx8bvCJxDe0GlY7Bjpw7UP5l6jHIC0j2SrH563B5rLUF9JT5bzDZzAj6Y8V7IMf8R0kkL4rIOJw+9uIe3W6owN6By12Dy37BX5H7NykVLyCc0PlsiJc8n0q/v33TpzMfZI7HEI7Syq/uAljm92fl5IP/jby0ldrPSKTIma3j8UOIZ8dvDlX16Zg9A/niQYhG1KVLG4WoIVomD1lHLIBcAwt8MwzTydWyLIksG9nmkK8IH81Fn1EABFL8T/bh7ok2tBGD0nso3AuGf8q4OUy/7xEHjwwBuAw7xT665N/s1nAy8T3F7y+UAjX9ZqrbpebElwCTkKjKbG+Lvlaz5LP8gf/9cBrM+tj9/j3RM3oknGUO5C0lmtQ0U/+83crzXhvyNjF37S7X/6sMZr6Vs54+K/AmMuIuNThPh372+2Eweghj5s7V7s68c5Wey+21iJzri19N0v28z+qt/StZzBY6//e8STki2JLerAvY4eDlDgfgL0FTbpYKO8Nti/LyoOx/Nz/Ed3+fudD8IpIbkCnlA+G09a/9xY4ilEY2ZO9Nm+fs+vrkI+3V1owCUMelVRRPzRkKEJj9/6teBbsgkpDLdGAE4DLz58XbvG6mcmru8vaYMai/6odzdG+MAr4h14L30vgFY98QJPfoW8O6wbL7jb1YAXcApbIdZE4GClOHEAqQd0vcIzoUXPowAIgN0vsIBzY+bVOu2fv/qfwf26nURRz/Ad94spGSaspFSgowO4vW3v2mxwqwef+kDxJ+YIVvzT59Z4MImErodFLdxzgoqRPqQTOXWYhy6asDBp3dzmzSkj5/piLlH9TpAQ7HHnDyUigB6IEhs9jaR/8ggLkJ+HhgQ9+9A1my5VIBtV06cmR3yj6wzLvDDovUNznwVg/pTRcDtnXrgk79DHNScOMvk73yXnOoURqLzjyI6ct63pCFBaCS2qIGvjsYfCpIIbdMKQsG/CTP3ECPWO97CkDT97YI4uS00GWt9eQlPH2vWIik0bw/p7S5XYwf+SvSkR0YoYY3dyQBF07cSPWLJikBCnsXGI+ZV/X23FFxCg7/l300jTW9fR8hB2yB5HEtYX7rfyukSpvvXmp/El/IE0Dy2dbTMAW9SDdtBZlYXb5KWaxeZQXmHt6KpNiLyjmuxyD6+N2WqsXB19N+SjpF3g8GdeVwZveD56Ll5vR1LyFN9H+oiZl4eg6HQREweQXwQe0Wk3rx/8f/Uj+Z4FXiky/f2VypQ/7vYQb90K71a2MByFyrfsL1ruLe+c2fkF964BmVtxeqHPFcUl5QOuekRr8Oi0kMnSjxT5ij5ZXhw4fqlYNyUGAH6/eYKPhWmAvyFdKxoZlgkYwsnvrO0VmsP+5ReVZzP247/JFkvqMGPajzfQ25n+LHzqOnbgC7/qDxecvPKcM2Uh0LKwYQcHkzrnV9dTG8koBa8cmPsy97ijyw0r4aeaa8bPAShv8MZiaeC+zhT0lZPlbJQkeYvUZ2W9oh3e3IyqesE/ncmhiiOy7fm/TbV1CfxREY0+QcryMTG//X8+fMoayzPchDxknZ53EfXxYchZiWuJKXwE9jruIRjcNQ+KnrROzqTlvwzWWy8VLOHyQXCHgoYk+wXHpNfj/7cWNwVTDbD8ynjwgsZ70ugde+p4YIberiBUTrHJCaBb7z0NpRdn0M+eU0bi6df2yOQZlzfW4rayWrw67tjDSi+3rikno9Q9RihOmAAnXTAP1LtN8snbGoMpOnxepCS7JEN/7eX9PtqcNmJZdeOkzzkVybQ6crQZO+WBY6tWwkNcfz8pAtQl/TC8Z81ElT6KDzeeLWhZ7IvBX9PtvgDUZDLmKdQICkz0/RuAwfdlMnvd1yowt+6KHh6CWgal8Al/chjhu/utvlP4fHx9eHr+phhzctDutYB8TA8enq9odFXyh3/fm/u0ZhYEuKtGx/LLis3j+mPdTXmhVJwJsbsuTqQYOOZl3cljrpsHhPuZhrZe/DC27JJ68ZaYS1g1aD/HcySeixIDpCTuJjhdsx/AG/LjswPTjwSv8BOPIL2XZatLBTf9MU5hhLjdohJg0t9feL18ihWKz+lqYMB1wLvLlBIDsrCEH8K7+88Ag/LCMSy3OiVGEyPe7tSuSDTQ5zUHiAb6Am6+SozFscX7FXS/a1wal3GEv6rDdpMsV5bxnxkfcqfgrl6te+xa7Ay/ZLW0vW3q/Ya/KtpTGttEVa+q+rsE4Ko6TtBL7eVoXxv46kPV8F+o7GdCQKLM7fzYq2fqsOmu1Lvd+bOjScD3saeR9v6uM8zF334frjxsol5LZ8k0Yf4WBmGGwT1vBJr/2/75jXd72fM540dME8fh0PX1EtmyHKnCCHQCG/g1jWVqWMGWD7YjuBF1Sgz//AjvxbTf9ongAUpxv+91+zq/7Sn/1f79z/tOfuf+1PD/9FemP/pP8Kd/2kv/h/XFzUN/q8//+f15f/5T//7R/nv7//3L8X/x/3/j/7R/4/2/1/j///f/n/OL5r//1m/xutTWf6EN0TTWEqwjP58emvIfLT4oQv62f+nPYX/e33/e/3/3J8Z/hNf48W63DsuBT7dvVpVVZfb7ZnG6o28Dd5HW/5zva787/u3uNaOlYuj+P93/Fmut7hR88XOeV3+0/+t5lqbxk7HfGtet7qbf7tdfIStNx6LQzW7wv91/aDRr2wkc+eOze3qRsejuYVc9Lf/anx8mv+dP8UrMITP/hFq5ij958Gcz/0/48MHLMTur3cXbULIBhxL1mLmNd4E+7xn3zLeYDv/d9Yub/Ey4/9TC1G6KG9Fzmctivhzx5LmErXuE4KQn8zvLs1wcD1aopis+uUVwEk//e2YKYIae0uH6UduE3u7uyZ5/n2KL1yFPHPwI3OX+esLEKBIfOmhFE/Nwtp8gJd3Kl3+FFzNkzke4M/7EnvYv8dX0f/sqWke8qjWWGNQCdbtfOLd2tzLid8j5PEjLdpne3hmiFFZHv8dXjR4RLlcM5K89YJP1Tenvx8F1ng/wmJi8Ufo8cWGV/2PlBv8X/UtlM4PseFj0ZmlGrpHn3q0vk0K4eu/6kv4I7oXrb2R3rpXwGMr/lftS9RkOGsE/uFcOAx5d7hDDIdH5PGdfy3y/SQRv+0B8RI6KZGF4gipQ8CSwEM2xYkS7dUROO9pm74jJKgxfZ1u1Bm1p0ctknoMGKmXuOF9H7/H4iWof5bJi+u3oj0+yzaUOnI84PGwqLn4ENH1tKGZLRU5q3fuyVqdharteHgktRj70afGy9GGxkhK0GPxz/NZ/R4DjefJxIXAu31k7F+aRsRC77C/1SOjSgbisHFSZNz5rsa5ODhUfoxf3q57s/q7upTGkSFr7x+RbC7+3vSZm6Tf1NsfuBQk93UCuF+baUCCsQmxZp6f1BRMkbdHe1JIoF0WHL/p7ZHb/BgK5cvSK1/BGI8faW735oa1cbKuvlZIq4fMUxzGUpbxjDwMcbOIURSyEO903prs9rhd+C/9uEg4yHePYeX9t6jqZOO6d163ZNH3S3DHuxC5tRd6JM4Mu7emOcCPeJF19/M+kX6At7h/VibrCaPGN9tl8QsuvPe3tA8yEQqnNt3Nz/5+egf3JMTCjrkBd9J/nmXEvxr/pkX1iPg69uhXkO/J87su+N+ZBkbB2oSMX/3cCIIQit7OUizo9xLpDvknIPW0O5uMR8KELY7UUd5u+N/jEAxuwY2A9rdgSjsZty2Bm1rThN4lNtrPICKGx9mLeb8Wea1kbDCU18RgaecxC9aOzbraA54sVZ96pvwNcea5fUn2GajeRfiH3tBlquD3qsj2nP/tIR+ao3NrKNfxGPzreuK0PZH+/m1pd8bUWxZCFPUlta2Td9C/AM7+0b+Qei2T0/Ks/MIcG9PPBTsVj5f+QfBMA3gxhM3cCce75ielvVUSvc7eKdQPzQkL545zO/cpJOqZhQKHde7tIfe+x+rPng/7cCzx0WRmJBOdSsYHa+iuezd7SH/efo1ffVyk37XpMf24gJcFqiIxvv3+vh771tosqPvVxkPgpi8hgFyIS95tE4pMJjxO4HyaMOw8wp1tszl6tUgZ4zfFYW6ffvD41o4d/SFbDX5cZJ8u++2q8aE9KSwm2dFjnbizuKdiQTwRZOjxuvqTEVT3QVQKSF8zUdHSBh7zNH49uk/W7PEvxMhLdsByPVUP+6Wmd9Qph/wZQsTI4fQuxDPOCtPUjFdvl7YfLTFZpuDExfS6DFUUXzVJio40oviibH6RKCdoH4B54JYp5FocSWPqf8LQUXPonSXBfG+vYPzX+21W+SmKBOp9eb374c+/NjPKHeTWcGxK/751hEyIg2I9qfj7MTwhFX+5uw27Ayzpeyi2eeeQ4WvkvarejAsB90+t3/Mhgk6/DbaabbARm8+DseseClBfSan0SjN4ACqleQ6lgkGA+Uyej5CsCugRn793MbSYAJ6I/ryaYCvyw+Tl4KG8eHg3PE3udoJwgDiXZcy8LzeS2HFcPmR1qNBM3hqPRDEhgkx/QdroPnYjGVxBi+43CaDZP4mm3rHmAOHjejHyCB8EGMw3AOO3daHGKn4UZe8b8pqiOu72wwsa0NjJpUVB8oZ3M581k3s/fEDajEgHD2ZowHV3EhJ+0x3Kn1jGV22abuDIpfJxzvGgSK9WVyWKTksoDwj8cY+ZRMCpn72J8r/97zIWrM3tV6D1YQ5ZvBN/+2vs5vEbGffeExJ8usTzVQk/6PUM8sHcwoigTareCJtxVkSBS5q2ys0JGotoLdVppyLwX9k74BdhUOSX4cJBjckRuv7D/oi1a1bAt2nbsjphUqTLRTdoaSxD47sXnxX8PV/XjD3r4HSOf/uHzXflBWkP76/fdv8Jf++fyhd82oQUjYqkDH0D3NtZQtOuVeuF7Yj20T8SAuPhjYT83HFDqp/mAM23YX8Y82vmIGin+OHcyUkB3vyeruzaIDS+x7IUa2fkgKz4YeV1ZSCkp+8XJqi0DmpeRdb8+p4MgOFnZly2jeaPemvutyYkFD95syp+taL7G2zXs78bPyiAtkVorUTLQL2xPpi6q6kBhnhjsTBaJ0U2uM/9TiVuCe9JSnC7nKLr5fkzSPH3jeYPF3C9etEBGh/Cy2QU/t6PNI9Gj540u0SSodlSuz61CrpGDOEBnFQF8cMlLr9ihkikrED5CDrpQxAIpW+HJft3Plv+2GB4oflN4HDwBW+WUH9wo3hwE7o/UfhfWaxKdH2i/4QSyaASSlsWRPLqTirYSP09DIE4RZKFr7L9+Se+Tu2gOLJF6/9VpPSxOBWaH6ZVGPyAxQANsW9JjPt7Plg+X0uMSfHUABXnUonJ2RFKJcyHqd3fItDKZyBj9WsmpPWW2XwMvhv8O/NQ9CCdtkClteNXa/IUyWD17baOtgHe3dMdHP5E/V/49zR4325QRF2MWPIVofjTh9VuFiJmRaD+AhQYzo7alXkYOvy7LdBp8HC3Oy9dAZFxyrUPXkeItIzseHZH4xPLeuV/bwP9PvVTKJYkehQfHyPwpKWfSqjc27nzeDppgdSV37e1z2j859Bp9k2YNqiA7IOTyPvfUP/yR94szaSItNCs7NqmLfReagcbWUDx9er87XVAFN+i0bEjp7rTDC1ZTBiRg6kA4o/6VOYJR/P3Il/+ZOV/359tjrvyC4bWZ7kJ1DZu1NRITf6AtyEiV2jTmiASzzuaf0obDoJW8bGRYbFXKOXcCQLv+6Pn/InmR6A6BOY7OxHSJTA1ZtLTCiXFfT8WmWcP0NVPiXMWE/X/Ux7dZkbBAl0yJx4vpmZz8HiRzDG987/7H6pN4Ay6v5ON2M3RWXMEjfFwyWH8vBppXJ/TS7ySBtqRTrxjM0Z6dgwXTAH885Axek+GyLa3vxqW4W/WjqeN+H3EPWcjXnPIBzm75apAAo8PjaF9BhZ7x5vrOd39OW9CnsGLiXvf480j0tDWS8HLGvzTF5rofnrEf8/45X9NrM49jsg9jQlbvsR9UzENm1L2C6PYFUtpRaI8zGHPL1hVxQFq1KhPzGR4Gbsu6R7FtE555OdzXl7rfhq8q0UoOV7Hhtg/PlB9ybVHWhtO15a6Lbgyv0cNXh/+4nO9y3CBn2fvOPeJb0PhF+HvXhSWs9IpGZsOPqMbC688nFKe5m1TgApkSnBuU9WD5l/ni4lYriF8yolLfuZ+CzCXt7C3njgNIEKNHHdaraBT3F/ikXG1AzJ8fuRCx5oNuJU3hwVQYaE41KeXc6TIAE35zutrowNCzt4ZYRP5J/au0dUOFBkYwCOnfSDt8rz96f8hXhTuij0em8wBWYOMxocAE/B3B+2/+lQMkyjLPkGrUhhzHECVg5ly6DloVScC75+Jm1VKT1Axt+IzrWQlgL8zs+1es7RGSj6473Tl8IXmcZCk68aVCqI7fic2q99rnnqc5brumQ8NpWZ2FtFTC67OZuZty6RGvpdK8XvlChJEmgWyL77CFuDbL1vFjpIimctSsNzjHUJpKVH3W4D4v/mrKnT3WgkJZHViXvLTI7xryTaV3j4f5O9oe81/i31XgAvY4q4/Pp1HWZ90JGkZGEC11sVsFEdpJPt1r0QxuIB3nsOzu3EZim++JNVLeIu/C7u8Yf5sCYochgBF/HQ+C8TzNfz2L7LrZfyZPTKTEp/Qw1fseD57xt7x3OvVmLkFq4wzsnLDbCNG+pzO206hDo7GC7+dtrxKllDYt+rHUsFseEcR//Pd/XvAFfUAO55sRIih/mOxe3mux8HNEN/9c1XwGLcxNuG5/eLtjivKOew9b/f+OWuqzxZ8F/OdFnmA2j8znnTfDXc8bn8QTKo83iV+vC0Ct/2MuHjxrEdKreq7J0j+OKzFgx/wX16rn05+7SF2PqMkvpPS5R0fbN80ruRfOD3QFJaS40MB85VczSfK/+q7rGKJhznST1j5rUz9sZ0y33/WRKu2N5KXemDk1pIhuKnn44u7U0mHPF+vccY3K4RuWiSaggXRA2TJTMxZdNMikCP56z+0UoMKpdXKtjcCjX8BK95pXWORfn/5svAh9J/H48olzHfCyXDaaYpfoWM08hfesJo1/5uQf+1T5m0dK4GH5mn7Nevxl/BV6+f1O48HBLzW94uX4+j3/31WGibjbMGzkhBBFSp5W0ByR4EMHBNPSourUXx+Ea0ffn9XoRcsOM/44Ffi1c8igL3XigLOw1K2d2nH0NxvrTNZnXiAc4O/r2lP90YUqu8L76zBh5ZFedFjJKsRceYhx2djGQ2IxC5Kw+SF9KWnjbef//VVMJbU9/kLJFeRheIah11B+Sltsy/Dxy84gFjSjm3UmB1Jz9Ls9hee3aC7FdXcb9f5ANFSsnvquhYhDe+4+rVJSSODr08NK3CyCGxxDZO6nw1F7OUd49d0BNDjHFudF4sYgXUY+PZeHESHLYsc73guAtKH+kJeFEbkYOUMJWH+KmyKQmQdvzscBGjzdkXMd7URwBbFk/ua1SgCziyzp2oJNlSDlRat93GrwBr/+kGX3YgQr8zgLRLip0d1lPzhEnah8TeXFIU9eSg/+Bf5ATJHeR7vSNEszgPydxrJkHF3I2iZ11I807ZWlz1i1pkf1KbcxkuGXF71MpI1thmv3jSpK/VIvaCJPUQGGP8HM69zul1YTvXr9mA4xSOYgfN11eMB3t50H49UgwqFWtdunVfrL+8yZK9xw16AuO2+6eXHlUSNX7ThXen36XpYloPJ5D5CiRtpf+RM8KPR8rn2S2FJrvSI27Rz+zcSMvxU3fIlSl+yxm+SjsPj/vQ9zDQO3/ddZ8H9NjwxonzTyP9aHDPUx8fxhHuNK0rYIvwP7Rtzf1ZPuhZQ8EinlD8djxyeVplMNUr9kIBp5qnWXuM7k/Tnx9UDjxREhFKLn91x4+zZOhNHhB+dvI2LslCSR2DV9CJLhltwrzmPuAicU8aE3OX8fPp4Hi0qCB5+P97G6XNAy6xRvxDfv5uImwLy50T95KHfqzmKxt5Vid7irhCzf+aJYI1DyiwKiv3WFW6G651Ns+r5Zmu8LOae+Pti1yPuWSP1iuTuOHEUeUVyPiXjxd82WCaoce/4K5R3+2S7D15aQPP6nZJQfFdkRYiUXnlk2IHxo++VA7Z427yTjbGaf9zi/beQjQtl1dgVd4lRfmlXzFKjamOhYHSAkRjEPtCFfTHEk+g7IP/Sh3uBG2hk/8/Hf6uZ8s6nSbWWm+MEfgzJJpT5hF+8AQ3j3gSLDuWIOVqsUaAKOkaONT08JUVSg9OIySkKoJVxf99SMZABPOXIEZWyvIxz3LG30lwCKLn611jDAt5A+JonSV7QQmOyG4q/w20caDV28Myq+hAB8m7mEQusqIildMlfHok3qC+zUnmRgvjvljw9vr5oXuYf4rmN76E/PLxm4zFLd18EfELL56EHmMxTT/js4WKn0NIoapDL/ViBYyOx/33Ed0U8bFrXnxLCH11IGvH8cCcDkqDOQ3mdVUJySjYF8tHT3s2HQr0x2+6AaRDIpnOOOyGfn6c2Bm1WQU3XVKQhAhnp4zWB6RdntUh0g/xdsfeZ9Vjr6Pk2eZ8C+O/zf1aIc3Y/wZR4t0dybiXZkgoefZb7g1lTgPLzZ1z3si8vD//3+yHBxuoH+BaytX1kATymxBWG+OvhX9n4Mgu/NjgK5cc0btYZYq9M8foG4b1HilObzlg0l3gebXyY9TJTC8B5t9dPpb7eNSc/DXR3pP+EOKg1O6YExE9lcpckTK68y3U5M1a+xwGup6P8mm1E+HGKLNCtx7x5JG0HBGX7HsD9bf6SJHCEi//v+6lNoo7yYmTnhS98M9/jDqE0fghI3GOvjvQu6hmNW5jNNP77dGecTIC4MPWOUXPykhWPHp3cN94BwoctUCoj1zo6xJ04Ec5QTC9vJ2XItZgk2Pj/vP9oZfbGr6fNyCflsa1AkSECP4C7htxMhkmBGp9+0X2PrZXyjr1ILpz6fm2cNR/f143TyQs7CbGmbPupeOzH944DxxG+LC8lwbxXiObPW//eaL2swCNG8elwYu69cMowOi97dUi/IsdjSj/bM70TIU2fDd+1xMnhChX1SSN81ZLt2j/mz/Fwz0uYlaztAeE/XlnHiaHrP/mLjMFFaR7be4c0RS6f4e1v2dZ2PBB+AcG3R1NCecziNrDOiXQiHLSh3d874UmI8cNyhes+Iv98lKmF/3/tXWlz4kjS/isTft9v7rarpNK138TlC4OFDbbpcEzoAtQICYO4PNH/fStTQipk3GP39E70zkJ0dJhHdWRlZmVmKRPpVG/w833dfg7rN1JrXG1P57enZ70+3NCzSJ8fziZTkx9NzqRo1Hzo1q436qJ+VZ9Urcu4HfXZA7z/yD6Vv7oGDR/r1cSsxRFxeo+W2b8ZVCpevcHjZ/nuUr7dBG63cubcrjeTu7DG91fjgtz665eeaZxXvK+tdbc9rsqn64vqmC0aVqXTlFbhUDlPzD4/brYbjxOnXr2a+qS+qiiSVWmc25Xeudztm48kHpPusmeTSqDLjeT5JmHWRa9yExNTezDMWufFItP75UO90nq2+6fTdtixKmcLiQfmzW7HTLxex58nao/754Hb6Z4rPd9qXVWMr521VlubvciTLOlu2qlXXXh+mhV4fatx/3J24fTbtGH67Ye6fTWA5//Nw5uzbnvZkjj/kkR6bsHzta6sB+9hevli101ZrnsLPuzMqinR6mF2qz/w89EFJc9kTewuF+CpEzSs0dpqz5uUhl/HE8M0L24W8kXPsUk1Uur1ARl4oVXfnHaaL9Q4a5nj2+rk6+g47I+rjXnzuNPnZ0zLvOYHkcfQe+Dx1e3N1VW7YnjcWM6fj88arjKzqhJxledGm49fH17fOc9Dq18365P212A66DvW1Uu/0Ro/PnP+tqT6tbE0nS4/1iyul/1wND23bvqdHhs9Oo1L82zYdM6vL/3Heo1OWDS1gvjYqktxW53RVWNkRrLkJJdG3+b64S43MxZTeD+zkgx7q8f70AycxvWSWA3On2jTZLYRN1bWpfJ4VzkL27JnXt5fhbLbIk636uqx1FL6Pddqnd9Jp9O6d6aYpvHVWfk3nlU3b8IL09iQFbOuT0f1s9r5ILw0Xa/Vc6vK8K5eGW86L82FXmlYDae3OdZJyL2xdXz24nkV2+vWZFmxaqPV/NTi9uIhlgJ63zGbvW6bLIe13rhWqw/1eHLKj9NXQUuNboen9wqf3t/cNMZf7+uV+ro6+hrKrcC6rq2m3cS2+PnhVL96aC6i4H5cs8PN1fLGa91ZtRB+f19rSS3TtCdxr3tcf6ib1aXaaHZlJbLOp5PxilB30jPD9fza4zukN64MZ+NukzQ5ze1uY/DIyGm9ZVYH9/1780Hi+jv8utEcnVyfWo2H7vOzP1S/huZZ/6zmdI6Xj+OKk5iV5ErxBla7P7hc9C4nXWom0ji4WMyju251lLRWx91GWLWarZv64GzY701N2t5UeovavF+vddWwtnlRO2PripihX63dSp55Nb5uLtnspl/nsZGssfPZKLBq14N1+Ly5fKiY0VVS4ZbfvO9Wmp1OOOz5l45Vrbce7o5fCOePMnQvZ02XPXZr7eXqwjge8BNKXY1GY3e+JIkJ73x03dFtd1x9OH8OFr1Vr29dSlHYl/t2l58tk5eF8qCdPnar1nIc3cWN6aXVvkhid2253Kd9XcmLs7PgxupW+IHM8yKjUrFastJqkZFMQ9OvOXRzeu7y+H1z8bwavVxax9b1md+HN7aMFa74vU5vfjHh+rO4eFCJkxiOdX6rnJtT1QtbJtT83fVj77ZrHs+6/tnKDh2rMZTlEenTu7U5vRq+GOtawvdPZ9DvzEkluYDn52n3XUnpXppH3759+u1o7vqRf/Sv3/44mtozP0r4n0fcKBzxS4HHv1D+R7KZQpOjZTK+D/i2ak/96KzZ8SPPn3HAi1fQfDqLp/4sCfw5DhctJo4/aw+a9safASTBdJ4/hW6Rmzb7sjMtfKjhqI4rU4UVNBRXFFtmioxXBKJEevzZHloc2x0PZ/EigtG+0BPy6bftf0+8dXFZguvkRPr02/Y/uL4M/NU0niXpRQJ4aYRkFd8Gnu81g+EoCaJhxrgQvjbiMIxXVXviz+wtDjzhfxMk1Z/7s6VfjcN4VlkMBq+u1PxpMtq5Evn2rBoG0ymf6ia0I/8uDvnokQsc4cQRmMTNGnTsaOjX11M7mgdxhA0Ufnkx929HNpfdPBuUAzjTje+H6RIAjV03XEDHjp0EcTo8hyf2OpgsJq1MyNAHxmEgsijhtLhJsARq6LulLsi2JHXmUmar+6We8fW1zAexa4c3cYCzfPlM2Yks6ZQQiaQfJRMjx2VVUWVKQZDTeB4kKZu+fJYk/USiBjEkKjNJVlX502+fJYWdGESRFZ2olPKeKtcCQz1hisRDO1nRdEljudp0p6+U5qksG2ghU/1EI4RR/iGqofOZmKqdqAqVJEPRZKIb2hNs2A+yzrFVZpD9rDPdJN63W5bBPHCCMEg2mbpOA3dsO6GfffVm9lD4yvWmAnsHOiezhQ9KMwuGQbS7cpKuXGTwq4tzLjJ/7xblI/JF2zs9P4tdB/HM9dtT+3kBAwzscO5v0Tu+M+bhwk25tr3EyZ5d28ksWOcTkj3//dCFJ1B6vhbcE1++HM395NqeTtE2feEbZJ7AXv3X//9RSFA2BlzTvh09PUET3uEmFcrm7S5Es5mOXZ7ebVkLdShb1pSAkqLkVJd1hJumOASjFfAJ+azJXTzlBmy4yczGDI3xXTDxc5Nhz2b2xnRdfz6/jj0/awgit2f5PsCmus7kE0ZU3dCpAZ+nVF7NOObnvTvQvdudbsVAvbLuumhWNyZM3rKRnM85ntFB8+4CgGaMr8lOssnmFZ+rkw8syczjaylfRNNFUrMT+88E/dnjjXgHQeDC6t7szS2V5g0+JnNBsvtlvqWlJPubONxkSylLfwpmNf1zZM9H0EEZDDSHUslzPJtqRCWSLFHHYITptqQq+u+UMiJ7MBgfuxra83k+Dw4Gbi2Vz1GBAGV3GUmNMLYTlaEksXXme6rxZBpHfkqQDKIMXlCIMCGoIihJxp4JWqXPqsItK6Ma01NXBh3VE8PQDI0xVI5sSH4hWoQh2t2sr8LtNG+myZQVndEYfLebpmz9Jv+myycqH0BSJen73YjQiRLthPsWQ9U0HhxpurGXUjQ9XG03u+LxZGZTz1FVxjTP0yRJIYqmaKrDh5Ed4v8uGRLTm3vEU/XDsOB5KiGYqSSdLheZLH1fOLQQDk63VzjikmWdkP2cxWUOAj/0ss7bhTqSrHmKJ6myPqA6MRTqqY48MMBRM33g/87HpPvUEFS9vE5O0tz/MUUU1goz/ulSX9m8vauG2JHHNZkbTPfhdo/O/GEwT2b5Rb6jM8N19O07ocOb1iGzNSWrsGul3gr6MZjFoF9RgdV2uPDfYeNHO60gQsOowE4W6bLyi2JoENkRTpd2UlUefinE0InMwzZFA6f8Pmx7GPB5tI4TCaO+cvDgz5x46e823Alb8obcc5mv2gphSOXVjNuLdjgd4ZkBFWXpQ8B2myoVOrEUqQpqUrTbcWWev+aHExRd1ijJIrgvXxS+DzUMYrkxkhQF/JHC1U8Dnhhyjqm8m2YAphQY76JTDIALjHeB+JUaeoFxW6UzwIwC48Po0A12xxZTQTMAK2hROR0GAYwVGB/GgG6koEXjbZBcohUYb4PkkoIWjQ+N5JKCFo33Q3JpQYvG+/HzAoAFMcgoJI4W1CCnwNdwRSpAHUD4Tgve6KAVSB8tCEIGIoG0oEjnc/CjAP8ukQIEtiI1UkGnDnRSmF0q6ATGUqRGKujUgU4Ks0sFncBuitRIBZ3Ab4oTSwUzgeEUJ5YK4kFpqISzF8SDGCjOIRfEgxwoziEXxIMgKA4nF8QbQCf2lAviQXMo9hRAlA+VYXpZEVCgFJvJqoACVQjImoCCWiIg6wIKxMqwItkQUCCMAQ2MCChwkAH5jAoo0AvRxA4K+kUZkMokAQUmMqCByQIK9IKXlJiwYhAqZUYZBT4qSJnAB5A1VZAygQ+gZVRhJRSkTRWkTOAOqBRaR3TXOQqUKXoZBU6ClZCYwDOQOFVpGQXKVGSBwElQBKqyEgqaQFVclsBJUAWqqmUUKFP1MoqU4fQC10FjqEbKKFCmSWUUKNNQOIKEQDd4FFlCQd5UU8oocFLTyihQpiG9gjQZUmaUUeCkTsooUKbTMgqU6XIJBZ5QnZVRoExXyihwEu3zDgqU6VoZRcrKq0CnqpdXoaALKa8C1IYa5VWAgmRuSUTl3DGJKLqX8trSuzNlWaha7rJEFDhplCWkkdyViSjNnZmgJag2pKxRqCCpkxNRdEtSSVM1dExyGdX3ojA9Ke8WVJDULYooUqaWdqGeu8sdlOWosLv13I3uoNAMHaloNVIXbpQsDKoCujQRRVWgZcuFQn+Noo9FeybIGIWeooKEUOjoFkVLi+J9jaLzLdtqFG+KFpxMxYueVfAMqXhTVBdQXIVaRlmOagKK9KIfUgVUzVFFQLUcZQKKq0BfKguokaPFilMxpCgVUFwFej1hxcguRAUXnzImRYW1IQtSVFgFLjZFhVWkkQgGGcIq0lAEUWEVaWdEhVVIeXwkxEPp34gK8VTaj+bM2KL52qggC6QHmwkBXUo7zVVli+YSoiJluYSoSJm+lTwRKTNyVKBMzvVMiGdTaeH0QuQrogJlKG8UnhBNp7qBpApxd6pHtDBqGarkqEgZrpjsRv0pSkrng1TDMUASThIZqu2eOdI9kqKC9uEuI4WDEdHCGaUo2x4TMneWoXhQkHPXJ6Lo+gQa2JYxmUsVUZI75QJFdmUOPEO3R5/Ulu+gWh4YZCjLmJiFFiKKIQAtoywPWTJUyVibBT0iCuSpWhmleTCVoWrmpbPAS0T1PEgTUW0b5u2gGIAaZVTZho87KIaPahmVtmHpFtUyMVBFKqF4DlVoGdW3ofEOqm3D6B0UpmRqGWXb8HwHxUBcLtGLIQCjZRS0hJW5o+LhRS+j2vbosYPCf3JZQhjeyGUJYSgk2nWUsYrHn7KWYIglWnBEIYqnklbSMwzdRAueoniCY2UU/hNtNeo6BpWiVU7R/FwpohisilaZbc9DVLTKKYqn3dLuTsNoysoonqFF7pBMZFS0yohiKC9aZQTwMLBjlfVMOJSoZRRoICXbh8JJ7w0IdjI90uxY5e05OL3jINhfFM6OUUZ+8yuGVgbl7M6GYOpRBkbJK+ARcMcg04zXO/YYiAS/tGOOScZpveTBkNGiMcbVgJvQBZKkLUP1kgtFfuoCSRIyGSYS3SrL+KYLJOFplGR3p0R3D1ZYNM3ICjW92yWGEMAe0Swjd3h/rRSWAB80MYjS0rtVopkGfsGCRSMN6grrFU00zVYmGmjgIKxBFUMnmt6JE40zMBXoVUthHtgp0VyDLwU6VIE+YDPQIRpwUFqYUykFqTC+aLyB8TCWaLrBV4LZV8TwlKRtxAMTyAK+i0cgUGCwCOKhBuQDxlo8vIB8YN+LhxTQXtjf4mEEfBts5vLxAraReIwAmYHGi4cI1FyYW6AZgwgpnSfH0ANzTKAZPZeczp1j/DpMI5AMouWttm7g6RtmMT6ap02zvnsT+kLK+HW+FqtJihQ6JJ68YDBYzMX73KqmM5lbPX6GNgjKgpzoTCOKrnNjJBkMzTQ5wYskbwzrSzOqf30Ye+JAqv8nETWf+u4itGc/aTjfeystIJCeZ3Yy/uY38LfE5A22wE28wtoemqW74qntZils/F7korMKnoyUV9luqGQa2K5fXYRCDc9gFkfJaxizR1k6Ic1O8ov+feAlo3zmUCho+o6+frcARfPe0NdDAcqvVYCiuR8uQFHdDxegbNVhTzECJ+CXKEChQFSevPunlJ1w7v5o2Yni+rr88bKTTJ77Jf1zyk583za4Qvm2p6jGgDDbkVzqMVV3dV/V2O/8yKGzv7XsBCb8+WUnWYnJf0u9iSsrA9eRDc3XHMkwZE31VJXZxCCax+Xk/s6IpLK/r94Ep/vTIgyFSNoH600UxzeoxJVaU23N1jVXVxXHNXTH8X2IG37nY+rvrjfZKv5fKTeBCf90pfzMLXEl4sc5PBD+baUm+y1CZl/+Q6UmO2t9OpSZHMpMDmUmOXgoM/l0KDM5lJkcykwK9FBmkqKHMpP8tuWhzORQZpKjhzKTFD2UmaToocwkRQ9lJgJ6KDM5lJkI6KHM5FBmcigzOZSZHMpMPv1aZSZvZWPT3O5fLjOhhzKTf1iZCfkly0wUlZurV/qaJqUq9uxHKk3IuypN7EUST+zE9wRoHcybtuOHQAVM6sTrm52qE7AMn7noMRvFr2bcAVGjTrBURfk4d0ES+jfB2g/bgwEkyzFlTLZX/XVym2zC9AFOg7jQ56P/S59yc4Q1KFHe6iiKZxM7zOEsZ61n3xv2JAg3aUpvFgyOvgE/OUtwObtkUIZkwNWfRgb7DhlcFKuWHZlRFCeiggJepLZuV3bijoTcFlwu0mK7l7+9KqTIsph3cZZV/PQzCyIKFT2kPw/pz0+H9Cdih/Tnp0P685D+PKQ/D+nPAj2kP1P0kP4s7hoc0p+H9OcWPaQ/U/SQ/kzRQ/pTQA/pz0P6U0QP6c9D+lNAD+nPQ/rzkP48pD+/l04iBqGesz/9ie942HNHfr4K0twCzVJp0TzLmJ3ALisSl69uXe//STLd/q5YfI/Bmz9ntsNtwm6d36be/kow8s1oiPeh5eyXsAmnboE3+3uQMJjnZIlDY1Ju+yu0c9/28pXP8cURZjFKOtkPvJ9AUiXivpFn/gFGa68ZTU6MPAebplnfyrruioE7L5XrsKERphvMUDGBq6kqYfwjc0dqaJirU2WZcDvIzY9i8Jb0F5JZ+m6M/4DUZJVq3huvYfnL2wOEs00YqTokkFBg8u5n7+aBH+QzZjBOt6JImsI0Daw6pFpVxZAUnaubbhAVPCBMy3RdI1x6jPGoVlP/R0QHv5P+aaLj4Z+uaPn/2gcMnSEbqgEGQNMVA380vX2qgsy4FyT8MCBLiqrq2v+IYDTH+wUE8/kfLpmnV1l/E19WlL9JaH/KP3sJ0fbJCbbn9QJ/BbVQb3bJnuLzwS5QkfWRLlldgdBly4P97bPY5t3tMxf97vaZc/hIe7BIHxqfbxSsvXhrm33/DWLOG8+jefcbxF7p+I+9QUxs8YNvEMOapb1vEBOvfPwNYp9+lfeH4dNO3v3+MGd/MaOhU/bGS7De+f6wdz5GKDOnpTd/UaHfqzd/cRwrE6Amj37/FV/7V+c4viO/enOTufbn/03PVyo9DekTKE/+70++oiuACrXMK47iVUY6DHb0ACzAarJH+OsF/upjTRl3PINgeJRWrsLjmfL9kQTTDjxhaLH1HGoG2l6wmKdqrJOdj5S2aPrRECsbcXeDGxokr4dKYWGw1IMvfbQRqPRrcx3M86InCY7+cINKw+Vudi6ybR2FjjHsy87FlElwxvlh35dtoA85slQrUytdmpb3F0ztG1OmgZIw5bu6OMUL0SZJ+vAnKiuGATeHeOCRoAH9AzZIxx9clDZS4TRSXWgPOkWt4btfIehu7fTrFxiCWB1/ZC+DtGbvD7GJTahNUgWeufli3wgevXnyZpPMTNiw+/ONy8k/2dVXzODswT4Xe/OdfZ4E05Nq0u0mcoEGPwI7sn2PaNmy88+/AVBLAQIUABQAAAAIACeXmlhVf3GjIPkEAOXfCwAKAAAAAAAAAAAAAACAAQAAAABpbmRleC5qc29uUEsFBgAAAAABAAEAOAAAAEj5BAAAAA==";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
